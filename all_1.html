<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Zhan's Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="Zhan's Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:swuzjb.github.io ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        <li id="menu_item_index"><a href="index.html">HOME</a></li>
        <li id="menu_item_archives"><a href="archives.html">Archives</a></li>
        <li id="menu_item_about"><a href="about.html">ABOUT</a></li>
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; Zhan's Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
       
       <li><a href="index.html">HOME</a></li>
    <li><a href="archives.html">Archives</a></li>
    <li><a href="about.html">ABOUT</a></li>

    <li><label>Categories</label></li>

        
            <li><a href="iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html">iOS学习笔记</a></li>
        
            <li><a href="Java.html">Java</a></li>
        
            <li><a href="%E8%AF%BE%E7%A8%8B%E7%9B%B8%E5%85%B3.html">课程相关</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="14814626217350.html">
                
                  <h1>HTTPS技术简要介绍</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">背景</h2>

<p>随着互联网技术应用的广泛应用，越来越多的信息在网络上被交换和利用，网络信息安全也就成为了一个被关注的热点。我们当前的互联网服务多数是基于HTTP协议之上进行开发设计，但是由于HTTP的设计缺陷，信息数据在传输过程中有极大的泄露风险，HTTPS技术也应运而生。<br/>
近日，各大互联网公司纷纷宣布旗下服务必须强制使用HTTPS技术进行网络通讯。如2017年1月1日苹果iOS应用推行ATS安全标准，将强制使用HTTPS安全连接；谷歌Chrome将把所有的HTTP网站标记为「不安全」；在国内热火朝天的小程序也要求必须使用HTTPS请求等。<br/>
本文将对HTTPS的定义、工作原理、使用、与HTTP的不同等方面对HTTPS技术进行简要的介绍。</p>

<h2 id="toc_1">HTTS工作原理</h2>

<h3 id="toc_2">HTTP在安全方面的缺陷</h3>

<p>HTTP本身是明文传输的，没有经过任何安全处理。例如用户在百度搜索了一个关键字，比如“苹果手机”，中间者完全能够查到到这个信息，并且有可能打电话过来骚扰用户。也有一些用户投诉使用百度时，发现首页或者结果页浮了一个很长很大的广告，这也肯定是中间者往页面插的广告内容。如果劫持技术比较低劣的话，用户甚至无法访问百度。<br/>
这里提到的一些中间者主要指一些网络节点，使用户数据在浏览器和百度服务器之间传输必须要经过的节点，比如WIFI热点、路由器、防火墙、反向代理、缓存服务器等。<br/>
在HTTP协议下，中间者可以随意嗅探用户搜索内容，窃取隐私甚至篡改网页。不过HTTPS是这些劫持行为的克星，能够完全有效地防御。总体来说，HTTPS协议提供了三个强大的功能来对抗上述的劫持行为：</p>

<ol>
<li>内容加密。浏览器到百度服务器的内容都是以加密形式传输的，中间者无法直接查看原始内容</li>
<li>身份认证。保证用户访问的是百度服务，即使被DNS劫持到了第三方站点，也会提醒用户没有访问百度服务</li>
<li>数据完整。防止内容被第三方冒充或篡改</li>
</ol>

<h3 id="toc_3">HTTPS的定义</h3>

<p>HTTPS（Hypertext Transfer Protocol Secure，超文本传输安全协议）是一种网络安全传输协议。在计算机网络上，HTTPS经由超文本传输协议进行通信，但利用SSL/TLS来对数据包进行加密。HTTPS开发的主要目的，是提供对网络服务器的身份认证，保护交换数据的隐私与完整性。简单而言HTTPS就是在HTTP协议发送数据的过程中使用SSL协议对数据进行加密，从而保证数据的安全。<br/>
SSL目前的版本是3.0，被IETF（Internet Engineering Task Force）定义在RFC 6101中，之后IETF对SSL 3.0进行了升级，于是出现了TLS（Transport Layer Security）1.0，定义在RFC 2246。实际上我们现在的HTTPS都是用的TLS协议，但是由于SSL出现的时间比较早，并且依旧被现在浏览器所支持，因此SSL依然是HTTPS的代名词，但无论是TLS还是SSL都是上个世纪的事情，SSL最后一个版本是3.0，今后TLS将会继承SSL优良血统继续为我们进行加密服务。目前TLS的版本是1.2，定义在RFC 5246中，暂时还没有被广泛的使用。<br/>
<img src="media/14814626217350/14814628384569.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h3 id="toc_4">TLS/SSL工作原理</h3>

<p>HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，本节分析安全协议的实现原理。<br/>
TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。<br/>
<img src="media/14814626217350/14814628187370.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<p>散列函数Hash，常见的有MD5、SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性;对称加密，常见的有 AES-CBC、DES、3DES、AES-GCM等，相同的密钥可以用于信息的加密和解密，掌握密钥才能获取信息，能够防止信息窃听，通信方式是1对1;非对称加密，即常见的 RSA 算法，还包括 ECC、DH 等算法，算法特点是，密钥成对出现，一般称为公钥(公开)和私钥(保密)，公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。因此掌握公钥的不同客户端之间不能互相解密信息，只能和掌握私钥的服务器进行加密通信，服务器可以实现1对多的通信，客户端也可以用来验证掌握私钥的服务器身份。<br/>
在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密;对称加密的优势是信息传输1对1，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录，且缺少修改密码的机制;非对称加密的特点是信息传输1对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密速度慢。<br/>
结合三类算法的特点，TLS的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥，然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。</p>

<h3 id="toc_5">HTTPS的工作原理</h3>

<p>HTTPS其实是有两部分组成：HTTP + SSL/TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。请求流程如图所示：<br/>
<img src="media/14814626217350/14814628698302.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<ol>
<li><p>客户端发起HTTPS请求<br/>
与HTTP发送请求类似，用户在浏览器或者通过其他方式请求一个HTTPS连接如（<a href="https://www.baidu.com">https://www.baidu.com</a>），然后连接到服务器的443端口。在此过程中客户端会发送一个密文族给服务器，密文族是浏览器所支持的加密算法的清单。</p></li>
<li><p>服务器配置<br/>
采用HTTPS协议的服务器必须要有一套数字证书，该证书可以自己制作，也可以向组织申请。区别就是自己制作的证书需要客户端验证通过才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。<br/>
证书其实就是一对公钥和私钥，可以这么理解，公钥就是一把锁头，私钥就是这把锁的钥匙，锁头可以给别人对某个东西进行加锁，但是加锁完毕之后，只有持有这把锁的钥匙才可以解锁看到加锁的内容。<br/>
前面说过客户端会传送密文族给服务端，服务端则会从这些密文族中，挑选出一个，比如百度采用的就是RSA公钥加密算法来区分证书签名和交换密钥，通过AES算法来加密数据，至于GCM则是用来校验信息的。</p></li>
<li><p>传送证书<br/>
证书将在接收到客户端请求后由服务器端发送到客户端。该证书包含了公钥、证书的颁发机构、过期时间等重要信息。</p></li>
<li><p>客户端解析证书<br/>
这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，如颁发机构、过期时间等等，如果发现异常则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密。<br/>
注意一下上面提到的“发现异常”。证书中会包含数字签名，该数字签名是加密过的，是用颁发机构的私钥对本证书的公钥、名称及其他信息做hash散列加密而生成的。客户端浏览器会首先找到该证书的根证书颁发机构，如果有，则用该根证书的公钥解密服务器下发的证书，如果不能正常解密，则就是“发现异常”，说明该证书是伪造的。</p></li>
<li><p>传送加密信息<br/>
这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，然后客户端和服务端的通信就可以通过这个随机值生成对称加密的秘钥来进行加密和解密了。</p></li>
<li><p>服务端解密信息<br/>
服务端用私钥解密后，得到了客户端传过来的随机值，至此一个非对称加密的过程结束，至此TLS利用非对称加密实现了身份认证和密钥协商。然后把内容通过该值进行对称加密。</p></li>
<li><p>传输加密后的信息<br/>
当对称加密秘钥生成完成之后，服务器和客户端之间的信息通信将被该秘钥进行加密。加密后进行正常的HTTP的信息发送，该信息可在客户端被揭秘还原。</p></li>
<li><p>客户端解密信息<br/>
客户端用之前生成的随机值解密服务端传送过来的信息，于是获取了解密后的内容，至此一个对称加密的过程结束，看到对称加密是用于对服务器待传送给客户端的数据进行加密用的。整个过程即使第三方监听了数据，也束手无策。</p></li>
</ol>

<h2 id="toc_6">HTTPS的使用</h2>

<h3 id="toc_7">SSL证书类型</h3>

<p>通常来说，SSL证书分为三大类，他们的安全性是递增的，当然价格和安全系数成正比。</p>

<ol>
<li>DV（Domain Validation Certificate）。DV证书适合个人网站使用，申请证书时，CA只验证域名信息。几分钟之内就能签发。</li>
<li>OV（Organization Validation Certificate）。OV证书需要认证公司的信息。1-2天签发。</li>
<li>EV（Extended Validation Certificate）。EV证书的认证最为严格，一般会要求提供纸质材料。签发时间也较久。
<img src="media/14814626217350/14814632071178.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></li>
</ol>

<h3 id="toc_8">SSL证书供应商简单对比</h3>

<p>Let&#39;s Encrypt是国外一个公共的免费SSL项目，由Linux基金会托管，由Mozilla、思科、Akamai、IdenTrust和EFF等组织发起，目的就是向网站自动签发和管理免费证书，以便加速互联网由HTTP过渡到HTTPS。<br/>
StartSSL是StartCom公司旗下的SSL证书，应该算是免费SSL证书中的鼻祖，最早提供完全免费的SSL证书并且被各大浏览器所支持的恐怕就只有 StartSSL证书了。首次申请StartSSL免费SSL证书是免费一年，但是你可以在第二年继续续期。<br/>
七牛免费SSL，七牛最近和亚洲诚信合作推了赛门铁克Symantec签发的DV证书。</p>

<h4 id="toc_9">对比结果：</h4>

<ol>
<li>申请便利性：StartSSL和七牛的申请起来都相对便利，Let&#39;s Encrypt对环境要求比较多。</li>
<li>有效期：StartSSL和七牛都是一年，Let&#39;s Encrypt 90天。</li>
<li>证书兼容性：StartSSL 的一年免费 DV SSL 已经被 Chrome、Mozilla 封杀。要慎重选择。Let&#39;s Encrypt总体来说兼容性还不错，不过肯定是赛门铁克的兼容性最好。</li>
<li>售后：免费证书其实基本都没啥售后可言，Let&#39;s Encrypt 基本上只能求助于社区，StartSSL和七牛都有官方客服可以咨询，七牛对中文服务的支持更好。</li>
</ol>

<h3 id="toc_10">七牛免费证书的申请和使用</h3>

<ol>
<li><p>在个人面板-&gt;证书管理申请证书<br/>
<img src="media/14814626217350/14814632233597.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>申请完证书后跳转到证书列表而不是订单列表，具体设置要在订单列表中完成。<br/>
<img src="media/14814626217350/14814632320729.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>DNS验证</p>

<ol>
<li> 记录类型选择 CNAME</li>
<li><p>主机记录填写 cnamekey，点击复制 Key 是复制全部字段（注：万网和DNSpod平台cnamekey不需要主域名部分），见下图<br/>
<img src="media/14814626217350/14814632427561.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>记录值填写cnamevalue，复制全部字段，见图<br/>
<img src="media/14814626217350/14814632609686.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>其他选项默认即可，见图<br/>
<img src="media/14814626217350/14814632750932.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>CName Key 的 DNS 解析指向 CName Value 操作完成后，系统会循环自动检测验证，最长不超过24小时，您可以用 dig 命令来自我检测下DNS解析是否配置成功，见图<br/>
<img src="media/14814626217350/14814632882974.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
</ol></li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/12/11</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AF%BE%E7%A8%8B%E7%9B%B8%E5%85%B3.html'>课程相关</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                      
                        &nbsp;<a  class="ds-thread-count" data-thread-key="14814626217350.html" data-count-type="comments" href="14814626217350.html#ds-thread"></a>
                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14786108252793.html">
                
                  <h1>Hadoop搭建实例</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>本次课程要求自主搭建Hadoop集群环境，并进行MapReduce作业操作<br/>
本文以统计知乎用户地域分布情况为例进行统计展示</p>
</blockquote>

<h2 id="toc_0">数据获取与格式说明</h2>

<h3 id="toc_1">数据获取</h3>

<p>实验数据采用爬虫方式从知乎进行爬取，并保存进入数据库，总数据量3383054条。为了后续处理方便，我们将数据从数据库中倒成csv文件进行存储。<br/>
数据爬取代码：<a href="https://github.com/wycm/mycrawler">知乎爬虫</a></p>

<h3 id="toc_2">数据格式</h3>

<p>导出的数据格式为：<code>id,name,headline,gender,school,major,address,industry,company,job</code><br/>
<img src="media/14786108252793/14786149854526.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_3">Hadoop集群搭建</h2>

<p>Hadoop是一个由Apache基金会所开发的分布式系统基础架构。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。<br/>
本次课程实例基于ubuntu12.04、jdk1.8.111、hadoop2.7.3进行说明，其中ubuntu服务器以虚拟机的形式搭建。</p>

<ol>
<li><p>ubuntu虚拟机搭建</p>

<p>虚拟机创建的步骤在本文中不加以介绍，如有需要请自行百度。ps.为了简便操作，我们可以先创建并配置一台虚拟机然后进行克隆。为了简便操作，可以使用<code>sudo apt-get install ubuntu-desktop</code>安装ubuntu的图形操作界面。</p></li>
<li><p>建立软件目录</p>

<p>为了后续更好的管理我们按照的软件。我们使用mkdir命令，建立软件的安装目录。命令：<code>sudo mkdir /usr/soft</code></p></li>
<li><p>jdk的安装与环境变量设置</p>

<ol>
<li>首先我们从Oracle的官网上下载jdk的压缩文件。下载地址：<a href="http://download.oracle.com/otn-pub/java/jdk/8u111-b14/jdk-8u111-linux-x64.tar.gz">jdk</a>;</li>
<li>使用<code>tar -xzvf 文件名</code>对安装包进行解压;</li>
<li>将解压后的文件夹移至上一步我们建立的软件安装目录。<code>mv jdk1.8.0_111/ /usr/soft</code></li>
<li><p>设置java所需要的环境变量:</p>

<ol>
<li>打开配置文件 <code>sudo vi /etc/profile</code>；</li>
<li>在配置文件中加入<code>export JAVA_HOME=&quot;/usr/soft/jdk1.8.0_111&quot;</code>；</li>
<li>在配置文件中加入<code>export PATH=&quot;$PATH:$JAVA_HOME/bin&quot;</code>；</li>
<li>保存配置文件退出；</li>
<li>使用source命令让配置文件生效，<code>source /etc/profile</code></li>
</ol></li>
<li><p>调用<code>javac -version</code>命令，检查配置是否生效,安装是否成功。</p></li>
</ol></li>
<li><p>Hadoop的安装与环境变量设置</p>

<ol>
<li>从Apache Hadoop网站上下载对应的Hadoop安装包。下载地址：<a href="http://mirrors.cnnic.cn/apache/hadoop/common/hadoop-2.7.3/hadoop-2.7.3.tar.gz">Hadoop2.7.3</a>；</li>
<li>使用<code>tar -xzvf 文件名</code>对安装包进行解压;</li>
<li>将解压后的文件夹移至上一步我们建立的软件安装目录。<code>mv Hadoop-2.7.3 /usr/soft</code></li>
<li>打开配置文件 <code>sudo vi /etc/profile</code>；</li>
<li>在配置文件中加入<code>export PATH=&quot;$PATH:$JAVA_HOME/bin:/usr/soft/hadoop-2.7.3/bin:/usr/soft/hadoop-2.7.3/sbin&quot;</code>；</li>
<li>保存配置文件退出；</li>
<li>使用source命令让配置文件生效，<code>source /etc/profile</code></li>
<li>调用<code>Hadoop version</code>命令，检查配置是否生效,安装是否成功。</li>
</ol></li>
<li><p>SSH免密码登录配置</p>

<ol>
<li>使用<code>sudo apt-get install ssh</code>安装完整的ssh客户端；</li>
<li>使用<code>ssh-keygen -t rsa -P &#39;&#39; -f ~/.ssh/id_rsa</code>生成公私钥；</li>
<li>使用<code>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code>将公钥复制；</li>
<li>使用<code>ssh localhost</code>命令检验是否可以免密码登录系统。</li>
</ol></li>
<li><p>修改服务器的名称</p>

<ol>
<li>使用<code>sudo vi /etc/hostname</code>,修改服务器的名称</li>
<li>重启服务器使配置生效</li>
</ol></li>
<li><p>配置Hadoop配置文件</p>

<p>Hadoop的配置文件位于其安装目录下的etc/hadoop/目录下</p>

<ol>
<li><p>修改yarn-site.xml，内容如下（master代表主服务器名）：</p>

<pre><code class="language-xml">&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;fs.defaultFS&lt;/name&gt;
        &lt;value&gt;hdfs://master/&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;
        &lt;value&gt;~/hadoop/data&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre></li>
<li><p>修改hdfs-site.xml，内容如下:</p>

<pre><code class="language-xml">&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.replication&lt;/name&gt;
        &lt;value&gt;3&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre></li>
<li><p>修改mapred-site.xml（此文件需要从mapred-site.xml.template复制），内容如下：</p>

<pre><code class="language-xml">&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;
        &lt;value&gt;yarn&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre></li>
<li><p>修改yarn-site.xml,内容如下：</p>

<pre><code class="language-xml">&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;
        &lt;value&gt;master&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;
        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt;
        &lt;value&gt;master:8032&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt;
        &lt;value&gt;master:8030&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre></li>
<li><p>修改slaves文件，将附属机主机名添加入内，每行一个，样例为:</p>

<pre><code class="language-xml">s1
s3
</code></pre></li>
</ol></li>
<li><p>克隆宿主机，配置hosts文件</p>

<ol>
<li>使用VM的克隆功能，克隆虚拟机，并依次修改主机名</li>
<li><p>根据实际IP修改各个机器的hosts文件，ip查看可以使用<code>ifconfig</code>命令，样例如下：</p>

<pre><code>127.0.0.1  localhost    
10.104.234.203  master
182.254.216.245 s1
123.207.252.11 s2
123.207.24.98 s3
</code></pre></li>
</ol></li>
<li><p>格式化HDFS文件系统，执行<code>hdfs namenode -format</code>命令，对HDFS进行格式化。</p></li>
<li><p>启动Hadoop集群</p>

<ol>
<li>启动文件系统,<code>start-dfs.sh</code>;</li>
<li>启动yarn，<code>start-yarn.sh</code>;</li>
<li>可以使用<code>jps</code>命令，检查各个服务的启动情况</li>
</ol></li>
</ol>

<h2 id="toc_4">统计程序的编写与运行</h2>

<p>本次实验所用的MapReduce程序采用Maven的方式进行构建，具体操作可以参考文章：<a href="http://www.cnblogs.com/Leo_wl/p/4862820.html">Maven构建Hadoop工程</a></p>

<ol>
<li><p>编写Mapper类，本次我们实现的功能从原理上与Hadoop自带的WordCount实验非常相似。</p>

<pre><code class="language-java">package com.swu.count;

import java.io.IOException;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;

public class CountMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt; {

    private final static IntWritable one = new IntWritable(1);
    private Text word = new Text();

    @Override
    protected void map(Object key, Text value, Mapper&lt;Object, Text, Text, IntWritable&gt;.Context context)
            throws IOException, InterruptedException {
        // 获取每一行数据，并以逗号为基准进行分割
        String[] data = value.toString().split(&quot;,&quot;);
        // 设置word的key为地址信息
        word.set(data[5]);
        // 设置value为1
        context.write(word, one);
    }

}
</code></pre></li>
<li><p>编写Reducer类。</p>

<pre><code class="language-java">package com.swu.count;

import java.io.IOException;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Reducer;

public class CountReduce extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {
    private IntWritable result = new IntWritable();
    private Text keyEx = new Text();

    @Override
    protected void reduce(Text key, Iterable&lt;IntWritable&gt; values,
            Reducer&lt;Text, IntWritable, Text, IntWritable&gt;.Context context) throws IOException, InterruptedException {
        int sum = 0;
        // 遍历value相加
        for (IntWritable val : values) {
            sum += val.get();
        }
        // 返回新的key-value
        result.set(sum);
        keyEx.set(key);
        context.write(keyEx, result);
    }
}
</code></pre></li>
<li><p>编写Comparator类，用于第二次作业的排序。</p>

<pre><code class="language-java">package com.swu.count;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.WritableComparable;

public class CountComparator extends IntWritable.Comparator {

    @Override
    public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {
        // TODO Auto-generated method stub
        return -super.compare(b1, s1, l1, b2, s2, l2);
    }
    public int compare(WritableComparable a, WritableComparable b) {
        // TODO Auto-generated method stub
        return -super.compare(a, b);
    }
}
</code></pre></li>
<li><p>编写主方法。</p>

<pre><code class="language-java">package com.swu.count;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.util.GenericOptionsParser;
import java.util.Random;

import org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat;
import org.apache.hadoop.mapreduce.lib.input.SequenceFileInputFormat;
import org.apache.hadoop.mapreduce.lib.map.InverseMapper;

public class Main {
    public static void main(String[] args) throws Exception {
        Configuration conf = new Configuration();
        String[] otherArgs = new GenericOptionsParser(conf, args).getRemainingArgs();
        if (otherArgs.length != 2) {
            System.err.println(&quot;Usage: zhihuCount &lt;in&gt; &lt;out&gt;&quot;);
            System.exit(2);
        }
        Path tempDir = new Path(&quot;wordcount-temp-&quot; + Integer.toString(new Random().nextInt(Integer.MAX_VALUE))); // 定义一个临时目录

        Job job = new Job(conf, &quot;zhihuCount&quot;);
        job.setJarByClass(Main.class);
        try {
            job.setMapperClass(CountMapper.class);
            job.setCombinerClass(CountReduce.class);
            job.setReducerClass(CountReduce.class);

            job.setOutputKeyClass(Text.class);
            job.setOutputValueClass(IntWritable.class);

            FileInputFormat.addInputPath(job, new Path(otherArgs[0]));
            FileOutputFormat.setOutputPath(job, tempDir);
            // 先将词频统计任务的输出结果写到临时目录中,下一个排序任务以临时目录为输入目录。
            job.setOutputFormatClass(SequenceFileOutputFormat.class);
            if (job.waitForCompletion(true)) {
                Job sortJob = new Job(conf, &quot;sort&quot;);
                sortJob.setJarByClass(Main.class);
                FileInputFormat.addInputPath(sortJob, tempDir);
                sortJob.setInputFormatClass(SequenceFileInputFormat.class);

                /* InverseMapper由hadoop库提供，作用是实现map()之后的数据对的key和value交换 */
                sortJob.setMapperClass(InverseMapper.class);
                /* 将 Reducer 的个数限定为1, 最终输出的结果文件就是一个。 */
                sortJob.setNumReduceTasks(1);
                FileOutputFormat.setOutputPath(sortJob, new Path(otherArgs[1]));

                sortJob.setOutputKeyClass(IntWritable.class);
                sortJob.setOutputValueClass(Text.class);
                /*
                 * Hadoop 默认对 IntWritable 按升序排序，而我们需要的是按降序排列。 因此我们实现了一个
                 * IntWritableDecreasingComparator 类, 并指定使用这个自定义的 Comparator
                 * 类对输出结果中的 key (词频)进行排序
                 */
                sortJob.setSortComparatorClass(CountComparator.class);

                System.exit(sortJob.waitForCompletion(true) ? 0 : 1);
            }
        } finally {
            FileSystem.get(conf).deleteOnExit(tempDir);
        }
    }
}
</code></pre></li>
<li><p>将写好的程序编译为jar包(注意指定Main方法)，上传至服务器。</p></li>
<li><p>执行<code>hadoop jar XXX.jar /inputFile /outputFile</code>，执行作业。</p></li>
</ol>

<h2 id="toc_5">结果展示与说明</h2>

<p>上述作业结束后，我们就可以通过查询输出文件得到我们的统计结果。本次实验统计结果如下：<br/>
<img src="media/14786108252793/14787497512630.jpg" alt=""/><br/>
输出文件如下：<br/>
<img src="media/14786108252793/14787497741393.jpg" alt=""/></p>

<h2 id="toc_6">相关代码</h2>

<p>本次实验相关代码和所用的数据资料，均已上传至码云仓库（OSChina git）地址为：<a href="https://git.oschina.net/cobber/HadoopPractice">HadoopPractice</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/11/8</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%AF%BE%E7%A8%8B%E7%9B%B8%E5%85%B3.html'>课程相关</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                      
                        &nbsp;<a  class="ds-thread-count" data-thread-key="14786108252793.html" data-count-type="comments" href="14786108252793.html#ds-thread"></a>
                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14773646522828.html">
                
                  <h1>网易Java Web微专业Spring-Web框架单元作业</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>完成包含以下功能的Web工程，提供一个接口，该接口可以根据需要（扩展名，Accep头）返回一个HTML文档或者JSON数据，要求：<br/>
返回的JSON数据是一个用户列表，每个用户包含两个信息：用户Id（userId），用户名（userName），最终的数据类似：<br/>
{&quot;userList&quot; : [<br/>
    {<br/>
        &quot;userId&quot;: 1001,<br/>
        &quot;userName&quot;: &quot;test1&quot;<br/>
    },<br/>
    {<br/>
        &quot;userId&quot;: 1002,<br/>
        &quot;userName&quot;: &quot;test2&quot;<br/>
    }<br/>
    ...<br/>
]}<br/>
2. 返回的HTML文档基于FreeMarker生成，内容是一个用户列表的表格，对HTML表格不熟悉的同学可以参考 <a href="http://www.w3school.com.cn/tiy/t.asp?f=html_tables">http://www.w3school.com.cn/tiy/t.asp?f=html_tables</a> 了解；<br/>
3. 以自己能力为基础，返回的数据可以是接口内直接返回的，也可以是从数据库表里查询出来的（加分）；<br/>
4. 尽可能根据项目模板里介绍的内容组织代码及资源。</p>
</blockquote>

<h2 id="toc_0">项目架构</h2>

<p><img src="media/14773646522828/14773699877029.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_1">相关概念</h2>

<h3 id="toc_2">SpringMVC</h3>

<p>SpringMVC是Spring自身提供的一套基于MVC设计理念的开发框架，用于替代安全性较低的Sturts框架</p>

<h3 id="toc_3">JSON</h3>

<p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C、C++、C#、Java、JavaScript、Perl、Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。</p>

<h3 id="toc_4">视图解析器</h3>

<p>控制器在选择好适合处理请求的方法时，传入收到的请求(根据方法参数类型，可能以不同的类型传入)，并且 调用该方法中的逻辑来进行处理(也可以是调用Service来真正处理)。方法逻辑可能也会在参数中添加或者删除数据。处理方法处理完之后，会委派给一个 视图，由该视图来处理方法的返回值。处理程序的返回值并不代表视图的具体实现，可以只是String类型，代表视图名，甚至是void(这时候 Spring MVC可以根据方法名或者控制器名找默认视图)。也不需要担心返回值只是视图名称的话，视图拿不到要显示的数据。因为方法参数对于视图来说也是可以拿到 的。比如说，如果处理方法以Map为参数，那么这个Map对于视图也是可以拿到的。<br/>
返回的视图名称会返回给DispatcherServlet，它会根据一个视图解析器将视图名称解析为一个具体的视图实现。这里说到的视图解析器是一个实现了ViewResolver借口的Bean，它的任务就是返回一个视图的具体实现(HTML、jsonp、json等等)。</p>

<h4 id="toc_5">内容协商视图解析器</h4>

<p>可以根据请求的内容，自动匹配对应的视图解析器，对视图进行解析。</p>

<h2 id="toc_6">作业实现</h2>

<p>我们按照模块图有下自上对本次作业实现进行说明。</p>

<ol>
<li><p>User模型</p>

<pre><code class="language-java">package site.zhanjingbo.course.meta;

public class User {
    private int userId;
    private String userName;

    public int getUserId() {
        return userId;
    }

    public void setUserId(int userId) {
        this.userId = userId;
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }
}
</code></pre></li>
<li><p>UserDao。User数据库访问接口</p>

<pre><code class="language-java">package site.zhanjingbo.course.dao;
import java.util.List;
import site.zhanjingbo.course.meta.User;
public interface UserDao {
    public List&lt;User&gt; getUserList();
}
</code></pre></li>
<li><p>UserDaoMapper。使用Mybatis对UserDao进行实现。</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;site.zhanjingbo.course.dao.UserDao&quot;&gt;
    &lt;resultMap type=&quot;User&quot; id=&quot;UserResult&quot;&gt;
        &lt;result property=&quot;userId&quot; column=&quot;userId&quot; /&gt;
        &lt;result property=&quot;userName&quot; column=&quot;userName&quot; /&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;getUserList&quot; resultMap=&quot;UserResult&quot;&gt;
        select * from user
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre></li>
<li><p>UserService。User的对应业务逻辑层</p>

<pre><code class="language-java">package site.zhanjingbo.course.service.impl;
import java.util.List;
import javax.annotation.Resource;
import org.springframework.stereotype.Service;
import site.zhanjingbo.course.dao.UserDao;
import site.zhanjingbo.course.meta.User;
import site.zhanjingbo.course.service.UserService;  
@Service
public class UserServiceImpl implements UserService {
    @Resource
    private UserDao userDao;
    public List&lt;User&gt; getUserList() {
        return userDao.getUserList();
    }
}
</code></pre></li>
<li><p>UserController。User的控制器层，调用业务逻辑，返回对应视图名称和数据。</p>

<pre><code class="language-java">package site.zhanjingbo.course.web.controller;

import javax.annotation.Resource;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;
import site.zhanjingbo.course.service.UserService;

@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {
    @Resource
    private UserService userService;
    @RequestMapping(&quot;/userList&quot;)
    public ModelAndView getUserList() {
        ModelAndView mav = new ModelAndView();
        mav.setViewName(&quot;userList&quot;);
        mav.addObject(&quot;userList&quot;, userService.getUserList());
        return mav;
    }
}
</code></pre></li>
<li><p>userList.ftl。使用FreeMarker渲染的视图文件</p>

<pre><code class="language-html">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;用户列表&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;table border=&quot;1px&quot;&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;td&gt;userId&lt;/td&gt;
              &lt;td&gt;userName&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;#list userList as user&gt; 
                &lt;tr&gt;
                    &lt;td&gt;${user.userId}&lt;/td&gt; 
                    &lt;td&gt;${user.userName}&lt;/td&gt;
                &lt;/tr&gt;
            &lt;/#list&gt;
          &lt;/tbody&gt;  
        &lt;/table&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre></li>
<li><p>DispatcherServlet的配置文件，主要配置对应View的渲染方案，即内容协商视图响应。</p>

<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd
http://www.springframework.org/schema/mvc
http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

&lt;context:component-scan base-package=&quot;site.zhanjingbo.course.web.controller&quot; /&gt;

&lt;bean id=&quot;contentNegotiationManager&quot;
    class=&quot;org.springframework.web.accept.ContentNegotiationManagerFactoryBean&quot;&gt;
    &lt;!-- 扩展名至mimeType的映射,即 /user.json =&gt; application/json --&gt;
    &lt;property name=&quot;favorPathExtension&quot; value=&quot;true&quot; /&gt;
    &lt;!-- 用于开启 /userinfo/123?format=json 的支持 --&gt;
    &lt;property name=&quot;favorParameter&quot; value=&quot;true&quot; /&gt;
    &lt;property name=&quot;parameterName&quot; value=&quot;format&quot; /&gt;
    &lt;!-- 是否忽略Accept Header --&gt;
    &lt;property name=&quot;ignoreAcceptHeader&quot; value=&quot;false&quot; /&gt;
    &lt;property name=&quot;mediaTypes&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;json&quot; value=&quot;application/json&quot; /&gt;
            &lt;entry key=&quot;xml&quot; value=&quot;application/xml&quot; /&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;!-- 默认的content type --&gt;
    &lt;property name=&quot;defaultContentType&quot; value=&quot;text/html&quot; /&gt;
&lt;/bean&gt;
&lt;!-- freeMarker --&gt;
&lt;bean id=&quot;freemarkerConfig&quot;
    class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;
    &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/freemarker/&quot; /&gt;
&lt;/bean&gt;
&lt;bean
    class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt;
    &lt;property name=&quot;contentNegotiationManager&quot; ref=&quot;contentNegotiationManager&quot; /&gt;
    &lt;property name=&quot;viewResolvers&quot;&gt;
        &lt;list&gt;
            &lt;bean id=&quot;viewResolver&quot;
                class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;
                &lt;property name=&quot;cache&quot; value=&quot;true&quot; /&gt;
                &lt;property name=&quot;prefix&quot; value=&quot;&quot; /&gt;
                &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot; /&gt;
                &lt;property name=&quot;contentType&quot; value=&quot;text/html; charset=utf-8&quot; /&gt;
            &lt;/bean&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;defaultViews&quot;&gt;
        &lt;list&gt;
            &lt;!-- JSON --&gt;
            &lt;bean
                class=&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot; /&gt;
            &lt;!-- XML --&gt;
            &lt;bean class=&quot;org.springframework.web.servlet.view.xml.MarshallingView&quot;&gt;
                &lt;property name=&quot;marshaller&quot;&gt;
                    &lt;bean class=&quot;org.springframework.oxm.xstream.XStreamMarshaller&quot; /&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;/beans&gt;
</code></pre></li>
</ol>

<h2 id="toc_7">结果展示</h2>

<p>为了更好的展示不同URL后缀以及不同Accept头对应的不同返回结果，我们使用curl命令对项目进行请求，观察返回结果。</p>

<ol>
<li><p>无后缀，默认URL</p>

<pre><code>curl http://localhost:8080/SpringHomework5_1/api/user/userList
</code></pre>

<p><img src="media/14773646522828/14773731907095.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>html后缀</p>

<pre><code>http://localhost:8080/SpringHomework5_1/api/user/userList.html
</code></pre>

<p><img src="media/14773646522828/14773756220422.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>JSON后缀</p>

<pre><code>http://localhost:8080/SpringHomework5_1/api/user/userList.json
</code></pre>

<p><img src="media/14773646522828/14773756553739.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>XML后缀</p>

<pre><code>curl http://localhost:8080/SpringHomework5_1/api/user/userList.xml
</code></pre>

<p><img src="media/14773646522828/14773755762050.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>JSON头</p>

<pre><code>curl -H &#39;Accept:application/json&#39; http://localhost:8080/SpringHomework5_1/api/user/userList
</code></pre>

<p><img src="media/14773646522828/14773757816596.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>XML头</p>

<pre><code>curl -H &#39;Accept:application/xml&#39; http://localhost:8080/SpringHomework5_1/api/user/userList
</code></pre>

<p><img src="media/14773646522828/14773757471295.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
</ol>

<h2 id="toc_8">总结</h2>

<p>虽然完成了目标任务，但是对于Spring整合其它框架以及SpringMVC的相关功能的具体熟悉还需要进一步学习。</p>

<h2 id="toc_9">代码</h2>

<p><a href="http://git.oschina.net/cobber/SpringHomework5_1">Demo</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/10/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Java.html'>Java</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                      
                        &nbsp;<a  class="ds-thread-count" data-thread-key="14773646522828.html" data-count-type="comments" href="14773646522828.html#ds-thread"></a>
                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14766902757975.html">
                
                  <h1>网易Java Web微专业Spring-数据访问单元作业</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>根据本单介绍的Spring JDBC，事务管理，MyBatis等内容，分别使用Spring JDBC及MyBatis提供一个转帐服务（保证事务），提供一个transferMoney接口：<br/>
transferMoney(Long srcUserId, Long targetUserId, double count)；// srcUserId及targetUserId为转帐用户标识</p>
</blockquote>

<h2 id="toc_0">相关表结构</h2>

<table>
<thead>
<tr>
<th style="text-align: center">列名</th>
<th style="text-align: center">类型</th>
<th style="text-align: center">备注</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">userId</td>
<td style="text-align: center">Long</td>
<td style="text-align: center">唯一用户标识</td>
</tr>
<tr>
<td style="text-align: center">balance</td>
<td style="text-align: center">double</td>
<td style="text-align: center">账户余额</td>
</tr>
</tbody>
</table>

<h2 id="toc_1">程序架构</h2>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-10-17-14766906872633.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h3 id="toc_2">说明</h3>

<ul>
<li>UserDao 为统一的User数据库访问接口</li>
<li>UserService 为外部服务提供直接调用的接口</li>
</ul>

<h2 id="toc_3">实现说明</h2>

<ol>
<li><p>application-config配置，相关配置均有注释说明。其中事务的处理可以采用注解或AOP的XML配置方式，下列代码均有体现。</p>

<pre><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
xmlns:mybatis=&quot;http://mybatis.org/schema/mybatis-spring&quot;
xsi:schemaLocation=&quot;
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop-2.0.xsd
http://www.springframework.org/schema/tx
http://www.springframework.org/schema/tx/spring-tx.xsd
http://mybatis.org/schema/mybatis-spring
http://mybatis.org/schema/mybatis-spring.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!-- 数据库连接配置文件导入 --&gt;
    &lt;context:property-placeholder location=&quot;db.properties&quot; /&gt;
    &lt;!-- 扫描注解 --&gt;
    &lt;context:component-scan base-package=&quot;site.zhanjingbo&quot; /&gt;
    &lt;!-- 使用注解声明事务 --&gt;
    &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; /&gt;
    &lt;!-- MyBatis的自动扫描 --&gt;
    &lt;mybatis:scan base-package=&quot;site.zhanjingbo&quot; /&gt;

    &lt;!-- 数据源配置 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;
        destroy-method=&quot;close&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driverClassName}&quot; /&gt;
        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;
        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
    &lt;/bean&gt;
    &lt;!-- 事务管理器 --&gt;
    &lt;bean id=&quot;txManager&quot;
        class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- 使用AOP-XML声明事务 --&gt;
    &lt;!-- &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt; &lt;tx:attributes&gt; 
        &lt;tx:method name=&quot;transfer*&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; 
        &lt;aop:pointcut id=&quot;daoOperation&quot; expression=&quot;execution(* site.zhanjingbo.service.*.*(..))&quot; 
        /&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;daoOperation&quot; /&gt; &lt;/aop:config&gt; --&gt;

    &lt;!-- 配置myBatis的sqlSessionFactory --&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;!-- 自动扫描mappers.xml文件 --&gt;
        &lt;property name=&quot;mapperLocations&quot;
            value=&quot;classpath:site/zhanjingbo/dao/myBatiesImpl/*.xml&quot;&gt;&lt;/property&gt;
        &lt;!-- myBatis配置文件 --&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre></li>
<li><p>UserDao的接口声明</p>

<pre><code class="language-java">public interface UserDao {
    public void reset();
    public List&lt;User&gt; getUserList();
    public void updateMoney(Long userId, double count);
}
</code></pre></li>
<li><p>UserDao的JDBC实现，其中JdbcTemplete由Spring进行装载。</p>

<pre><code class="language-java">@Component(&quot;UserJDBCDao&quot;)
public class UserDaoJDBCImpl implements UserDao {
    private JdbcTemplate jdbcTemplate;
    @Autowired
    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }
    public void reset() {
        this.jdbcTemplate.execute(&quot;update UserBalance set balance=1000&quot;);
    }
    public List&lt;User&gt; getUserList() {
        return this.jdbcTemplate.query(&quot;select * from UserBalance&quot;, new RowMapper&lt;User&gt;() {
            public User mapRow(ResultSet rs, int rowNum) throws SQLException {
                User user = new User();
                user.setUserId(rs.getLong(&quot;userId&quot;));
                user.setBalance(rs.getDouble(&quot;balance&quot;));
                return user;
            }
        });
    }
    public void updateMoney(Long userId, double count) {
        this.jdbcTemplate.update(&quot;update UserBalance set balance=balance+? where userId=?&quot;, count, userId);
    }
}
</code></pre></li>
<li><p>UserDao的MyBatis实现，采用Mapper.xml的方式进行声明实现</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;site.zhanjingbo.dao.UserDao&quot;&gt;
    &lt;resultMap type=&quot;User&quot; id=&quot;UserResult&quot;&gt;
        &lt;result property=&quot;userId&quot; column=&quot;userId&quot; /&gt;
        &lt;result property=&quot;balance&quot; column=&quot;balance&quot; /&gt;
    &lt;/resultMap&gt;
    &lt;update id=&quot;reset&quot;&gt;
        update UserBalance set balance=500
    &lt;/update&gt;

    &lt;select id=&quot;getUserList&quot; resultMap=&quot;UserResult&quot;&gt;
        select * from userBalance
    &lt;/select&gt;
    &lt;update id=&quot;updateMoney&quot;&gt;
        update UserBalance set balance=balance+#{param2} where userId=#{param1}
    &lt;/update&gt;
&lt;/mapper&gt; 
</code></pre></li>
<li><p>UserService的实现，其中主要为transferMoney方法的实现。由于该方法的业务逻辑，该方法应该确保事务性。采用注解的方式声明事务，则在该方法前添加<code>@Transactional</code>注解。采用配置文件方式对事务进行声明参考第1小节中的配置文件。</p>

<pre><code class="language-java">@Transactional(propagation = Propagation.REQUIRED)
public void transferMoney(Long srcUserId, Long targetUserId, double count) {
    userDao.updateMoney(srcUserId, 0 - count);
    userDao.updateMoney(targetUserId, count);
}
</code></pre>

<p>在UserService的实现过程中，我们需要调用UserDao的具体实例，在本次作业过程中我们采用了两种方法来实现UserDao。在测试不同的实现方式时只需要修改注入的UserDao的具体实例就可完成。为了明显区分两种实例的实现，我们在reset的方法中做了区别。其中JDBC实现方式Reset之后balance的值为1000，MyBatis实现方式reset之后的balance值为500。</p></li>
<li><p>Application调用代码</p>

<pre><code class="language-java">    public static void main(String[] args) {
        //加载Spring
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application-context.xml&quot;);
        //获取UserService实例
        UserService userService = applicationContext.getBean(UserService.class);
        userService.reset();
        try {
            userService.transferMoney(new Long(10000), new Long(10001), 100);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        List&lt;User&gt; userList = userService.getUserList();
        for (User user : userList) {
            System.out.println(user);
        }

        ((ConfigurableApplicationContext) applicationContext).close();
    }
</code></pre></li>
</ol>

<h2 id="toc_4">运行结果</h2>

<h3 id="toc_5">JDBC运行结果</h3>

<ol>
<li><p>正常执行<br/>
<img src="media/14766902757975/14766935577292.jpg" alt=""/></p></li>
<li><p>执行中异常，打印异常信息，数据回滚<br/>
<img src="media/14766902757975/14766935207561.jpg" alt=""/></p></li>
</ol>

<h3 id="toc_6">MyBatis运行结果</h3>

<ol>
<li><p>正常执行<br/>
<img src="media/14766902757975/14766936235948.jpg" alt=""/></p></li>
<li><p>执行中异常，打印异常信息，数据回滚<br/>
<img src="media/14766902757975/14766936425847.jpg" alt=""/></p></li>
</ol>

<h2 id="toc_7">程序地址</h2>

<p><a href="http://git.oschina.net/cobber/SpringHomework4_1">SpringHomework4_1</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/10/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Java.html'>Java</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                      
                        &nbsp;<a  class="ds-thread-count" data-thread-key="14766902757975.html" data-count-type="comments" href="14766902757975.html#ds-thread"></a>
                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14759932535473.html">
                
                  <h1>网易Java Web微专业Spring-AOP容器作业</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<blockquote>
<p>完成一个基本的应用，提供若干个Service（&gt;=2），每个Service提供基本的增删查改的接口（实现随意，比如输出一行信息），通过AOP保证所有所有的Service接口在正常调用返回后以及抛出异常时（Service接口模拟），打出如下信息：函数名称，函数参数，并说明发生的事件：正常返回或者抛出异常。</p>
</blockquote>

<h2 id="toc_0">AOP模式示意图</h2>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-10-09-14759941824050.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_1">作业描述</h2>

<p>本次作业我设计了两个Service，分别是UserService和ProductService，每个Service分别提供增删改查操作（Print语句代替业务逻辑）。</p>

<ol>
<li><p>配置Spring配置文件，加入AOP相关的xsd文件。并配置AOP。</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd
http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop-2.0.xsd&quot;&gt;

    &lt;!-- 引入AOP --&gt;
    &lt;aop:aspectj-autoproxy /&gt;
    &lt;!-- 自动扫描annotation配置 --&gt;
    &lt;context:component-scan base-package=&quot;site.zhanjingbo&quot; /&gt;

    &lt;!-- 自定义的日志切面声明 --&gt;
    &lt;bean id=&quot;logAspect&quot; class=&quot;site.zhanjingbo.aspect.LogAspect&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre></li>
<li><p>编写Service。以UserService为例。</p>

<pre><code class="language-java">package site.zhanjingbo.service;
import org.springframework.stereotype.Component;

@Component
public class UserService {
    public void add(String username) throws Exception {
        System.out.println(&quot;添加用户:&quot; + username);
        throw new Exception(&quot;测试&quot;);
    }
    public void edit(String username) {
        System.out.println(&quot;添加用户:&quot; + username);
    }
    public void del(String username) {
        System.out.println(&quot;删除用户:&quot; + username);
    }
    public void find(String username) {
        System.out.println(&quot;查询用户:&quot; + username);
    }
}
</code></pre></li>
<li><p>编写Aspect，完成切面方法。</p>

<pre><code class="language-java">package site.zhanjingbo.aspect;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Aspect;

@Aspect
public class LogAspect {

    /**
     * 正常返回时调用
     * @param jp调用点信息
     */
    @AfterReturning(&quot;execution(* site.zhanjingbo.service.*.*(..))&quot;)
    public void logAfterReturning(JoinPoint jp){
        String className = jp.getSignature().getDeclaringTypeName();
        String methodName = jp.getSignature().getName();
        System.out.print(&quot;正常返回Log:调用&quot;+className+&quot;的&quot;+methodName+&quot;方法,参数为：&quot;);
        for (Object obj : jp.getArgs()) {
            System.out.print(obj.toString());
        }
        System.out.println(&quot;&quot;);
    }
    /**
     * 抛出异常返回时调用
     * @param jp 调用点信息
     * @param ex 异常信息
     */
    @AfterThrowing(pointcut=&quot;execution(* site.zhanjingbo.service.*.*(..))&quot;,throwing=&quot;ex&quot;)
    public void logAfterThrowing(JoinPoint jp,Exception ex){
        String className = jp.getSignature().getDeclaringTypeName();
        String methodName = jp.getSignature().getName();
        System.out.print(&quot;异常Log:调用&quot;+className+&quot;的&quot;+methodName+&quot;方法,参数为：&quot;);
        for (Object obj : jp.getArgs()) {
            System.out.print(obj.toString());
        }
        System.out.println(&quot;。抛出异常:&quot;+ex.getMessage()+&quot;!&quot;);
    }
}
</code></pre></li>
<li><p>编写模拟调用的Application类，来模拟业务。</p>

<pre><code class="language-java">public class Application {
    public static void main(String[] args){
        //加载Spring相关配置文件
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application-context.xml&quot;);

        //获取UserService实例
        UserService userService = applicationContext.getBean(UserService.class);
        //调用方法
        try {
            userService.add(&quot;ZhangSan&quot;);
        } catch (Exception e) {

        }
        //获取ProductService实例
        ProductService productService = applicationContext.getBean(ProductService.class);
        //调用方法
        productService.del(&quot;Pen&quot;);

        ((ConfigurableApplicationContext)applicationContext).close();
    }
}
</code></pre></li>
</ol>

<h2 id="toc_2">程序运行结果</h2>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-10-09-14759958614665.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<p>Service的方法正常调用或调用异常结束后，完成对应的切面方法响应，输出对应的Log。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/10/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Java.html'>Java</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                      
                        &nbsp;<a  class="ds-thread-count" data-thread-key="14759932535473.html" data-count-type="comments" href="14759932535473.html#ds-thread"></a>
                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_2.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="asset/img/icon.jpg" /></div>
            
                <h1>Zhan's Blog</h1>
                <div class="site-des">展镜博的个人博客</div>
                <div class="social">









<a class="github" target="_blank" href="https://github.com/swuzjb" title="GitHub">GitHub</a>
<a class="email" href="mailto:412008196@qq.com" title="Email">Email</a>
  <a class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>
              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"><strong>iOS学习笔记</strong></a>
        
            <a href="Java.html"><strong>Java</strong></a>
        
            <a href="%E8%AF%BE%E7%A8%8B%E7%9B%B8%E5%85%B3.html"><strong>课程相关</strong></a>
         
        </p>


                </div>
              </div>
              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>BookList</h2>
                </div>
                <div class="side-content">

                <p class="cat-list">
                
                    <a href="bookList.html"><strong>待读书单</strong></a>
                
                </p>


                </div>
              </div>
              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="14878305448928.html">Java容器框架分析(四)——ArrayDeque源码分析</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14878187570598.html">Java容器框架分析(三)——LinkedList源码分析</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14876660718478.html">Java容器框架分析（二）——ArrayList源码解析</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14876629153312.html">Java容器框架分析（一）——相关概念综述</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14875782735365.html">Java内存管理</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
                <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>FRIEND LINKS</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
                  <li class="post">
                    <a href="https://guxinyan.github.io">顾鑫燕的博客</a>
                    
                  </li>
                  <li class="post">
                    <a href="http://ranchu.win">CD'S Blog</a>
                  </li>
                  <li class="post">
                    <a href="https://hran.me">Hran's Blog</a>
                  </li>
          </ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2016 swuzjb
  </div>
</div>

        </section>
      </div>
    </div>

  


<script type="text/javascript">
var duoshuoQuery = {short_name:'zhanjingbo'};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    <script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?0fb9ecff8c9a2c820ce81c18ff77c1e8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  </body>
</html>
