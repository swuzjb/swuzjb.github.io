<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Zhan's Blog]]></title>
  <link href="http://swuzjb.github.io/atom.xml" rel="self"/>
  <link href="http://swuzjb.github.io/"/>
  <updated>2017-03-13T16:00:40+08:00</updated>
  <id>http://swuzjb.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[设计模式-单例模式]]></title>
    <link href="http://swuzjb.github.io/14893892449120.html"/>
    <updated>2017-03-13T15:14:04+08:00</updated>
    <id>http://swuzjb.github.io/14893892449120.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</p>
</blockquote>

<p>单例模式有三个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。<br/>
单例模式是结构最简单的设计模式一，在它的核心结构中只包含一个被称为单例类的特殊类。单例模式结构如图所示：<br/>
<img src="media/14893892449120/14893894908299.gif" alt=""/></p>

<p>单例模式结构图中只包含一个单例角色：</p>

<ul>
<li>Singleton（单例）：在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。</li>
</ul>

<h2 id="toc_0">实现</h2>

<h3 id="toc_1">饿汉单例类</h3>

<p>饿汉式单例类是实现起来最简单的单例类，饿汉式单例类结构图如图所示：<br/>
<img src="media/14893892449120/14893897883680.gif" alt=""/><br/>
从图中可以看出，由于在定义静态变量的时候实例化单例类，因此在类加载的时候就已经创建了单例对象，代码如下所示：</p>

<pre><code class="language-java">public class EagerSingleton {
    private static final EagerSingleton EAGER_SINGLETON = new EagerSingleton();

    private EagerSingleton() {

    }

    public static EagerSingleton getInstance() {
        return EAGER_SINGLETON;
    }
}
</code></pre>

<h3 id="toc_2">懒汉单例模式</h3>

<p>除了饿汉式单例，还有一种经典的懒汉式单例。懒汉式单例类结构图如图所示：<br/>
<img src="media/14893892449120/14893900184282.gif" alt=""/><br/>
从图中可以看出，懒汉式单例在第一次调用getInstance()方法时实例化，在类加载时并不自行实例化，这种技术又称为延迟加载(Lazy Load)技术，即需要的时候再加载实例，为了避免多个线程同时调用getInstance()方法，我们可以使用关键字synchronized，代码如下所示：</p>

<pre><code class="language-java">public class LazySingleton1 {
    private static LazySingleton1 instance = null;

    private LazySingleton1() {
    }

    synchronized public static LazySingleton1 getInstance() {
        if (instance == null) {
            instance = new LazySingleton1();
        }
        return instance;
    }
}
</code></pre>

<p>该懒汉式单例类在<code>getInstance()</code>方法前面增加了关键字<em>synchronized</em>进行线程锁，以处理多个线程同时访问的问题。但是，上述代码虽然解决了线程安全问题，但是每次调用<code>getInstance()</code>时都需要进行线程锁定判断，在多线程高并发访问环境中，将会导致系统性能大大降低。如何既解决线程安全问题又不影响系统性能呢？我们继续对懒汉式单例进行改进。事实上，我们无须对整个<code>getInstance()</code>方法进行锁定，只需对其中的代码<code>instance = new LazySingleton();</code>进行锁定即可。因此<code>getInstance()</code>方法可以进行如下改进：</p>

<pre><code class="language-java">public static LazySingleton getInstance() {   
    if (instance == null) {  
        synchronized (LazySingleton.class) {  
            instance = new LazySingleton();   
        }  
    }  
    return instance;   
} 
</code></pre>

<p>问题貌似得以解决，事实并非如此。如果使用以上代码来实现单例，还是会存在单例对象不唯一。原因如下：假如在某一瞬间线程A和线程B都在调用<code>getInstance()</code>方法，此时instance对象为null值，均能通过<code>instance == null</code>的判断。由于实现了<em>synchronized</em>加锁机制，线程A进入synchronized锁定的代码中执行实例创建代码，线程B处于排队等待状态，必须等待线程A执行完毕后才可以进入synchronized锁定代码。但当A执行完毕时，线程B并不知道实例已经创建，将继续创建新的实例，导致产生多个单例对象，违背单例模式的设计思想，因此需要进行进一步改进，在synchronized中再进行一次(instance == null)判断，这种方式称为<strong>双重检查锁定(Double-Check Locking)</strong>。使用双重检查锁定实现的懒汉式单例类完整代码如下所示：</p>

<pre><code class="language-java">class LazySingleton {   
    private volatile static LazySingleton instance = null;   
  
    private LazySingleton() { }   
  
    public static LazySingleton getInstance() {   
        //第一重判断  
        if (instance == null) {  
            //锁定代码块  
            synchronized (LazySingleton.class) {  
                //第二重判断  
                if (instance == null) {  
                    instance = new LazySingleton(); //创建单例实例  
                }  
            }  
        }  
        return instance;   
    }  
}  
</code></pre>

<p>需要注意的是，如果使用双重检查锁定来实现懒汉式单例类，需要在静态成员变量instance之前增加修饰符volatile，被volatile修饰的成员变量可以确保多个线程都能够正确处理，且该代码只能在JDK 1.5及以上版本中才能正确执行。由于volatile关键字会屏蔽Java虚拟机所做的一些代码优化，可能会导致系统运行效率降低，因此即使使用双重检查锁定来实现单例模式也不是一种完美的实现方式。 </p>

<h3 id="toc_3">懒汉和饿汉的比较</h3>

<p>饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多线程访问问题，可以确保实例的唯一性；从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。<br/>
懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须处理好多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响。</p>

<h3 id="toc_4">静态内部类实现法</h3>

<p>饿汉式单例类不能实现延迟加载，不管将来用不用始终占据内存；懒汉式单例类线程安全控制烦琐，而且性能受影响。可见，无论是饿汉式单例还是懒汉式单例都存在这样那样的问题，有没有一种方法，能够将两种单例的缺点都克服，而将两者的优点合二为一呢？答案是：Yes！下面我们来学习这种更好的被称之为Initialization Demand Holder (IoDH)的技术。<br/>
在IoDH中，我们在单例类中增加一个静态(static)内部类，在该内部类中创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用，实现代码如下所示：</p>

<pre><code class="language-java">class Singleton {  
    private Singleton() {  
    }  
      
    private static class HolderClass {  
            private final static Singleton instance = new Singleton();  
    }  
      
    public static Singleton getInstance() {  
        return HolderClass.instance;  
    }  
      
    public static void main(String args[]) {  
        Singleton s1, s2;   
            s1 = Singleton.getInstance();  
        s2 = Singleton.getInstance();  
        System.out.println(s1==s2);  
    }  
}  
</code></pre>

<p>编译并运行上述代码，运行结果为：true，即创建的单例对象s1和s2为同一对象。由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类HolderClass，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。</p>

<p>通过使用IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的Java语言单例模式实现方式（其缺点是与编程语言本身的特性相关，很多面向对象语言不支持IoDH）。</p>

<h2 id="toc_5">总结</h2>

<p>单例模式作为一种目标明确、结构简单、理解容易的设计模式，在软件开发中使用频率相当高，在很多应用软件和框架中都得以广泛应用。</p>

<h3 id="toc_6">主要优点</h3>

<p>单例模式的主要优点如下：</p>

<ol>
<li>单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。</li>
<li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。</li>
<li>允许可变数目的实例。基于单例模式我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例单例对象共享过多有损性能的问题。</li>
</ol>

<h3 id="toc_7">主要缺点</h3>

<p>单例模式的主要缺点如下：</p>

<ol>
<li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li>
<li>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li>
</ol>

<h3 id="toc_8">适用场景</h3>

<p>在以下情况下可以考虑使用单例模式：</p>

<ol>
<li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。</li>
<li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</li>
</ol>

<h2 id="toc_9">实现</h2>

<p><a href="https://github.com/swuzjb/DesignPatterns">相关代码Github地址</a><br/>
<a href="http://blog.csdn.net/lovelion">文章参考-刘伟</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[剑指Offer-合并两个排序的链表]]></title>
    <link href="http://swuzjb.github.io/14893744942754.html"/>
    <updated>2017-03-13T11:08:14+08:00</updated>
    <id>http://swuzjb.github.io/14893744942754.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
</blockquote>

<h2 id="toc_0">非递归实现</h2>

<pre><code class="language-java">public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        ListNode head = new ListNode(0);
        ListNode p = head;
        boolean isFirst = true;
        while(list1 != null &amp;&amp; list2 != null){
            if(list1.val &lt; list2.val){
                p.next = list1;
                list1 = list1.next;
            }else{
                p.next = list2;
                list2 = list2.next;
            }
            p = p.next;
        }
        if(list1 != null){
            p.next = list1;
        }
        if(list2 != null){
            p.next = list2;
        }
        return head.next;
    }
    
}
</code></pre>

<h2 id="toc_1">递归实现</h2>

<pre><code class="language-java">public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        if(list1 == null){
            return list2;
        }
        if(list2 == null){
            return list1;
        }
        
        ListNode head = null;
        
        if(list1.val &lt; list2.val){
            head = list1;
            head.next = Merge(list1.next, list2);
        }else{
            head = list2;
            head.next = Merge(list1, list2.next);
        }
        return head;
    }
    
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式-抽象工厂模式]]></title>
    <link href="http://swuzjb.github.io/14893043668918.html"/>
    <updated>2017-03-12T15:39:26+08:00</updated>
    <id>http://swuzjb.github.io/14893043668918.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。</p>
</blockquote>

<p>抽象工厂模式为创建一组对象提供了一种解决方案。与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品。<br/>
在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，这些产品构成了一个产品族。</p>

<h2 id="toc_0">角色</h2>

<p>在抽象工厂模式结构图中包含如下几个角色：</p>

<ol>
<li>AbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。</li>
<li>ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。</li>
<li>AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。</li>
<li>ConcreteProduct（具体产品）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。</li>
</ol>

<p>抽象工厂模式结构如图所示：<br/>
<img src="media/14893043668918/14893046728402.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_1">实现</h2>

<p>在抽象工厂中声明了多个工厂方法，用于创建不同类型的产品，抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下所示：</p>

<pre><code class="language-java">public abstract class AbstractFactory {
    /**
     * 生产A产品的具体实例
     * 
     * @return
     */
    public abstract ProductA createProductA();

    /**
     * 生产B产品的具体实例
     * 
     * @return
     */
    public abstract ProductB createProductB();
}
</code></pre>

<p>具体工厂实现了抽象工厂，每一个具体的工厂方法可以返回一个特定的产品对象，而同一个具体工厂所创建的产品对象构成了一个产品族。对于每一个具体工厂类，其典型代码如下所示：</p>

<pre><code class="language-java">public class ConcreteFactoryOne extends AbstractFactory {
    @Override
    public ProductA createProductA() {
        return new ConcreteProductA();
    }

    @Override
    public ProductB createProductB() {
        return new ConcreteProductB();
    }
}

public class ConcreteFactoryTwo extends AbstractFactory {
    @Override
    public ProductA createProductA() {
        return new ConcreteProductA2();
    }

    @Override
    public ProductB createProductB() {
        return new ConcreteProductB2();
    }
}
</code></pre>

<h2 id="toc_2">总结</h2>

<p>抽象工厂模式是工厂方法模式的进一步延伸，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和API类库的设计中，例如在Java语言的AWT（抽象窗口工具包）中就使用了抽象工厂模式，它使用抽象工厂模式来实现在不同的操作系统中应用程序呈现与所在操作系统一致的外观界面。抽象工厂模式也是在软件开发中最常用的设计模式之一。</p>

<h3 id="toc_3">主要优点</h3>

<p>抽象工厂模式的主要优点如下：</p>

<ol>
<li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。</li>
<li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</li>
<li>增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。</li>
</ol>

<h3 id="toc_4">主要缺点</h3>

<p>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。</p>

<h3 id="toc_5">适用场景</h3>

<p>在以下情况下可以考虑使用抽象工厂模式：</p>

<ol>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。</li>
<li>产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</li>
</ol>

<h2 id="toc_6">实现</h2>

<p><a href="https://github.com/swuzjb/DesignPatterns">相关代码Github地址</a><br/>
<a href="http://blog.csdn.net/lovelion">文章参考-刘伟</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式-工厂方法模式]]></title>
    <link href="http://swuzjb.github.io/14893023180281.html"/>
    <updated>2017-03-12T15:05:18+08:00</updated>
    <id>http://swuzjb.github.io/14893023180281.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。</p>
</blockquote>

<p>在简单工厂模式中只提供一个工厂类，该工厂类处于对产品类进行实例化的中心位置，它需要知道每一个产品对象的创建细节，并决定何时实例化哪一个产品类。简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，需要在其中加入必要的业务逻辑，这违背了“开闭原则”。此外，在简单工厂模式中，所有的产品都由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性，而工厂方法模式则可以很好地解决这一问题。<br/>
在工厂方法模式中，<strong>我们不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构</strong>。</p>

<h2 id="toc_0">工厂方法模式中的角色</h2>

<p>工厂方法模式提供一个抽象工厂接口来声明抽象工厂方法，而由其子类来具体实现工厂方法，创建具体的产品对象。<br/>
在工厂方法模式结构图中包含如下几个角色：</p>

<ol>
<li>Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。</li>
<li>ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。</li>
<li>Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。</li>
<li>ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。</li>
</ol>

<p>工厂方法模式结构如图2所示：<br/>
<img src="media/14893023180281/14893025237716.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_1">实现</h2>

<p>与简单工厂模式相比，工厂方法模式最重要的区别是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下所示：</p>

<pre><code class="language-java">public interface AbstarctFactory {
    public Product createProduct();
}
</code></pre>

<p>在抽象工厂中声明了工厂方法但并未实现工厂方法，具体产品对象的创建由其子类负责，客户端针对抽象工厂编程，可在运行时再指定具体工厂类，具体工厂类实现了工厂方法，不同的具体工厂可以创建不同的具体产品，其典型代码如下所示：</p>

<pre><code class="language-java">public class ConcreteFactoryA implements AbstarctFactory {
    @Override
    public Product createProduct() {
        return new ConcreteProductA();
    }
}
</code></pre>

<p>在实际使用时，具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。<br/>
在客户端代码中，只需关心工厂类即可，不同的具体工厂可以创建不同的产品，典型的客户端类代码片段如下所示：</p>

<pre><code class="language-java">AbstractFactory factory;  
factory = new ConcreteFactoryA(); //可通过配置文件实现  
Product product;  
product = factory.createProduct();  
</code></pre>

<p>可以通过配置文件来存储具体工厂类ConcreteFactory的类名，更换新的具体工厂时无须修改源代码，系统扩展更为方便。</p>

<h2 id="toc_2">总结</h2>

<p>工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。工厂方法模式是使用频率最高的设计模式之一，是很多开源框架和API类库的核心模式。</p>

<h3 id="toc_3">主要优点</h3>

<p>工厂方法模式的主要优点如下：</p>

<ol>
<li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li>
<li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。</li>
<li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li>
</ol>

<h3 id="toc_4">主要缺点</h3>

<p>工厂方法模式的主要缺点如下：</p>

<ol>
<li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li>
<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li>
</ol>

<h3 id="toc_5">适用场景</h3>

<p>在以下情况下可以考虑使用工厂方法模式：</p>

<ol>
<li>客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。</li>
<li>抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li>
</ol>

<h2 id="toc_6">实现</h2>

<p><a href="https://github.com/swuzjb/DesignPatterns">相关代码Github地址</a><br/>
<a href="http://blog.csdn.net/lovelion">文章参考-刘伟</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[剑指Offer-二进制中1的个数]]></title>
    <link href="http://swuzjb.github.io/14892880856219.html"/>
    <updated>2017-03-12T11:08:05+08:00</updated>
    <id>http://swuzjb.github.io/14892880856219.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>输入一个整数n，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
</blockquote>

<h2 id="toc_0">思路</h2>

<ul>
<li><p>方案一：</p>

<p>将(n&amp;1)可以知道n的最后一位是不是1，然后依次将n不断向右移1位，直到n为0。</p></li>
</ul>

<pre><code class="language-java">public class Solution {
    public int NumberOf1(int n) {
        int count = 0;
        while(n != 0){
            if( (n &amp; 1) == 1){
                count++;
            }
            /*
            *注意，这里是&gt;&gt;&gt;
            *&gt;&gt;为最高位填补符号位，负数会发生错误
            *&gt;&gt;&gt;为最高位填写0
            */
            n = n &gt;&gt;&gt; 1;
        }
        return count;
    }
}
</code></pre>

<ul>
<li><p>方案二：</p>

<p>将一个整数减一，都是把最右边的1变成0，如果它的右边还有0的话，所有的0都变成1，而它的左边的所有位都保持不变。若我们将n和n-1做与运算，相当于把它最右边的1变成0。那么，一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。</p></li>
</ul>

<pre><code class="language-java">public class Solution {
    public int NumberOf1(int n) {
        int count = 0;
        while(n != 0){
            count++;
            n = n &amp; (n-1);
        }
        return count;
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式-简单工厂模式]]></title>
    <link href="http://swuzjb.github.io/14892373699810.html"/>
    <updated>2017-03-11T21:02:49+08:00</updated>
    <id>http://swuzjb.github.io/14892373699810.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p>
</blockquote>

<p>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。简单工厂模式结构比较简单，其核心是工厂类的设计，其结构如图所示：<br/>
<img src="media/14892373699810/14892374346473.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_0">简单工厂模式中的角色</h2>

<p>在简单工厂模式结构图中包含如下几个角色：</p>

<ol>
<li>Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。</li>
<li>Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</li>
<li>ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法</li>
</ol>

<h2 id="toc_1">实现</h2>

<p>在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象，它是工厂模式家族中最简单的一员。<br/>
在使用简单工厂模式时，首先需要对产品类进行重构，不能设计一个包罗万象的产品类，而需根据实际情况设计一个产品层次结构，将所有产品类公共的代码移至抽象产品类，并在抽象产品类中声明一些抽象方法，以供不同的具体产品类来实现，典型的抽象产品类代码如下所示：</p>

<pre><code class="language-java">public abstract class Product {
    //公共方法的实现
    public void methodSame() {
    }

    // 声明抽象业务方法
    public abstract void methodDiff();
}
</code></pre>

<p>在具体产品类中实现了抽象产品类中声明的抽象业务方法，不同的具体产品类可以提供不同的实现，典型的具体产品类代码如下所示：</p>

<pre><code class="language-java">public class ConcreteProductA extends Product {
    @Override
    public void methodDiff() {
        System.out.println(&quot;具体产品A的特性实现&quot;);
    }
}
</code></pre>

<p>简单工厂模式的核心是工厂类，在没有工厂类之前，客户端一般会使用new关键字来直接创建产品对象，而在引入工厂类之后，客户端可以通过工厂类来创建产品，在简单工厂模式中，工厂类提供了一个静态工厂方法供客户端使用，根据所传入的参数不同可以创建不同的产品对象，典型的工厂类代码如下所示：</p>

<pre><code class="language-java">public class SimpleFactory {
    public static Product getProduct(String arg) {
        Product product = null;
        if (arg.equalsIgnoreCase(&quot;A&quot;)) {
            product = new ConcreteProductA();
            // 初始化设置product
        } else if (arg.equalsIgnoreCase(&quot;B&quot;)) {
            product = new ConcreteProductB();
            // 初始化设置product
        }
        return product;
    }
}
</code></pre>

<p>客户端调用，如果追求进一步解耦，可以引入配置文件，每次根据配置文件的值，对产品进行实例化：</p>

<pre><code class="language-java">    public static void main(String[] args) {
        Product product;
        product = SimpleFactory.getProduct(&quot;A&quot;); // 通过工厂类创建产品对象
        product.methodSame();
        product.methodDiff();
    }
</code></pre>

<h2 id="toc_2">总结</h2>

<p>简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开，它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用。</p>

<h3 id="toc_3">主要优点</h3>

<p>简单工厂模式的主要优点如下：</p>

<ol>
<li>工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。</li>
<li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。</li>
<li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li>
</ol>

<h3 id="toc_4">主要缺点</h3>

<p>简单工厂模式的主要缺点如下：</p>

<ol>
<li>由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。</li>
<li>使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。</li>
<li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li>
<li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li>
</ol>

<h3 id="toc_5">适用场景</h3>

<p>在以下情况下可以考虑使用简单工厂模式：</p>

<ol>
<li>工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</li>
</ol>

<h2 id="toc_6">练习</h2>

<p>使用简单工厂模式设计一个可以创建不同几何形状（如圆形、方形和三角形等）的绘图工具，每个几何图形都具有绘制draw()和擦除erase()两个方法，要求在绘制不支持的几何图形时，提示一个UnSupportedShapeException。</p>

<h2 id="toc_7">实现</h2>

<p><a href="https://github.com/swuzjb/DesignPatterns">相关代码Github地址</a><br/>
<a href="http://blog.csdn.net/lovelion">文章参考-刘伟</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式-装饰模式]]></title>
    <link href="http://swuzjb.github.io/14892189846734.html"/>
    <updated>2017-03-11T15:56:24+08:00</updated>
    <id>http://swuzjb.github.io/14892189846734.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。</p>
</blockquote>

<p>装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为，在现实生活中，这种情况也到处存在，例如一张照片，我们可以不改变照片本身，给它增加一个相框，使得它具有防潮的功能，而且用户可以根据需要给它增加不同类型的相框，甚至可以在一个小相框的外面再套一个大相框。<br/>
装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。</p>

<h2 id="toc_0">装饰模式中的角色</h2>

<p>在装饰模式结构图中包含如下几个角色：</p>

<ol>
<li>Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。</li>
<li>ConcreteComponent（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。</li>
<li>Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。</li>
<li>ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。</li>
</ol>

<p><img src="media/14892189846734/14892191328338.gif" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/><br/>
由于具体构件类和装饰类都实现了相同的抽象构件接口，因此装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</p>

<h2 id="toc_1">总结</h2>

<p>装饰模式降低了系统的耦合度，可以动态增加或删除对象的职责，并使得需要装饰的具体构件类和具体装饰类可以独立变化，以便增加新的具体构件类和具体装饰类。在软件开发中，装饰模式应用较为广泛，例如在Java I/O中的输入流和输出流的设计、javax.swing包中一些图形界面构件功能的增强等地方都运用了装饰模式。</p>

<h3 id="toc_2">主要优点</h3>

<p>装饰模式的主要优点如下：</p>

<ol>
<li>对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。</li>
<li>可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为。</li>
<li>可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。</li>
<li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。</li>
</ol>

<h3 id="toc_3">主要缺点</h3>

<p>装饰模式的主要缺点如下：</p>

<ol>
<li>使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能。</li>
<li> 装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。</li>
</ol>

<h3 id="toc_4">适用场景</h3>

<p>在以下情况下可以考虑使用装饰模式：</p>

<ol>
<li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li>
<li>当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类已定义为不能被继承（如Java语言中的final类）。</li>
</ol>

<h2 id="toc_5">Demo</h2>

<p>某软件公司欲开发了一个数据加密模块，可以对字符串进行加密。最简单的加密算法通过对字母进行移位来实现，同时还提供了稍复杂的逆向输出加密，还提供了更为高级的求模加密。用户先使用最简单的加密算法对字符串进行加密，如果觉得还不够可以对加密之后的结果使用其他加密算法进行二次加密，当然也可以进行第三次加密。试使用装饰模式设计该多重加密系统。</p>

<h2 id="toc_6">实现</h2>

<p><a href="https://github.com/swuzjb/DesignPatterns">相关代码Github地址</a><br/>
<a href="http://blog.csdn.net/lovelion">文章参考-刘伟</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式-观察者模式]]></title>
    <link href="http://swuzjb.github.io/14892030475974.html"/>
    <updated>2017-03-11T11:30:47+08:00</updated>
    <id>http://swuzjb.github.io/14892030475974.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。</p>
</blockquote>

<p>观察者模式是使用频率最高的设计模式之一，它用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。</p>

<h2 id="toc_0">观察者模式中的角色</h2>

<p>在观察者模式中包含如下几个角色：</p>

<ol>
<li>Subject（目标）：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类。</li>
<li>ConcreteSubject（具体目标）：具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。</li>
<li>Observer（观察者）：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者。</li>
<li>ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的update()方法。通常在实现时，可以调用具体目标类的attach()方法将自己添加到目标类的集合中或通过detach()方法将自己从目标类的集合中删除。</li>
</ol>

<p><img src="media/14892030475974/14892033599821.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/><br/>
观察者模式描述了如何建立对象与对象之间的依赖关系，以及如何构造满足这种需求的系统。观察者模式包含观察目标和观察者两类对象，一个目标可以有任意数目的与之相依赖的观察者，一旦观察目标的状态发生改变，所有的观察者都将得到通知。作为对这个通知的响应，每个观察者都将监视观察目标的状态以使其状态与目标状态同步，这种交互也称为发布-订阅(Publish-Subscribe)。观察目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。</p>

<h2 id="toc_1">通用代码实现</h2>

<p>目标类的实现：</p>

<pre><code class="language-java">package com.swu.ObserverPattern;

import java.util.ArrayList;
import java.util.List;

/**
 * 主题的实现类，如有需要可以进一步将此类抽象
 * 
 * @author zhanjingbo
 *
 */
public class Subject {
    /**
     * 维护所有观察者的队列
     */
    private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;();

    /**
     * 将观察者添加入通知队列
     * 
     * @param obs
     */
    public void attach(Observer obs) {
        this.observers.add(obs);
    }

    /**
     * 将观察者移除出通知队列
     * 
     * @param obs
     */
    public void detach(Observer obs) {
        this.observers.remove(obs);
    }

    /**
     * 通知所有观察者
     */
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update();
        }
    }

}
</code></pre>

<p>观察者抽象的接口：</p>

<pre><code class="language-java">public interface Observer {
    void update();
}
</code></pre>

<p>观察者的具体实现：</p>

<pre><code class="language-java">public class ConcerteObserversA implements Observer {
    public void update() {
        System.out.println(&quot;A类观察者收到消息&quot;);
    }
}
</code></pre>

<h2 id="toc_2">JDK对观察者模式的支持</h2>

<p>观察者模式在Java语言中的地位非常重要。在JDK的java.util包中，提供了Observable类以及Observer接口，它们构成了JDK对观察者模式的支持。如图所示：<br/>
<img src="media/14892030475974/14892071855093.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h3 id="toc_3">Observer接口</h3>

<p>在java.util.Observer接口中只声明一个方法，它充当抽象观察者，其方法声明代码如下所示：<code>void  update(Observable o, Object arg);</code>当观察目标的状态发生变化时，该方法将会被调用，在Observer的子类中将实现update()方法，即具体观察者可以根据需要具有不同的更新行为。当调用观察目标类Observable的notifyObservers()方法时，将执行观察者类中的update()方法。</p>

<h3 id="toc_4">Observable类</h3>

<p>java.util.Observable类充当观察目标类，在Observable中定义了一个向量Vector来存储观察者对象，它所包含的方法及说明见表：<br/>
<img src="media/14892030475974/14892075822399.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/><br/>
我们可以直接使用Observer接口和Observable类来作为观察者模式的抽象层，再自定义具体观察者类和具体观察目标类，通过使用JDK中的Observer接口和Observable类，可以更加方便地在Java语言中应用观察者模式。</p>

<h2 id="toc_5">实现</h2>

<p><a href="https://github.com/swuzjb/DesignPatterns">相关代码Github地址</a><br/>
<a href="http://blog.csdn.net/lovelion">文章参考-刘伟</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[剑指Offer-递归和循环]]></title>
    <link href="http://swuzjb.github.io/14891973906960.html"/>
    <updated>2017-03-11T09:56:30+08:00</updated>
    <id>http://swuzjb.github.io/14891973906960.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">求斐波那契额</h2>

<p>这个题目非常简单，2分钟就可以解决。直接上代码！</p>

<pre><code class="language-java">public class Solution {
    public int Fibonacci(int n) {
        if(n &lt;= 0){
            return 0;
        }
        if(n == 1){
            return 1;
        }
        return Fibonacci(n-1)+Fibonacci(n-2);
    }
}
</code></pre>

<p>但是，这个解法有很多的问题。当n的值比较大的时候，就会出现栈调用溢出。所以，我们一般在条件允许的情况下，使用循环来替代递归的实现。</p>

<pre><code class="language-java">public class Solution {
    public int Fibonacci(int n) {
        if(n &lt;= 1){
            return n;
        }
        int number1 = 0;
        int number2 = 1;
        int ans = 0;
        for(int i = 2;i&lt;=n;i++){
            ans = number1 + number2;
            number1 = number2;
            number2 = ans;
        } 
        return ans;
    }
}
</code></pre>

<h2 id="toc_1">跳台阶</h2>

<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>

<h3 id="toc_2">思路</h3>

<p>首先我们考虑最简单的情况。如果只有1级台阶，那显然只有一种跳法。如果有2级台阶，那就有两种跳的方法了：一种是分2次跳，每次跳1级；另外一种就是一次跳2级。<br/>
接着我们再来讨论一般情况，我们把n级台阶时的跳法看成是n的函数，记为f(n)。当n&gt;2时，第一次跳的时候就有两种不同的选择：一是一次跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；另一种跳法是一次跳2级，这是跳法数目就是后面剩下n-2级台阶的跳法数目，即f(n-2)。因此n级台阶的跳法数目f(n) = f(n-1) + f(n - 2);</p>

<h3 id="toc_3">代码</h3>

<pre><code class="language-java">public class Solution {
    public int JumpFloor(int target) {
        if(target &lt;= 2){
            return target;
        }
        int number1 = 1;
        int number2 = 2;
        int ans = 0;
        for(int i = 3;i&lt;=target;i++){
            ans = number1 + number2;
            number1 = number2;
            number2 = ans;
        }
        return ans;
    }
}
</code></pre>

<h2 id="toc_4">变态跳台阶</h2>

<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>

<h3 id="toc_5">思路</h3>

<p>借鉴上面的思路，我们把n级台阶时的跳法看成是n的函数，记为f(n)。此时<code>f(n) = f(n-1) + f(n-2) + ...+ f(1) + 1</code>;经过数学推导可得：f(n) = 2<sup>n-1</sup>;</p>

<h3 id="toc_6">代码</h3>

<pre><code class="language-java">public class Solution {
    public int JumpFloorII(int target) {
        return 1 &lt;&lt; target-1;
    }
}
</code></pre>

<h2 id="toc_7">矩形覆盖</h2>

<p>我们可以用<code>2*1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个<code>2*n</code>的大矩形，总共有多少种方法？</p>

<h3 id="toc_8">思路</h3>

<p>既然放在这个章节，自然是递推解决。当我们使用一个<code>1*2</code>的矩形去覆盖大矩形（<code>2*n</code>）的左侧时，我们有两个选择，横着放或者竖着放。当竖着放时，右边剩下的区域长度就为<code>n-1</code>；当横着放时，左边剩下的区域长度就为<code>n-2</code>。所以可以发现<code>f(n) = f(n-1) + f(n-2)</code>。</p>

<h3 id="toc_9">代码</h3>

<pre><code class="language-java">public class Solution {
    public int RectCover(int target) {
        if(target &lt;=2){
            return target;
        }
        int number1 = 1;
        int number2 = 2;
        int ans = 0;
        for(int i = 3;i &lt;= target;i++){
            ans = number1 + number2;
            number1 = number2;
            number2 = ans;
        }
        return ans;
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式-策略模式]]></title>
    <link href="http://swuzjb.github.io/14891427018088.html"/>
    <updated>2017-03-10T18:45:01+08:00</updated>
    <id>http://swuzjb.github.io/14891427018088.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>策略模式是指：定义一系列算法类，将每一个算法封装起来，并让他们可以互相替换，策略模式让算法独立于使用它的客户而变化，也被称之为政策模式(Policy)。是一种对象行为型模式。</p>
</blockquote>

<h2 id="toc_0">详细说明</h2>

<p>在策略模式中，我们可以定义一些独立的类来封装不同的算法，每一个类封装一种具体的算法，在这里，每一个封装算法的类我们都可以称之为一种策略(Strategy)，为了保证这些策略在使用时具有一致性，一般会提供一个抽象的策略类来做规则的定义，而每种算法则对应于一个具体策略类。<br/>
策略模式的主要目的是将算法的定义与使用分开，也就是将算法的行为和环境分开，将算法的定义放在专门的策略类中，每一个策略类封装了一种实现算法，使用算法的环境类针对抽象策略类进行编程，符合“依赖倒转原则”。在出现新的算法时，只需要增加一个新的实现了抽象策略类的具体策略类即可。</p>

<h3 id="toc_1">策略模式中的角色</h3>

<p>在策略模式结构图中包含如下几个角色：</p>

<ul>
<li>Context（环境类）：环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。</li>
<li>Strategy（抽象策略类）：它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。</li>
<li><p>ConcreteStrategy（具体策略类）：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。</p>

<p>策略模式结构图如下：<br/>
<img src="media/14891427018088/14891431124940.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
</ul>

<h3 id="toc_2">通用实现</h3>

<p>在使用策略模式时，我们需要将算法从Context类中提取出来，首先应该创建一个策略接口，其典型代码如下所示：</p>

<pre><code class="language-java">public interface Strategy {
    void algorithm();
}
</code></pre>

<p>然后再将封装每一种具体算法的类作为该策略类的实现类，如下代码所示：</p>

<pre><code class="language-java">public class ConcreteStrategyA implements Strategy {
    public void algorithm() {
        System.out.println(&quot;这是策略A&quot;);
    }
}
public class ConcreteStrategyB implements Strategy {
    public void algorithm() {
        System.out.println(&quot;这是策略B&quot;);
    }
}
</code></pre>

<p>于Context类而言，在它与抽象策略类之间建立一个关联关系，其典型代码如下所示：</p>

<pre><code class="language-java">/**
 * 环境类，调用策略的实例
 * 
 * @author zhanjingbo
 *
 */
public class Context {
    private Strategy strategy;
    public Context(Strategy strategy) {
        this.strategy = strategy;
    }
    /**
     * 策略调用
     */
    public void algorihm() {
        this.strategy.algorithm();
    }
    /**
     * 动态设置策略
     * 
     * @param strategy
     */
    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }
}
</code></pre>

<p>在客户端代码中只需注入一个具体策略对象，可以将具体策略类类名存储在配置文件中，通过反射来动态创建具体策略对象，从而使得用户可以灵活地更换具体策略类，增加新的具体策略类也很方便。策略模式提供了一种可插入式(Pluggable)算法的实现方案。</p>

<h3 id="toc_3">总结</h3>

<p>策略模式用于算法的自由切换和扩展，它是应用较为广泛的设计模式之一。策略模式对应于解决某一问题的一个算法族，允许用户从该算法族中任选一个算法来解决某一问题，同时可以方便地更换算法或者增加新的算法。只要涉及到算法的封装、复用和切换都可以考虑使用策略模式。</p>

<h4 id="toc_4">主要优点</h4>

<p>策略模式的主要优点如下：</p>

<ol>
<li>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</li>
<li>策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族，恰当使用继承可以把公共的代码移到抽象策略类中，从而避免重复的代码。</li>
<li>策略模式提供了一种可以替换继承关系的办法。如果不使用策略模式，那么使用算法的环境类就可能会有一些子类，每一个子类提供一种不同的算法。但是，这样一来算法的使用就和算法本身混在一起，不符合“单一职责原则”，决定使用哪一种算法的逻辑和该算法本身混合在一起，从而不可能再独立演化；而且使用继承无法实现算法或行为在程序运行时的动态切换。</li>
<li>使用策略模式可以避免多重条件选择语句。多重条件选择语句不易维护，它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起，将它们全部硬编码(Hard Coding)在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后。</li>
<li>策略模式提供了一种算法的复用机制，由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类。</li>
</ol>

<h4 id="toc_5">主要缺点</h4>

<p>策略模式的主要缺点如下：</p>

<ol>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。</li>
<li>策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类。</li>
<li>无法同时在客户端使用多个策略类，也就是说，在使用策略模式时，客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的情况。</li>
</ol>

<h4 id="toc_6">适用场景</h4>

<p>在以下情况下可以考虑使用策略模式：</p>

<ol>
<li>一个系统需要动态地在几种算法中选择一种，那么可以将这些算法封装到一个个的具体算法类中，而这些具体算法类都是一个抽象算法类的子类。换言之，这些具体算法类均有统一的接口，根据“里氏代换原则”和面向对象的多态性，客户端可以选择使用任何一个具体算法类，并只需要维持一个数据类型是抽象算法类的对象。</li>
<li>一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重条件选择语句来实现。此时，使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难以维护的多重条件选择语句。</li>
<li> 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法与相关的数据结构，可以提高算法的保密性与安全性。</li>
</ol>

<h2 id="toc_7">练习</h2>

<p>某软件公司欲开发一款飞机模拟系统，该系统主要模拟不同种类飞机的飞行特征与起飞特征，需要模拟的飞机种类及其特征如下表所示：</p>

<table>
<thead>
<tr>
<th style="text-align: center">飞机种类</th>
<th style="text-align: center">起飞特征</th>
<th style="text-align: center">飞行特征</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">直升机(Helicopter)</td>
<td style="text-align: center">垂直起飞(VerticalTakeOff)</td>
<td style="text-align: center">亚音速飞行(SubSonicFly)</td>
</tr>
<tr>
<td style="text-align: center">客机(AirPlane)</td>
<td style="text-align: center">长距离起飞(LongDistanceTakeOff)</td>
<td style="text-align: center">亚音速飞行(SubSonicFly)</td>
</tr>
<tr>
<td style="text-align: center">歼击机(Fighter)</td>
<td style="text-align: center">长距离起飞(LongDistanceTakeOff)</td>
<td style="text-align: center">超音速飞行(SuperSonicFly)</td>
</tr>
<tr>
<td style="text-align: center">鹞式战斗机(Harrier)</td>
<td style="text-align: center">垂直起飞(VerticalTakeOff)</td>
<td style="text-align: center">超音速飞行(SuperSonicFly)</td>
</tr>
</tbody>
</table>

<p>请使用策略模式完成上述问题的设计。</p>

<h3 id="toc_8">实现</h3>

<p><a href="https://github.com/swuzjb/DesignPatterns">相关代码Github地址</a><br/>
<a href="http://blog.csdn.net/lovelion">文章参考-刘伟</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[剑指offer-旋转数组的最小数字]]></title>
    <link href="http://swuzjb.github.io/14891123573052.html"/>
    <updated>2017-03-10T10:19:17+08:00</updated>
    <id>http://swuzjb.github.io/14891123573052.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br/>
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br/>
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br/>
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
</blockquote>

<h2 id="toc_0">解题思路</h2>

<h3 id="toc_1">O(n)算法</h3>

<p>数组遍历，如果a[i]&lt;a[i-1]，这该位置为旋转位置，即最小元素。</p>

<h3 id="toc_2">O(logn)算法</h3>

<p>我们可以通过二分的思路，对上述问题进行优化。<br/>
我们发现，旋转之后的数组实际上可以划分为两个排序的子数组，而且后面的子数组的元素都小于等于前面的子数组的元素。而我们要找的这个最小元素，恰好是这两个数组的分界线。<br/>
和二分查找一样，我们分别用两个指针指向数组的第一个(start)和最后一个元素(end)，在求一个中间指针指向数组的中间(<code>mid = (start+end)/2</code>)：</p>

<ul>
<li>如果array[mid] &gt;= array[end],说明分界值应该在数组的后半段，此时将start赋值为mid；</li>
<li>如果array[mid] &lt;= array[start],说明分界值应该在数组的前半段，此时将end赋值为mid；</li>
<li>如果<code>end-start == 1</code>，说明array[end]为我们要找的分界值。</li>
<li>PS.如果 array[mid] == array[start] == array[end]，此时只能通过遍历来实现。</li>
</ul>

<h2 id="toc_3">代码示例</h2>

<h3 id="toc_4">O(n)</h3>

<pre><code class="language-java">public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if(array.length == 0){
            return 0;
        }
        for(int i=1;i&lt;array.length;i++){
            if(array[i]&lt;array[i-1]){
                return array[i];
            }
        }
        return array[0];
    }
}
</code></pre>

<h3 id="toc_5">O(logn)</h3>

<pre><code class="language-java">public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if (array.length == 0) {
            return 0;
        }
        int start = 0;
        int end = array.length - 1;
        while (end - start &gt; 1) {
            int mid = (start + end) / 2;
            
            if(array[start] == array [mid] &amp;&amp; array[mid] == array[end]){
                return order(array, start, end);
            }
            
            if( array[mid] &gt;= array[end]){
                start = mid;
                continue;
            }
            if(array[mid] &lt;= array[start]){
                end = mid;
                continue;
            }
        }
        return array[end];
    }
        
    public int order(int[] array,int start,int end){
        for(int i = start+1;i&lt;=end;i++){
            if(array[i]&lt;array[i-1]){
                return  array[i];
            }
        }
        return array[start];
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[剑指Offer-用两个栈实现队列]]></title>
    <link href="http://swuzjb.github.io/14891114918366.html"/>
    <updated>2017-03-10T10:04:51+08:00</updated>
    <id>http://swuzjb.github.io/14891114918366.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
</blockquote>

<h2 id="toc_0">解决思路</h2>

<p>栈是后进先出，而队列是先进先出，在pop的过程上是相反的。所以我们要解决的核心问题就是这样。<br/>
Stack1用来push数据，这样，最先进入的元素就成为了Stack1的栈底元素。当我们需要出队时，需要找到第一个进入stack1的元素，于是，我们分别将stack1的元素出栈，压入stack2，这时，stack2中的栈顶元素，就是最开始我们插入栈中的元素，也就是我们要pop的元素。<br/>
所以，就有了如下的规则:</p>

<ul>
<li>push操作：压入stack1中；</li>
<li>pop操作：如果stack2中有元素，则返回stack2的栈顶元素；若stack2为空，则依次将stack1中的元素出栈，压入stack2中，返回stack2的栈顶元素。</li>
</ul>

<h2 id="toc_1">代码如下：</h2>

<pre><code class="language-java">import java.util.Stack;

public class Solution {
    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();
    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();
    
    public void push(int node) {
        stack1.push(node);
    }
    
    public int pop() {
        if(stack2.size() &gt; 0 ){
            return stack2.pop();
        }
        
        while(stack1.size() &gt; 0 ){
            stack2.push(stack1.pop());
        }
        return stack2.pop();
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[剑指Offer-重建二叉树]]></title>
    <link href="http://swuzjb.github.io/14890277021887.html"/>
    <updated>2017-03-09T10:48:22+08:00</updated>
    <id>http://swuzjb.github.io/14890277021887.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
</blockquote>

<h2 id="toc_0">结题思路</h2>

<p>在二叉树的前序遍历中，第一个数字总是数的根节点的值。但在中序遍历中，根节点的值在序列的中间，左子树的结点的值位于根节点的左边，而右子树的节点的值位于根节点的值的右边，因此，我们需要扫描中序遍历，才能找到根节点的值。实例如图：<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-03-09-14890289045009.jpg" alt=" -c "/></p>

<p>既然我们已经分别找到了左、右子树的前序遍历和中序遍历序列，我们可以用同样的方法去分别构建左右子树。也就是递归去实现。</p>

<h2 id="toc_1">代码</h2>

<pre><code class="language-java">/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        return reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length);
    }
    
    public TreeNode reConstructBinaryTree(int[] pre,int pStart,int pEnd,int[] in,int iStart,int iEnd){
        if(pStart &gt; pEnd || iStart &gt; iEnd ){
            return null;
        }
        
        TreeNode node = new TreeNode(pre[pStart]);
        int k = find(in, pre[pStart], iStart, iEnd) - iStart;
        node.left = reConstructBinaryTree(pre, pStart+1, pStart+k, in, iStart, iStart+k);
        node.right = reConstructBinaryTree(pre, pStart+k+1, pEnd, in, iStart+k+1, iEnd);
        return node;
        
    }
    
    public int find(int[] array,int target,int start,int end){
        for(int i = start;i&lt;=end;i++){
            if(array[i] == target){
                return i;
            }
        }
        return -1;
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[剑指Offer-从尾到头打印链表]]></title>
    <link href="http://swuzjb.github.io/14890230803105.html"/>
    <updated>2017-03-09T09:31:20+08:00</updated>
    <id>http://swuzjb.github.io/14890230803105.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>输入一个链表，从尾到头打印链表每个节点的值。</p>
</blockquote>

<h2 id="toc_0">问题解答</h2>

<p>要解决这个问题肯定要遍历链表。遍历的顺序是从头到尾的顺序，可是输出的要求顺序却是从尾到头。也就是说第一个遍历到的节点，最后一个输出，而最后一个遍历到的节点第一个输出。这就是典型的后进先出，我们可以用栈实现这个顺序。每经过一个节点的时候，把该节点放入到一个栈中。当遍历完整个链表后，再从栈顶开始逐个输出节点的值，此时，输出的节点顺序已经反转过来了。<br/>
既然可以使用栈实现这个需求，那么我们就可以考虑使用递归，递归本质上就是一个栈结构。这样要实现反过来输出链表，我们每访问到一个结点的时候，先递归输出它后面的节点，在输出该节点自身，这样链表的输出就反过来了。</p>

<h2 id="toc_1">递归实现</h2>

<pre><code class="language-java">/**
*    public class ListNode {
*        int val;
*        ListNode next = null;
*
*        ListNode(int val) {
*            this.val = val;
*        }
*    }
*
*/
import java.util.ArrayList;
public class Solution {
    private ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;();
    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {
        search(listNode);
        return array;
    }
    public void  search(ListNode listNode){
        if(listNode != null){
            search(listNode.next);
            array.add(listNode.val);
        }
        
    }
}
</code></pre>

<p>本题基于递归实现看起来很简洁，但是有个问题，当链表非常长的时候，就会导致函数调用层级很深，从而有可能导致函数调用栈溢出。</p>

<h2 id="toc_2">显示栈实现</h2>

<pre><code class="language-java">import java.util.*;

public class Solution {
    
    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {
        ArrayDeque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();
        while(listNode != null){
            stack.offerFirst(listNode.val);
            listNode = listNode.next;
        }
        ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;(stack.size());
        while (stack.size()&gt;0) {
            array.add(stack.pollFirst());
        }
        return array;
    }
    
}
</code></pre>

<h2 id="toc_3">翻转链表</h2>

<p>如果可以改变原链表的结构，就可以对链表进行翻转。</p>

<pre><code class="language-java">import java.util.ArrayList;
public class Solution {
    private ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;();
    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {
        ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;();
        ListNode head = null;
        ListNode next = null;
        while (listNode != null) {
            next = listNode.next;
            listNode.next = head;
            head = listNode;
            listNode = next;
        }
        while (head != null) {
            array.add(head.val);
            head = head.next;
        }
        return array;
    }
    
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[剑指Offer-替换空格]]></title>
    <link href="http://swuzjb.github.io/14889379059302.html"/>
    <updated>2017-03-08T09:51:45+08:00</updated>
    <id>http://swuzjb.github.io/14889379059302.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
</blockquote>

<h2 id="toc_0">结题思路</h2>

<p>这个题目Java开发者可能一下就笑了，so easy啊，一个库函数就解决了。但是，我们还是要尝试去造一下轮子，追求原理。<br/>
由于要将空格替换为%20，字符串前后的长度肯定不一样，那么就肯定涉及到了重新申请内存地址。</p>

<p>最简单的思路，我们遍历字符串，发现空格，就将空格后面的字符进行移动，然后继续遍历。这样的做法时间复杂度为O(n<sup>2)，因为每次都移动了大量的字符。</sup></p>

<p>所以我们提出一个简要的方法，重新申请一个字符串（C/C++中准确的成为字符数组），这个新字符串的长度为原字符串长度+空格个数*2（空格的个数，可以通过一次遍历获得），然后用两个指针变量分别指向两个字符串的首位，然后进行复制，当原字符串指针指向空格时，新字符串插入“%20”，直到末尾。</p>

<h2 id="toc_1">实现代码</h2>

<p>库函数解决：</p>

<pre><code class="language-java">public class Solution {
    public String replaceSpace(StringBuffer str) {
        return str.toString().replaceAll(&quot; &quot;, &quot;%20&quot;);
    }
}
</code></pre>

<p>自己过不去版：</p>

<pre><code class="language-java">public class Solution {
    public String replaceSpace(StringBuffer str) {
        StringBuffer newStr = new StringBuffer();
        
        int i = 0;
        
        while(i&lt;str.length()){
            if(str.charAt(i) != &#39; &#39;){
                newStr.append(str.charAt(i));
            }else{
                newStr.append(&quot;%20&quot;);
            }
            i++;
        }
        return newStr.toString();
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[剑指Offer-二维数组中的查找]]></title>
    <link href="http://swuzjb.github.io/14889364537323.html"/>
    <updated>2017-03-08T09:27:33+08:00</updated>
    <id>http://swuzjb.github.io/14889364537323.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</blockquote>

<h2 id="toc_0">解题思路</h2>

<p>假设二维数组为N行，M列。则初始下标变量<code>int i=0;</code> <code>int j = M-1;</code>。此时选取a[i][j]作为比较标准:</p>

<ul>
<li>若target == a[i][j],则表明已找到对应的数字，返回true；</li>
<li>若target &gt; a[i][j],由于数组是从左至右递增的，所以这一行左边的数据都要比a[i][j]小，所以可以排除，此时将i++，作为新的比较标准；</li>
<li>若target &lt; a[i][j]，由于数组是从上而下递增的，该列的所有数字都比target大，不需要比较，则将j--，作为新的比较标准；</li>
<li>若遍历到<code>i==n，j==0</code>,依旧没有找到匹配数据，则返回false；</li>
</ul>

<h2 id="toc_1">实现代码</h2>

<pre><code class="language-java">public class Solution {
    public boolean Find(int target, int [][] array) {
        if(array.length == 0){
            return false;
        }
        int i = 0;
        int j = array[0].length - 1;
        
        while(i &lt; array.length &amp;&amp; j &gt;=0){
            if(array[i][j] == target){
                return true;
            }
            if(target &gt; array[i][j]){
                i++;
                continue;
            }
            if(target &lt; array[i][j]){
                j--;
                continue;
            }
        }
        return false;

    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java容器框架分析(九)——WeakHashMap]]></title>
    <link href="http://swuzjb.github.io/14880758779206.html"/>
    <updated>2017-02-26T10:24:37+08:00</updated>
    <id>http://swuzjb.github.io/14880758779206.html</id>
    <content type="html"><![CDATA[
<p>在Java容器框架系列文章的最后，笔者打算介绍一个特殊的成员：WeakHashMap，从名字可以看出它是某种Map。它的特殊之处在于WeakHashMap里的entry可能会被GC自动删除，即使程序员没有调用remove()或者clear()方法。</p>

<p>更直观的说，当使用WeakHashMap时，即使没有显示的添加或者删除任何元素，也可能发生如下情况：</p>

<ul>
<li>调用两次<code>size()</code>方法返回不同的值</li>
<li>两次调用<code>isEmpty()</code>方法，第一次返回<code>false</code>，第二次返回<code>true</code></li>
<li>两次调用<code>containsKey()</code>方法，第一次返回<code>true</code>，第二次返回<code>false</code>，尽管是同一个<code>key</code></li>
<li>两次调用<code>get()</code>方法，第一次返回一个<code>value</code>，第二次返回<code>null</code>，尽管两次使用的是同一个对象</li>
</ul>

<p>遇到这么奇葩的现象，你是不是觉得使用者一定疯掉？其实不然，<strong>WeekHashMap的这个特点特别适用于需要缓存的场景</strong>。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高效率，但缓存Miss也不会造成错误，因为可以通过计算重新得到。</p>

<p>要明白WeakHashMap的工作原理，还需要引入一个概念：<strong>弱引用</strong>。我们知道Java中的内存是通过GC自动管理的，GC会在程序运行过程中自动判断哪些对象时可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可以回收的依据是：<strong>是否有有效的引用指向该对象</strong>。如果没有有效引用指向该对象（意味着不存在访问该对象的方式），那么该对象就是可回收的。这里的<strong>有效引用并不包括弱引用</strong>。也就是说，虽然<strong>弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收</strong>。</p>

<p>WeakHashMap内部使用弱引用来管理entry，弱引用的特性对应到WeakHashMap上意味着什么呢？将一对key,value放入到WeakHashMap里并不能避免该key值被GC回收，除非在WeakHashMap之外还有对该key的强引用。</p>

<h2 id="toc_0">具体实现</h2>

<p>WeakHashMap的储存结构类似于HashMap，可参考前文。</p>

<h3 id="toc_1">WeakHashSet？</h3>

<p>如果你看过前几篇关于Map和Set的讲解，一定会问：既然有 WeekHashMap，是否有WeekHashSet呢？答案是没有！不过Java Collections工具类给出了解决方案，<code>Collections.newSetFromMap(Map&lt;E,Boolean&gt; map)</code>方法可以将任何Map包装成一个Set。通过如下方式可以快速得到一个 Weak HashSet：<br/>
<code>java<br/>
// 将WeakHashMap包装成一个Set<br/>
Set&lt;Object&gt; weakHashSet = Collections.newSetFromMap(<br/>
        new WeakHashMap&lt;Object, Boolean&gt;());<br/>
</code><br/>
其内部只是对传入的Map进行了简单的封装：</p>

<pre><code class="language-java">// Collections.newSetFromMap()用于将任何Map包装成一个Set
public static &lt;E&gt; Set&lt;E&gt; newSetFromMap(Map&lt;E, Boolean&gt; map) {
    return new SetFromMap&lt;&gt;(map);
}

private static class SetFromMap&lt;E&gt; extends AbstractSet&lt;E&gt;
    implements Set&lt;E&gt;, Serializable
{
    private final Map&lt;E, Boolean&gt; m;  // The backing map
    private transient Set&lt;E&gt; s;       // Its keySet
    SetFromMap(Map&lt;E, Boolean&gt; map) {
        if (!map.isEmpty())
            throw new IllegalArgumentException(&quot;Map is non-empty&quot;);
        m = map;
        s = map.keySet();
    }
    public void clear()               {        m.clear(); }
    public int size()                 { return m.size(); }
    public boolean isEmpty()          { return m.isEmpty(); }
    public boolean contains(Object o) { return m.containsKey(o); }
    public boolean remove(Object o)   { return m.remove(o) != null; }
    public boolean add(E e) { return m.put(e, Boolean.TRUE) == null; }
    public Iterator&lt;E&gt; iterator()     { return s.iterator(); }
    public Object[] toArray()         { return s.toArray(); }
    public &lt;T&gt; T[] toArray(T[] a)     { return s.toArray(a); }
    public String toString()          { return s.toString(); }
    public int hashCode()             { return s.hashCode(); }
    public boolean equals(Object o)   { return o == this || s.equals(o); }
    public boolean containsAll(Collection&lt;?&gt; c) {return s.containsAll(c);}
    public boolean removeAll(Collection&lt;?&gt; c)   {return s.removeAll(c);}
    public boolean retainAll(Collection&lt;?&gt; c)   {return s.retainAll(c);}
    // addAll is the only inherited implementation
    ......
}
</code></pre>

<h2 id="toc_2">声明</h2>

<p>本系列博文装载自：<a href="https://github.com/CarpenterLee/JCFInternals">https://github.com/CarpenterLee/JCFInternals</a><br/>
作者：CarpenterLee</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java容器框架分析(八)——PriorityQueue]]></title>
    <link href="http://swuzjb.github.io/14879958366746.html"/>
    <updated>2017-02-25T12:10:36+08:00</updated>
    <id>http://swuzjb.github.io/14879958366746.html</id>
    <content type="html"><![CDATA[
<p>前面以ArrayDeque讲解了Stack和Queue，其实还有一种特殊的队列叫做PriorityQueue，即优先队列。优先队列的作用是能保证每次取出的元素都是队列中权值最小的（Java的优先队列是每次取出最小的元素，C++的优先队列是每次取最大元素）。这里涉及到大小关系，元素的大小评判可以通过元素本身的自然顺序，或者通过自定义的比较器来进行定义。</p>

<p>Java中的PriorityQueue实现了Queue接口，不允许放入null元素；其底层通过堆实现，具体说是通过完全二叉树实现的小根堆（任意一个非叶子节点的权值，都不大于左右子节点的权值），也就意味着可以通过数组来作为PriorityQueue的底层实现。</p>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-25-14879965840202.png" alt=""/></p>

<p>上图中我们给每个元素按照宽度优先遍历的方式进行了编号，如果你足够细心会发现，父子节点的编号是有规律的：</p>

<ul>
<li><code>leftNo = parentNo*2+1</code></li>
<li><code>rightNo = parentNo*2+2</code></li>
<li><code>parentNo = (nodeNo - 1 ) / 2</code></li>
</ul>

<p>通过上述三个公式，可以轻易的推算某个节点的父子节点位置。这也就是为什么可以用数组来储存堆的原因。</p>

<p>PriorityQueue的<code>peek()</code>和<code>element()</code>操作是常数时间。<code>add()</code>、<code>offer()</code>、无参数的<code>remove()</code>、以及<code>poll()</code>方法的时间复杂度都是log(n)。</p>

<h2 id="toc_0">常用方法剖析</h2>

<h3 id="toc_1">add()&amp;offer()</h3>

<p>add(E e)和offer(E e)的语义相同，都是向优先队列中插入元素，只是Queue接口规定二者对插入时失败的处理不同，前者在插入失败时抛出异常，后者则返回false。对于PriorityQueue这个方法在实现上并没有什么区别。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-25-14880003809279.png" alt=""/></p>

<p>新插入的元素可能会破坏小根堆的性质，所以必须进行调整。</p>

<pre><code class="language-java">public boolean offer(E e) {
    if (e == null)//不允许放入null元素
        throw new NullPointerException();
    modCount++;
    int i = size;
    if (i &gt;= queue.length)
        grow(i + 1);//自动扩容
    size = i + 1;
    if (i == 0)//队列原来为空，这是插入的第一个元素
        queue[0] = e;
    else
        siftUp(i, e);//调整
    return true;
}
</code></pre>

<p>上述代码中，扩容函数grow()类似于ArrayList中的grow()函数，就是再申请一个更大的数组，并将原数组复制过去，这里不再赘述。需要注意的调整函数。siftUp(int k,E e)，该方法用于插入元素x并维持堆的特性。</p>

<pre><code class="language-java">private void siftUp(int k, E x) {
    while (k &gt; 0) {
        int parent = (k - 1) &gt;&gt;&gt; 1;//parentNo = (nodeNo-1)/2
        Object e = queue[parent];
        if (comparator.compare(x, (E) e) &gt;= 0)//调用比较器的比较方法
            break;
        queue[k] = e;
        k = parent;
    }
    queue[k] = x;
}
</code></pre>

<p>新加入的元素x可能会破坏小根堆的性质，因此需要进行调整，调整的过程为：<strong>从指定位置k开始将x逐层与当前点的parent进行比较并交换知道满足<code>x&gt;=queue[parent]</code>为止</strong>，这里比较的可以是自然顺序，也可以是自定义的比较器顺序。</p>

<h3 id="toc_2">element()&amp;peek()</h3>

<p>element()和peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，两者唯一区别是方法失败时前者抛出异常后者返回null。根据小根堆的性质，堆顶的那个元素就是全局最小的；由于堆用数组进行存储，根据下标关系，0下标处的那个元素就是堆顶元素，所以直接返回数组0下标的那个元素即可。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-25-14880023896388.png" alt=""/></p>

<pre><code class="language-java">//peek()
public E peek() {
    if (size == 0)
        return null;
    return (E) queue[0];//0下标处的那个元素就是最小的那个
}
</code></pre>

<h3 id="toc_3">remove()&amp;poll()</h3>

<p>remove()和poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回null。由于删除操作会改变堆的结构，为维护小根堆的性质，需要进行必要的调整。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-25-14880029594504.png" alt=""/><br/>
代码如下：</p>

<pre><code class="language-java">public E poll() {
    if (size == 0)
        return null;
    int s = --size;
    modCount++;
    E result = (E) queue[0];//0下标处的那个元素就是最小的那个
    E x = (E) queue[s];
    queue[s] = null;
    if (s != 0)
        siftDown(0, x);//调整
    return result;
}
</code></pre>

<p>上述代码首先记录0下标处的元素，并用最后一个元素替换0下标位置的元素，之后调用<code>siftDown()</code>方法对堆进行调整，最后返回原来0下标位置那个元素（也就是原先的堆顶元素）。重点是<code>siftDown(int k,E e)</code>方法，该方法的作用是<strong>从k指定的位置开始，将x逐层向下与当前点的左右孩子中较小的那个交换，直到x小于等于左右孩子中的任意一个位置</strong>。</p>

<pre><code class="language-java">//siftDown()
private void siftDown(int k, E x) {
    int half = size &gt;&gt;&gt; 1;
    while (k &lt; half) {
        //首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标
        int child = (k &lt;&lt; 1) + 1;//leftNo = parentNo*2+1
        Object c = queue[child];
        int right = child + 1;
        if (right &lt; size &amp;&amp;
            comparator.compare((E) c, (E) queue[right]) &gt; 0)
            c = queue[child = right];
        if (comparator.compare(x, (E) c) &lt;= 0)
            break;
        queue[k] = c;//然后用c取代原来的值
        k = child;
    }
    queue[k] = x;
}
</code></pre>

<h3 id="toc_4">remove(Object o)</h3>

<p>remove(Object o)方法用于删除队列中跟o相等的某一个元素（如果多个相等，只删除一个），该方法不是Queue接口内的方法，而是Collection接口的方法。由于删除操作会改变队列的结构，所以需要进行调整；又由于删除位置是任意的，所以调整过程比其它函数复杂一些。具体来说，remove(Object o)可以分为2种情况：1.删除的是最后一个元素则直接删除即可，不需要调整；2.删除的不是最后一个元素，从删除点开始以最后一个元素为参照点调用一次siftDown()即可。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-25-14880047702540.png" alt=""/></p>

<pre><code class="language-java">//remove(Object o)
public boolean remove(Object o) {
    //通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标
    int i = indexOf(o);
    if (i == -1)
        return false;
    int s = --size;
    if (s == i) //情况1
        queue[i] = null;
    else {
        E moved = (E) queue[s];
        queue[s] = null;
        siftDown(i, moved);//情况2
        ......
    }
    return true;
}
</code></pre>

<h2 id="toc_5">声明</h2>

<p>本系列博文装载自：<a href="https://github.com/CarpenterLee/JCFInternals">https://github.com/CarpenterLee/JCFInternals</a><br/>
作者：CarpenterLee</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java容器框架分析(七)——LinkedHashSet与LinkedHashMap]]></title>
    <link href="http://swuzjb.github.io/14879892493054.html"/>
    <updated>2017-02-25T10:20:49+08:00</updated>
    <id>http://swuzjb.github.io/14879892493054.html</id>
    <content type="html"><![CDATA[
<p>如果你已经看过前面关于HashSet和HashMap，以及TreeSet和TreeMap的讲解，一定能够想到本文要讲解的LinkedSet和LinkedHashMap在Java中也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说<strong>LinkedHashSet里面有一个LinkedHashMap(适配器模式)</strong>。因此本文将重点介绍LinkedHashMap。</p>

<p>LinkedHashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素。从名字上可以看出该容器是LinkedList和HashMap的混合体，也就是说它同时满足HashMap和LinkedList的某些特性。可以将LinkedHashMap看作采用LinkedList增强的HashMap。</p>

<p>事实上LinkedHashMap是HashMap的直接子类，二者的唯一区别是LinkedHashMap在HashMap的基础上，采用双向链表的形式将所有entry连接起来，这样是为保证元素的迭代顺序和插入顺序相同。</p>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-25-14879901525374.png" alt=""/></p>

<p>上图给出了LinkedHashMap的结构图，主体部分跟HashMap完全一样，多了header指向双向链表的头部，该双向链表的迭代顺序就是entry的插入顺序。<br/>
除了可以保证迭代顺序，这种结构还有一个好处：迭代LinkedHashMap时不需要像HashMap那样遍历整个table，而是只需要直接遍历header指向的双向链表即可。也就说LinkedHashMap的迭代时间就只跟entry的个数有关，和table的大小无关。</p>

<p>有两个参数可以影响 LinkedHashMap 的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。<br/>
将对象放入到 LinkedHashMap 或 LinkedHashSet 中时，有两个方法需要特别关心：<code>hashCode()</code>和<code>equals()</code>。<code>hashCode()</code>方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是 “同一个对象”。所以，如果要将自定义的对象放入到LinkedHashMap或LinkedHashSet中，需要覆盖<code>hashCode()</code>和<code>equals()</code>方法。</p>

<p>通过如下方式可以得到一个跟源Map迭代顺序一样的LinkedHashMap：</p>

<pre><code class="language-java">void foo(Map m) {
    Map copy = new LinkedHashMap(m);
    ...
}
</code></pre>

<p>出于性能原因，LinkedHashMap是非线程安全的，如果需要在多线程环境使用，需要程序呀手动进行同步；或者通过如下方式将LinkedHashMap包装成同步的：</p>

<pre><code class="language-java">Map m = Collections.synchronizedMap(new LinkedHashMap(...));
</code></pre>

<h2 id="toc_0">常用方法剖析</h2>

<h3 id="toc_1">get()</h3>

<p>get(Object key)方法根据指定的key值返回对应的value.该方法的流程和HashMap的实现方式基本一样，可参考前文。</p>

<h3 id="toc_2">put()</h3>

<p><code>put(K key,V value)</code>方法是将指定的<code>key,value</code>对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>get()</code>方法；如没有找到则会通过<code>addEntry(int hash,K key,V value,int bucketIndex)</code>方法插入新的entry。<br/>
PS.这里的插入有两重含义：</p>

<ol>
<li>从table的角度来看，新的entry需要插入到对应的bucket里，当有哈希冲突时，采用头插法将新的entry插入到冲突链表的头部。</li>
<li>从header的角度，新的entry需要插入到双向链表的尾部。</li>
</ol>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-25-14879912929279.png" alt=""/></p>

<p>addEntry()代码如下：</p>

<pre><code class="language-java">void addEntry(int hash, K key, V value, int bucketIndex) {
    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
        resize(2 * table.length);// 自动扩容，并重新哈希
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = hash &amp; (table.length-1);// hash%table.length
    }
    // 1.在冲突链表头部插入新的entry
    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];
    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(hash, key, value, old);
    table[bucketIndex] = e;
    // 2.在双向链表的尾部插入新的entry
    e.addBefore(header);
    size++;
}
</code></pre>

<p>上述代码中用到了<code>addBefore()</code>方法将新<code>entry e</code>插入到双向链表引用<code>header</code>的前面，这样e就成为了双向链表中的最后一个元素。<code>addBefore()</code>的代码如下：</p>

<pre><code class="language-java">// LinkedHashMap.Entry.addBefor()，将this插入到existingEntry的前面
private void addBefore(Entry&lt;K,V&gt; existingEntry) {
    after  = existingEntry;
    before = existingEntry.before;
    before.after = this;
    after.before = this;
}
</code></pre>

<p>仅需要简单修改相关entry的引用而已。</p>

<h3 id="toc_3">remove()</h3>

<p><code>remove(Object key)</code>的作用是删除key值对应的entry，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到key值对应的entry，然后删除entry(修改链表的引用)。查找过程和get()方法类似。<br/>
注意，这里的删除也有两层含义：</p>

<ol>
<li>从table的角度看，需要将该entry从对应的bucket里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。</li>
<li>从header的角度来看，需要将该entry从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。</li>
</ol>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-25-14879925343738.png" alt=""/></p>

<p><code>removeEntryForKey()</code>对应的代码如下：</p>

<pre><code class="language-java">// LinkedHashMap.removeEntryForKey()，删除key值对应的entry
final Entry&lt;K,V&gt; removeEntryForKey(Object key) {
    ......
    int hash = (key == null) ? 0 : hash(key);
    int i = indexFor(hash, table.length);// hash&amp;(table.length-1)
    Entry&lt;K,V&gt; prev = table[i];// 得到冲突链表
    Entry&lt;K,V&gt; e = prev;
    while (e != null) {// 遍历冲突链表
        Entry&lt;K,V&gt; next = e.next;
        Object k;
        if (e.hash == hash &amp;&amp;
            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {// 找到要删除的entry
            modCount++; size--;
            // 1. 将e从对应bucket的冲突链表中删除
            if (prev == e) table[i] = next;
            else prev.next = next;
            // 2. 将e从双向链表中删除
            e.before.after = e.after;
            e.after.before = e.before;
            return e;
        }
        prev = e; e = next;
    }
    return e;
}
</code></pre>

<h2 id="toc_4">LinkedHashSet</h2>

<p>前面已经说过 LinkedHashSet 是对 LinkedHashMap 的简单包装，对 LinkedHashSet 的函数调用都会转换成合适的 LinkedHashMap 方法，因此 LinkedHashSet 的实现非常简单，这里不再赘述。</p>

<pre><code class="language-java">public class LinkedHashSet&lt;E&gt;
    extends HashSet&lt;E&gt;
    implements Set&lt;E&gt;, Cloneable, java.io.Serializable {
    ......
    // LinkedHashSet里面有一个LinkedHashMap
    public LinkedHashSet(int initialCapacity, float loadFactor) {
        map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);
    }
    ......
    public boolean add(E e) {//简单的方法转换
        return map.put(e, PRESENT)==null;
    }
    ......
}
</code></pre>

<h2 id="toc_5">声明</h2>

<p>本系列博文装载自：<a href="https://github.com/CarpenterLee/JCFInternals">https://github.com/CarpenterLee/JCFInternals</a><br/>
作者：CarpenterLee</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java容器框架分析(六)——HashSet与HashMap]]></title>
    <link href="http://swuzjb.github.io/14879172287548.html"/>
    <updated>2017-02-24T14:20:28+08:00</updated>
    <id>http://swuzjb.github.io/14879172287548.html</id>
    <content type="html"><![CDATA[
<p>之所以把HashSet和HashMap放在一起，是因为二者在Java中有着相同的实现，前者仅仅是对后者进行了一次封装，也就是说HashSet中有一个HashMap(适配器模式)。因此本文将重点分析HashMap。</p>

<p>HashMap实现了Map接口，允许放入key为null的元素，也允许插入value为null的元素。除没有实现同步外，其余跟HashTable大致相同；跟TreeMap不同，该容器不保证元素顺序，根据需要，该容器可能会对元素重新哈希，元素的顺序也会被重新打散。因此在不同时间迭代同一个HashMap的顺序可能会不同。</p>

<p>根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式，另外一种是冲突链表方式。Java HashMap采用的是冲突链表方式。</p>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14879180909568.png" alt=""/></p>

<p>从上图可以看出，如果选择合适的哈希函数，put()和get()方法可以在常数时间内完成。但是在对HashMap进行迭代时，需要遍历整个table及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将HashMap的初始大小设置的过大。</p>

<p>有两个参数可以影响HashMap的性能：初始容量（inital capacity）和负载系数（loadFactor）。初始容量指定了初始table的大小，负载系数表示用来自动扩容的临界值。<br/>
当entry的数量超过<code>capacity*loadFactor</code>时，容器将自动扩容并重新哈希，对于插入元素较多的场景，将初始容量设大可以减小重新哈希的次数。</p>

<p>将对象放入到HashMap或者HashSet中时，有两个方法需要特别注意：<code>hashCode()</code>和<code>equals()</code>。<code>hashCode()</code>决定了对象会被放在哪个bucket里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是同一个对象。所以，如果要将自定义的对象放入到HashMap或者HashSet中，需要覆盖<code>hashCode()</code>和<code>equals()</code>方法。</p>

<h2 id="toc_0">常用方法剖析</h2>

<h3 id="toc_1">get()</h3>

<p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.getValue()</code>。因此<code>getEntry()</code>是算法的核心。<br/>
算法思想是首先通过<code>hash()</code>函数得到对应的bucket下标，然后依次遍历冲突链表，通过<code>key.equals(k)</code>方法来判断是否是要找的那个<code>entry</code>。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14879194728200.png" alt=""/><br/>
上图中 <code>hash(k)&amp;(table.length-1)</code>等价于<code>hash(k)%table.length</code>，原因是table.length必须是2的指数，因此table.length-1就是二进制低位全是1，跟hash(k)相与会将hash值得高位全抹掉，剩下的就是余数了。</p>

<pre><code class="language-java">final Entry&lt;K,V&gt; getEntry(Object key) {
    ......
    int hash = (key == null) ? 0 : hash(key);
    for (Entry&lt;K,V&gt; e = table[hash&amp;(table.length-1)];//得到冲突链表
         e != null; e = e.next) {//依次遍历冲突链表中的每个entry
        Object k;
        //依据equals()方法判断是否相等
        if (e.hash == hash &amp;&amp;
            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
            return e;
    }
    return null;
}
</code></pre>

<h3 id="toc_2">put()</h3>

<p>put(K key,V value)方法是将指定的key,value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含该元组，则直接返回，查找过程类似于getEntry()方法；如果没有找到，则会通过addEntry(int hash,K key,V value,int bucketIndex)方法插入新的entry，插入方式为头插法。</p>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14879200695663.png" alt=""/></p>

<pre><code class="language-java">void addEntry(int hash, K key, V value, int bucketIndex) {
    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
        resize(2 * table.length);//自动扩容，并重新哈希
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = hash &amp; (table.length-1);//hash%table.length
    }
    //在冲突链表头部插入新的entry
    Entry&lt;K,V&gt; e = table[bucketIndex];
    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
    size++;
}
</code></pre>

<h3 id="toc_3">remove()</h3>

<p><code>remove(Object key)</code>的作用是删除对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里面实现的。<code>removeEntryForKey(Object key)</code>方法会首先找到key值对应的entry，然后删除entry（修改链表的引用）。查找过程类似于getEntry()。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14879203192877.png" alt=""/></p>

<pre><code class="language-java">//removeEntryForKey()
final Entry&lt;K,V&gt; removeEntryForKey(Object key) {
    ......
    int hash = (key == null) ? 0 : hash(key);
    int i = indexFor(hash, table.length);//hash&amp;(table.length-1)
    Entry&lt;K,V&gt; prev = table[i];//得到冲突链表
    Entry&lt;K,V&gt; e = prev;
    while (e != null) {//遍历冲突链表
        Entry&lt;K,V&gt; next = e.next;
        Object k;
        if (e.hash == hash &amp;&amp;
            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {//找到要删除的entry
            modCount++; size--;
            if (prev == e) table[i] = next;//删除的是冲突链表的第一个entry
            else prev.next = next;
            return e;
        }
        prev = e; e = next;
    }
    return e;
}
</code></pre>

<h2 id="toc_4">HashSet</h2>

<p>前面已经说过 HashSet 是对 HashMap 的简单包装，对 HashSet 的函数调用都会转换成合适的 HashMap 方法，因此 HashSet 的实现非常简单，只有不到 300 行代码。这里不再赘述。</p>

<pre><code class="language-java">public class HashSet&lt;E&gt;
{
    ......
    private transient HashMap&lt;E,Object&gt; map;//HashSet里面有一个HashMap
    // Dummy value to associate with an Object in the backing Map
    private static final Object PRESENT = new Object();
    public HashSet() {
        map = new HashMap&lt;&gt;();
    }
    ......
    public boolean add(E e) {//简单的方法转换
        return map.put(e, PRESENT)==null;
    }
    ......
}
</code></pre>

<h2 id="toc_5">声明</h2>

<p>本系列博文装载自：<a href="https://github.com/CarpenterLee/JCFInternals">https://github.com/CarpenterLee/JCFInternals</a><br/>
作者：CarpenterLee</p>

]]></content>
  </entry>
  
</feed>
