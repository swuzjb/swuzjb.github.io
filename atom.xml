<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Zhan's Blog]]></title>
  <link href="http://swuzjb.github.io/atom.xml" rel="self"/>
  <link href="http://swuzjb.github.io/"/>
  <updated>2017-02-28T10:35:19+08:00</updated>
  <id>http://swuzjb.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Java容器框架分析(九)——WeakHashMap]]></title>
    <link href="http://swuzjb.github.io/14880758779206.html"/>
    <updated>2017-02-26T10:24:37+08:00</updated>
    <id>http://swuzjb.github.io/14880758779206.html</id>
    <content type="html"><![CDATA[
<p>在Java容器框架系列文章的最后，笔者打算介绍一个特殊的成员：WeakHashMap，从名字可以看出它是某种Map。它的特殊之处在于WeakHashMap里的entry可能会被GC自动删除，即使程序员没有调用remove()或者clear()方法。</p>

<p>更直观的说，当使用WeakHashMap时，即使没有显示的添加或者删除任何元素，也可能发生如下情况：</p>

<ul>
<li>调用两次<code>size()</code>方法返回不同的值</li>
<li>两次调用<code>isEmpty()</code>方法，第一次返回<code>false</code>，第二次返回<code>true</code></li>
<li>两次调用<code>containsKey()</code>方法，第一次返回<code>true</code>，第二次返回<code>false</code>，尽管是同一个<code>key</code></li>
<li>两次调用<code>get()</code>方法，第一次返回一个<code>value</code>，第二次返回<code>null</code>，尽管两次使用的是同一个对象</li>
</ul>

<p>遇到这么奇葩的现象，你是不是觉得使用者一定疯掉？其实不然，<strong>WeekHashMap的这个特点特别适用于需要缓存的场景</strong>。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高效率，但缓存Miss也不会造成错误，因为可以通过计算重新得到。</p>

<p>要明白WeakHashMap的工作原理，还需要引入一个概念：<strong>弱引用</strong>。我们知道Java中的内存是通过GC自动管理的，GC会在程序运行过程中自动判断哪些对象时可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可以回收的依据是：<strong>是否有有效的引用指向该对象</strong>。如果没有有效引用指向该对象（意味着不存在访问该对象的方式），那么该对象就是可回收的。这里的<strong>有效引用并不包括弱引用</strong>。也就是说，虽然<strong>弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收</strong>。</p>

<p>WeakHashMap内部使用弱引用来管理entry，弱引用的特性对应到WeakHashMap上意味着什么呢？将一对key,value放入到WeakHashMap里并不能避免该key值被GC回收，除非在WeakHashMap之外还有对该key的强引用。</p>

<h2 id="toc_0">具体实现</h2>

<p>WeakHashMap的储存结构类似于HashMap，可参考前文。</p>

<h3 id="toc_1">WeakHashSet？</h3>

<p>如果你看过前几篇关于Map和Set的讲解，一定会问：既然有 WeekHashMap，是否有WeekHashSet呢？答案是没有！不过Java Collections工具类给出了解决方案，<code>Collections.newSetFromMap(Map&lt;E,Boolean&gt; map)</code>方法可以将任何Map包装成一个Set。通过如下方式可以快速得到一个 Weak HashSet：<br/>
<code>java<br/>
// 将WeakHashMap包装成一个Set<br/>
Set&lt;Object&gt; weakHashSet = Collections.newSetFromMap(<br/>
        new WeakHashMap&lt;Object, Boolean&gt;());<br/>
</code><br/>
其内部只是对传入的Map进行了简单的封装：</p>

<pre><code class="language-java">// Collections.newSetFromMap()用于将任何Map包装成一个Set
public static &lt;E&gt; Set&lt;E&gt; newSetFromMap(Map&lt;E, Boolean&gt; map) {
    return new SetFromMap&lt;&gt;(map);
}

private static class SetFromMap&lt;E&gt; extends AbstractSet&lt;E&gt;
    implements Set&lt;E&gt;, Serializable
{
    private final Map&lt;E, Boolean&gt; m;  // The backing map
    private transient Set&lt;E&gt; s;       // Its keySet
    SetFromMap(Map&lt;E, Boolean&gt; map) {
        if (!map.isEmpty())
            throw new IllegalArgumentException(&quot;Map is non-empty&quot;);
        m = map;
        s = map.keySet();
    }
    public void clear()               {        m.clear(); }
    public int size()                 { return m.size(); }
    public boolean isEmpty()          { return m.isEmpty(); }
    public boolean contains(Object o) { return m.containsKey(o); }
    public boolean remove(Object o)   { return m.remove(o) != null; }
    public boolean add(E e) { return m.put(e, Boolean.TRUE) == null; }
    public Iterator&lt;E&gt; iterator()     { return s.iterator(); }
    public Object[] toArray()         { return s.toArray(); }
    public &lt;T&gt; T[] toArray(T[] a)     { return s.toArray(a); }
    public String toString()          { return s.toString(); }
    public int hashCode()             { return s.hashCode(); }
    public boolean equals(Object o)   { return o == this || s.equals(o); }
    public boolean containsAll(Collection&lt;?&gt; c) {return s.containsAll(c);}
    public boolean removeAll(Collection&lt;?&gt; c)   {return s.removeAll(c);}
    public boolean retainAll(Collection&lt;?&gt; c)   {return s.retainAll(c);}
    // addAll is the only inherited implementation
    ......
}
</code></pre>

<h2 id="toc_2">声明</h2>

<p>本系列博文装载自：<a href="https://github.com/CarpenterLee/JCFInternals">https://github.com/CarpenterLee/JCFInternals</a><br/>
作者：CarpenterLee</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java容器框架分析(八)——PriorityQueue]]></title>
    <link href="http://swuzjb.github.io/14879958366746.html"/>
    <updated>2017-02-25T12:10:36+08:00</updated>
    <id>http://swuzjb.github.io/14879958366746.html</id>
    <content type="html"><![CDATA[
<p>前面以ArrayDeque讲解了Stack和Queue，其实还有一种特殊的队列叫做PriorityQueue，即优先队列。优先队列的作用是能保证每次取出的元素都是队列中权值最小的（Java的优先队列是每次取出最小的元素，C++的优先队列是每次取最大元素）。这里涉及到大小关系，元素的大小评判可以通过元素本身的自然顺序，或者通过自定义的比较器来进行定义。</p>

<p>Java中的PriorityQueue实现了Queue接口，不允许放入null元素；其底层通过堆实现，具体说是通过完全二叉树实现的小根堆（任意一个非叶子节点的权值，都不大于左右子节点的权值），也就意味着可以通过数组来作为PriorityQueue的底层实现。</p>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-25-14879965840202.png" alt=""/></p>

<p>上图中我们给每个元素按照宽度优先遍历的方式进行了编号，如果你足够细心会发现，父子节点的编号是有规律的：</p>

<ul>
<li><code>leftNo = parentNo*2+1</code></li>
<li><code>rightNo = parentNo*2+2</code></li>
<li><code>parentNo = (nodeNo - 1 ) / 2</code></li>
</ul>

<p>通过上述三个公式，可以轻易的推算某个节点的父子节点位置。这也就是为什么可以用数组来储存堆的原因。</p>

<p>PriorityQueue的<code>peek()</code>和<code>element()</code>操作是常数时间。<code>add()</code>、<code>offer()</code>、无参数的<code>remove()</code>、以及<code>poll()</code>方法的时间复杂度都是log(n)。</p>

<h2 id="toc_0">常用方法剖析</h2>

<h3 id="toc_1">add()&amp;offer()</h3>

<p>add(E e)和offer(E e)的语义相同，都是向优先队列中插入元素，只是Queue接口规定二者对插入时失败的处理不同，前者在插入失败时抛出异常，后者则返回false。对于PriorityQueue这个方法在实现上并没有什么区别。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-25-14880003809279.png" alt=""/></p>

<p>新插入的元素可能会破坏小根堆的性质，所以必须进行调整。</p>

<pre><code class="language-java">public boolean offer(E e) {
    if (e == null)//不允许放入null元素
        throw new NullPointerException();
    modCount++;
    int i = size;
    if (i &gt;= queue.length)
        grow(i + 1);//自动扩容
    size = i + 1;
    if (i == 0)//队列原来为空，这是插入的第一个元素
        queue[0] = e;
    else
        siftUp(i, e);//调整
    return true;
}
</code></pre>

<p>上述代码中，扩容函数grow()类似于ArrayList中的grow()函数，就是再申请一个更大的数组，并将原数组复制过去，这里不再赘述。需要注意的调整函数。siftUp(int k,E e)，该方法用于插入元素x并维持堆的特性。</p>

<pre><code class="language-java">private void siftUp(int k, E x) {
    while (k &gt; 0) {
        int parent = (k - 1) &gt;&gt;&gt; 1;//parentNo = (nodeNo-1)/2
        Object e = queue[parent];
        if (comparator.compare(x, (E) e) &gt;= 0)//调用比较器的比较方法
            break;
        queue[k] = e;
        k = parent;
    }
    queue[k] = x;
}
</code></pre>

<p>新加入的元素x可能会破坏小根堆的性质，因此需要进行调整，调整的过程为：<strong>从指定位置k开始将x逐层与当前点的parent进行比较并交换知道满足<code>x&gt;=queue[parent]</code>为止</strong>，这里比较的可以是自然顺序，也可以是自定义的比较器顺序。</p>

<h3 id="toc_2">element()&amp;peek()</h3>

<p>element()和peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，两者唯一区别是方法失败时前者抛出异常后者返回null。根据小根堆的性质，堆顶的那个元素就是全局最小的；由于堆用数组进行存储，根据下标关系，0下标处的那个元素就是堆顶元素，所以直接返回数组0下标的那个元素即可。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-25-14880023896388.png" alt=""/></p>

<pre><code class="language-java">//peek()
public E peek() {
    if (size == 0)
        return null;
    return (E) queue[0];//0下标处的那个元素就是最小的那个
}
</code></pre>

<h3 id="toc_3">remove()&amp;poll()</h3>

<p>remove()和poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回null。由于删除操作会改变堆的结构，为维护小根堆的性质，需要进行必要的调整。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-25-14880029594504.png" alt=""/><br/>
代码如下：</p>

<pre><code class="language-java">public E poll() {
    if (size == 0)
        return null;
    int s = --size;
    modCount++;
    E result = (E) queue[0];//0下标处的那个元素就是最小的那个
    E x = (E) queue[s];
    queue[s] = null;
    if (s != 0)
        siftDown(0, x);//调整
    return result;
}
</code></pre>

<p>上述代码首先记录0下标处的元素，并用最后一个元素替换0下标位置的元素，之后调用<code>siftDown()</code>方法对堆进行调整，最后返回原来0下标位置那个元素（也就是原先的堆顶元素）。重点是<code>siftDown(int k,E e)</code>方法，该方法的作用是<strong>从k指定的位置开始，将x逐层向下与当前点的左右孩子中较小的那个交换，直到x小于等于左右孩子中的任意一个位置</strong>。</p>

<pre><code class="language-java">//siftDown()
private void siftDown(int k, E x) {
    int half = size &gt;&gt;&gt; 1;
    while (k &lt; half) {
        //首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标
        int child = (k &lt;&lt; 1) + 1;//leftNo = parentNo*2+1
        Object c = queue[child];
        int right = child + 1;
        if (right &lt; size &amp;&amp;
            comparator.compare((E) c, (E) queue[right]) &gt; 0)
            c = queue[child = right];
        if (comparator.compare(x, (E) c) &lt;= 0)
            break;
        queue[k] = c;//然后用c取代原来的值
        k = child;
    }
    queue[k] = x;
}
</code></pre>

<h3 id="toc_4">remove(Object o)</h3>

<p>remove(Object o)方法用于删除队列中跟o相等的某一个元素（如果多个相等，只删除一个），该方法不是Queue接口内的方法，而是Collection接口的方法。由于删除操作会改变队列的结构，所以需要进行调整；又由于删除位置是任意的，所以调整过程比其它函数复杂一些。具体来说，remove(Object o)可以分为2种情况：1.删除的是最后一个元素则直接删除即可，不需要调整；2.删除的不是最后一个元素，从删除点开始以最后一个元素为参照点调用一次siftDown()即可。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-25-14880047702540.png" alt=""/></p>

<pre><code class="language-java">//remove(Object o)
public boolean remove(Object o) {
    //通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标
    int i = indexOf(o);
    if (i == -1)
        return false;
    int s = --size;
    if (s == i) //情况1
        queue[i] = null;
    else {
        E moved = (E) queue[s];
        queue[s] = null;
        siftDown(i, moved);//情况2
        ......
    }
    return true;
}
</code></pre>

<h2 id="toc_5">声明</h2>

<p>本系列博文装载自：<a href="https://github.com/CarpenterLee/JCFInternals">https://github.com/CarpenterLee/JCFInternals</a><br/>
作者：CarpenterLee</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java容器框架分析(七)——LinkedHashSet与LinkedHashMap]]></title>
    <link href="http://swuzjb.github.io/14879892493054.html"/>
    <updated>2017-02-25T10:20:49+08:00</updated>
    <id>http://swuzjb.github.io/14879892493054.html</id>
    <content type="html"><![CDATA[
<p>如果你已经看过前面关于HashSet和HashMap，以及TreeSet和TreeMap的讲解，一定能够想到本文要讲解的LinkedSet和LinkedHashMap在Java中也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说<strong>LinkedHashSet里面有一个LinkedHashMap(适配器模式)</strong>。因此本文将重点介绍LinkedHashMap。</p>

<p>LinkedHashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素。从名字上可以看出该容器是LinkedList和HashMap的混合体，也就是说它同时满足HashMap和LinkedList的某些特性。可以将LinkedHashMap看作采用LinkedList增强的HashMap。</p>

<p>事实上LinkedHashMap是HashMap的直接子类，二者的唯一区别是LinkedHashMap在HashMap的基础上，采用双向链表的形式将所有entry连接起来，这样是为保证元素的迭代顺序和插入顺序相同。</p>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-25-14879901525374.png" alt=""/></p>

<p>上图给出了LinkedHashMap的结构图，主体部分跟HashMap完全一样，多了header指向双向链表的头部，该双向链表的迭代顺序就是entry的插入顺序。<br/>
除了可以保证迭代顺序，这种结构还有一个好处：迭代LinkedHashMap时不需要像HashMap那样遍历整个table，而是只需要直接遍历header指向的双向链表即可。也就说LinkedHashMap的迭代时间就只跟entry的个数有关，和table的大小无关。</p>

<p>有两个参数可以影响 LinkedHashMap 的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。<br/>
将对象放入到 LinkedHashMap 或 LinkedHashSet 中时，有两个方法需要特别关心：<code>hashCode()</code>和<code>equals()</code>。<code>hashCode()</code>方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是 “同一个对象”。所以，如果要将自定义的对象放入到LinkedHashMap或LinkedHashSet中，需要覆盖<code>hashCode()</code>和<code>equals()</code>方法。</p>

<p>通过如下方式可以得到一个跟源Map迭代顺序一样的LinkedHashMap：</p>

<pre><code class="language-java">void foo(Map m) {
    Map copy = new LinkedHashMap(m);
    ...
}
</code></pre>

<p>出于性能原因，LinkedHashMap是非线程安全的，如果需要在多线程环境使用，需要程序呀手动进行同步；或者通过如下方式将LinkedHashMap包装成同步的：</p>

<pre><code class="language-java">Map m = Collections.synchronizedMap(new LinkedHashMap(...));
</code></pre>

<h2 id="toc_0">常用方法剖析</h2>

<h3 id="toc_1">get()</h3>

<p>get(Object key)方法根据指定的key值返回对应的value.该方法的流程和HashMap的实现方式基本一样，可参考前文。</p>

<h3 id="toc_2">put()</h3>

<p><code>put(K key,V value)</code>方法是将指定的<code>key,value</code>对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>get()</code>方法；如没有找到则会通过<code>addEntry(int hash,K key,V value,int bucketIndex)</code>方法插入新的entry。<br/>
PS.这里的插入有两重含义：</p>

<ol>
<li>从table的角度来看，新的entry需要插入到对应的bucket里，当有哈希冲突时，采用头插法将新的entry插入到冲突链表的头部。</li>
<li>从header的角度，新的entry需要插入到双向链表的尾部。</li>
</ol>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-25-14879912929279.png" alt=""/></p>

<p>addEntry()代码如下：</p>

<pre><code class="language-java">void addEntry(int hash, K key, V value, int bucketIndex) {
    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
        resize(2 * table.length);// 自动扩容，并重新哈希
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = hash &amp; (table.length-1);// hash%table.length
    }
    // 1.在冲突链表头部插入新的entry
    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];
    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(hash, key, value, old);
    table[bucketIndex] = e;
    // 2.在双向链表的尾部插入新的entry
    e.addBefore(header);
    size++;
}
</code></pre>

<p>上述代码中用到了<code>addBefore()</code>方法将新<code>entry e</code>插入到双向链表引用<code>header</code>的前面，这样e就成为了双向链表中的最后一个元素。<code>addBefore()</code>的代码如下：</p>

<pre><code class="language-java">// LinkedHashMap.Entry.addBefor()，将this插入到existingEntry的前面
private void addBefore(Entry&lt;K,V&gt; existingEntry) {
    after  = existingEntry;
    before = existingEntry.before;
    before.after = this;
    after.before = this;
}
</code></pre>

<p>仅需要简单修改相关entry的引用而已。</p>

<h3 id="toc_3">remove()</h3>

<p><code>remove(Object key)</code>的作用是删除key值对应的entry，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到key值对应的entry，然后删除entry(修改链表的引用)。查找过程和get()方法类似。<br/>
注意，这里的删除也有两层含义：</p>

<ol>
<li>从table的角度看，需要将该entry从对应的bucket里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。</li>
<li>从header的角度来看，需要将该entry从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。</li>
</ol>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-25-14879925343738.png" alt=""/></p>

<p><code>removeEntryForKey()</code>对应的代码如下：</p>

<pre><code class="language-java">// LinkedHashMap.removeEntryForKey()，删除key值对应的entry
final Entry&lt;K,V&gt; removeEntryForKey(Object key) {
    ......
    int hash = (key == null) ? 0 : hash(key);
    int i = indexFor(hash, table.length);// hash&amp;(table.length-1)
    Entry&lt;K,V&gt; prev = table[i];// 得到冲突链表
    Entry&lt;K,V&gt; e = prev;
    while (e != null) {// 遍历冲突链表
        Entry&lt;K,V&gt; next = e.next;
        Object k;
        if (e.hash == hash &amp;&amp;
            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {// 找到要删除的entry
            modCount++; size--;
            // 1. 将e从对应bucket的冲突链表中删除
            if (prev == e) table[i] = next;
            else prev.next = next;
            // 2. 将e从双向链表中删除
            e.before.after = e.after;
            e.after.before = e.before;
            return e;
        }
        prev = e; e = next;
    }
    return e;
}
</code></pre>

<h2 id="toc_4">LinkedHashSet</h2>

<p>前面已经说过 LinkedHashSet 是对 LinkedHashMap 的简单包装，对 LinkedHashSet 的函数调用都会转换成合适的 LinkedHashMap 方法，因此 LinkedHashSet 的实现非常简单，这里不再赘述。</p>

<pre><code class="language-java">public class LinkedHashSet&lt;E&gt;
    extends HashSet&lt;E&gt;
    implements Set&lt;E&gt;, Cloneable, java.io.Serializable {
    ......
    // LinkedHashSet里面有一个LinkedHashMap
    public LinkedHashSet(int initialCapacity, float loadFactor) {
        map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);
    }
    ......
    public boolean add(E e) {//简单的方法转换
        return map.put(e, PRESENT)==null;
    }
    ......
}
</code></pre>

<h2 id="toc_5">声明</h2>

<p>本系列博文装载自：<a href="https://github.com/CarpenterLee/JCFInternals">https://github.com/CarpenterLee/JCFInternals</a><br/>
作者：CarpenterLee</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java容器框架分析(六)——HashSet与HashMap]]></title>
    <link href="http://swuzjb.github.io/14879172287548.html"/>
    <updated>2017-02-24T14:20:28+08:00</updated>
    <id>http://swuzjb.github.io/14879172287548.html</id>
    <content type="html"><![CDATA[
<p>之所以把HashSet和HashMap放在一起，是因为二者在Java中有着相同的实现，前者仅仅是对后者进行了一次封装，也就是说HashSet中有一个HashMap(适配器模式)。因此本文将重点分析HashMap。</p>

<p>HashMap实现了Map接口，允许放入key为null的元素，也允许插入value为null的元素。除没有实现同步外，其余跟HashTable大致相同；跟TreeMap不同，该容器不保证元素顺序，根据需要，该容器可能会对元素重新哈希，元素的顺序也会被重新打散。因此在不同时间迭代同一个HashMap的顺序可能会不同。</p>

<p>根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式，另外一种是冲突链表方式。Java HashMap采用的是冲突链表方式。</p>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14879180909568.png" alt=""/></p>

<p>从上图可以看出，如果选择合适的哈希函数，put()和get()方法可以在常数时间内完成。但是在对HashMap进行迭代时，需要遍历整个table及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将HashMap的初始大小设置的过大。</p>

<p>有两个参数可以影响HashMap的性能：初始容量（inital capacity）和负载系数（loadFactor）。初始容量指定了初始table的大小，负载系数表示用来自动扩容的临界值。<br/>
当entry的数量超过<code>capacity*loadFactor</code>时，容器将自动扩容并重新哈希，对于插入元素较多的场景，将初始容量设大可以减小重新哈希的次数。</p>

<p>将对象放入到HashMap或者HashSet中时，有两个方法需要特别注意：<code>hashCode()</code>和<code>equals()</code>。<code>hashCode()</code>决定了对象会被放在哪个bucket里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是同一个对象。所以，如果要将自定义的对象放入到HashMap或者HashSet中，需要覆盖<code>hashCode()</code>和<code>equals()</code>方法。</p>

<h2 id="toc_0">常用方法剖析</h2>

<h3 id="toc_1">get()</h3>

<p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.getValue()</code>。因此<code>getEntry()</code>是算法的核心。<br/>
算法思想是首先通过<code>hash()</code>函数得到对应的bucket下标，然后依次遍历冲突链表，通过<code>key.equals(k)</code>方法来判断是否是要找的那个<code>entry</code>。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14879194728200.png" alt=""/><br/>
上图中 <code>hash(k)&amp;(table.length-1)</code>等价于<code>hash(k)%table.length</code>，原因是table.length必须是2的指数，因此table.length-1就是二进制低位全是1，跟hash(k)相与会将hash值得高位全抹掉，剩下的就是余数了。</p>

<pre><code class="language-java">final Entry&lt;K,V&gt; getEntry(Object key) {
    ......
    int hash = (key == null) ? 0 : hash(key);
    for (Entry&lt;K,V&gt; e = table[hash&amp;(table.length-1)];//得到冲突链表
         e != null; e = e.next) {//依次遍历冲突链表中的每个entry
        Object k;
        //依据equals()方法判断是否相等
        if (e.hash == hash &amp;&amp;
            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
            return e;
    }
    return null;
}
</code></pre>

<h3 id="toc_2">put()</h3>

<p>put(K key,V value)方法是将指定的key,value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含该元组，则直接返回，查找过程类似于getEntry()方法；如果没有找到，则会通过addEntry(int hash,K key,V value,int bucketIndex)方法插入新的entry，插入方式为头插法。</p>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14879200695663.png" alt=""/></p>

<pre><code class="language-java">void addEntry(int hash, K key, V value, int bucketIndex) {
    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
        resize(2 * table.length);//自动扩容，并重新哈希
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = hash &amp; (table.length-1);//hash%table.length
    }
    //在冲突链表头部插入新的entry
    Entry&lt;K,V&gt; e = table[bucketIndex];
    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
    size++;
}
</code></pre>

<h3 id="toc_3">remove()</h3>

<p><code>remove(Object key)</code>的作用是删除对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里面实现的。<code>removeEntryForKey(Object key)</code>方法会首先找到key值对应的entry，然后删除entry（修改链表的引用）。查找过程类似于getEntry()。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14879203192877.png" alt=""/></p>

<pre><code class="language-java">//removeEntryForKey()
final Entry&lt;K,V&gt; removeEntryForKey(Object key) {
    ......
    int hash = (key == null) ? 0 : hash(key);
    int i = indexFor(hash, table.length);//hash&amp;(table.length-1)
    Entry&lt;K,V&gt; prev = table[i];//得到冲突链表
    Entry&lt;K,V&gt; e = prev;
    while (e != null) {//遍历冲突链表
        Entry&lt;K,V&gt; next = e.next;
        Object k;
        if (e.hash == hash &amp;&amp;
            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {//找到要删除的entry
            modCount++; size--;
            if (prev == e) table[i] = next;//删除的是冲突链表的第一个entry
            else prev.next = next;
            return e;
        }
        prev = e; e = next;
    }
    return e;
}
</code></pre>

<h2 id="toc_4">HashSet</h2>

<p>前面已经说过 HashSet 是对 HashMap 的简单包装，对 HashSet 的函数调用都会转换成合适的 HashMap 方法，因此 HashSet 的实现非常简单，只有不到 300 行代码。这里不再赘述。</p>

<pre><code class="language-java">public class HashSet&lt;E&gt;
{
    ......
    private transient HashMap&lt;E,Object&gt; map;//HashSet里面有一个HashMap
    // Dummy value to associate with an Object in the backing Map
    private static final Object PRESENT = new Object();
    public HashSet() {
        map = new HashMap&lt;&gt;();
    }
    ......
    public boolean add(E e) {//简单的方法转换
        return map.put(e, PRESENT)==null;
    }
    ......
}
</code></pre>

<h2 id="toc_5">声明</h2>

<p>本系列博文装载自：<a href="https://github.com/CarpenterLee/JCFInternals">https://github.com/CarpenterLee/JCFInternals</a><br/>
作者：CarpenterLee</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java容器框架分析(五)——TreeSet与TreeMap]]></title>
    <link href="http://swuzjb.github.io/14879027517066.html"/>
    <updated>2017-02-24T10:19:11+08:00</updated>
    <id>http://swuzjb.github.io/14879027517066.html</id>
    <content type="html"><![CDATA[
<p>之所以把TreeSet和TreeMap放到一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说TreeSet里面有一个TreeMap（适配器模式）。因此本文将重点分析TreeMap。</p>

<h2 id="toc_0">TreeMap简介</h2>

<p>Java TreeMap实现了SortedMap接口，也就是说会按照key的大小顺序对Map中的元素进行排序，key的大小评判可以通过其本身的自然顺序，也可以通过构造时传入的比较器。</p>

<p>TreeMap的底层通过红黑树实现，也就意味着<code>containsKey()</code>,<code>get()</code>,<code>put()</code>,<code>remove()</code>都有着<em>O(log n)</em>的时间复杂度。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14879037942508.png" alt=""/></p>

<p>出于性能原因，TreeMap是非同步的，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将TreeMap包装成同步的：</p>

<pre><code class="language-java">SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));
</code></pre>

<h2 id="toc_1">红黑树</h2>

<p><strong>红黑树是一种近似平衡的二叉查找树，他能保证任何一个节点的左右子树的高度差不会超过二者中较低的那个的一倍</strong>。具体来说，红黑树是满足如下条件的<strong>二叉查找树</strong>：</p>

<ol>
<li>每个节点要么是红色要么是黑色。</li>
<li>根节点必须是黑色。</li>
<li>红色节点不能连续（即红色节点的孩子和父亲都不能是红色）。</li>
<li>对每个节点，从该点到null（树尾端）的任何路径，都含有相同个数的黑色节点。
在树的结构发生改变时（插入或者删除操作），往往会破坏上述的条件3或者条件4，需要通过调整使查找树的结构重新满足红黑树的约束条件。</li>
</ol>

<h3 id="toc_2">预备知识</h3>

<p>前文说到当查找树的结构发生改变时，红黑树的约束条件可能被破坏，需要通过调整使得查找树重新满足红黑树的约束条件。调整可以分为两类：颜色调整（即改变某个节点的颜色）和结构调整（即改变查找树的结构关系）。结构调整包含两个基本的操作：左旋和右旋。</p>

<h4 id="toc_3">左旋</h4>

<p>左旋的过程是将x的右子树绕x逆时针旋转，使得x的右子树成为x的父亲，同时修改相关节点的引用，旋转之后，二叉查找树的属性仍然满足。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14879047657614.png" alt=""/></p>

<p>TreeMap中的左旋操作代码：<br/>
<code>java<br/>
private void rotateLeft(Entry&lt;K,V&gt; p) {<br/>
    if (p != null) {<br/>
        Entry&lt;K,V&gt; r = p.right;<br/>
        p.right = r.left;<br/>
        if (r.left != null)<br/>
            r.left.parent = p;<br/>
        r.parent = p.parent;<br/>
        if (p.parent == null)<br/>
            root = r;<br/>
        else if (p.parent.left == p)<br/>
            p.parent.left = r;<br/>
        else<br/>
            p.parent.right = r;<br/>
        r.left = p;<br/>
        p.parent = r;<br/>
    }<br/>
}<br/>
</code></p>

<h3 id="toc_4">右旋</h3>

<p>右旋的过程是将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性依旧满足。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14879049484921.png" alt=""/></p>

<p>TreeMap中的右旋代码：</p>

<pre><code class="language-java">private void rotateRight(Entry&lt;K,V&gt; p) {
    if (p != null) {
        Entry&lt;K,V&gt; l = p.left;
        p.left = l.right;
        if (l.right != null) l.right.parent = p;
        l.parent = p.parent;
        if (p.parent == null)
            root = l;
        else if (p.parent.right == p)
            p.parent.right = l;
        else p.parent.left = l;
        l.right = p;
        p.parent = l;
    }
}
</code></pre>

<h3 id="toc_5">寻找节点后继</h3>

<p>对于一课二叉查找树，给定节点t，其后继（数中大于t的最小的那个元素）可以通过如下方式找到：</p>

<ol>
<li>t的右子树不空，则t的后继是其右子树中最小的那个元素</li>
<li>t的右子树为空，则t的后继是其第一个向左走的祖先</li>
</ol>

<p>TreeMap中寻找节点后继的代码如下：</p>

<pre><code class="language-java">static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) {
    if (t == null)
        return null;
    else if (t.right != null) {
            // 1. t的右子树不空，则t的后继是其右子树中最小的那个元素
        Entry&lt;K,V&gt; p = t.right;
        while (p.left != null)
            p = p.left;
        return p;
    } else {
            // 2. t的右孩子为空，则t的后继是其第一个向左走的祖先
        Entry&lt;K,V&gt; p = t.parent;
        Entry&lt;K,V&gt; ch = t;
        while (p != null &amp;&amp; ch == p.right) {
            ch = p;
            p = p.parent;
        }
        return p;
    }
}
</code></pre>

<h2 id="toc_6">常用方法剖析</h2>

<h3 id="toc_7">get()</h3>

<p><code>get(Object key)</code>方法根据指定的key值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.value</code>。因此<code>getEntry()</code>是算法的核心。算法思想是依据<code>key</code>的顺序（自然顺序或自定义比较器顺序）对二叉树进行查找，直到找到满足<code>k.compareTo(p.key) == 0</code> 的<code>entry</code>。 <br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14879118892511.png" alt=""/></p>

<pre><code class="language-java">final Entry&lt;K,V&gt; getEntry(Object key) {
    ......
    if (key == null)//不允许key值为null
        throw new NullPointerException();
    Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序
    Entry&lt;K,V&gt; p = root;
    while (p != null) {
        int cmp = k.compareTo(p.key);
        if (cmp &lt; 0)//向左找
            p = p.left;
        else if (cmp &gt; 0)//向右找
            p = p.right;
        else
            return p;
    }
    return null;
}
</code></pre>

<h3 id="toc_8">put()</h3>

<p><code>put(K key,V value)</code>方法是将指定的<code>key，value</code>对添加到map里。该方法首先会对map进行一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到则会在红黑树中插入新的<code>entry</code>，如果插入之后破坏了红黑树的约束条件，则会进行相关的调整（旋转或改变颜色）。</p>

<pre><code class="language-java">public V put(K key, V value) {
    ......
    int cmp;
    Entry&lt;K,V&gt; parent;
    if (key == null)
        throw new NullPointerException();
    Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序
    do {
        parent = t;
        cmp = k.compareTo(t.key);
        if (cmp &lt; 0) t = t.left;//向左找
        else if (cmp &gt; 0) t = t.right;//向右找
        else return t.setValue(value);
    } while (t != null);
    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);//创建并插入新的entry
    if (cmp &lt; 0) parent.left = e;
    else parent.right = e;
    fixAfterInsertion(e);//调整
    size++;
    return null;
}
</code></pre>

<p>上述代码的插入部分并不难理解:首先在红黑树上找到合适的位置，然后创建新的<code>entry</code>并插入（当然，新插入的节点一定是树的叶子节点）。难点是调整函数<code>fixAfterInsertion()</code>，前面已经说过，调整往往需要：1.改变某些节点的颜色;2.对某些节点进行旋转。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14879127618711.png" alt=""/></p>

<pre><code class="language-java">//红黑树调整函数fixAfterInsertion()
private void fixAfterInsertion(Entry&lt;K,V&gt; x) {
    x.color = RED;
    while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) {
        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));
            if (colorOf(y) == RED) {
                setColor(parentOf(x), BLACK);              // 情况1
                setColor(y, BLACK);                        // 情况1
                setColor(parentOf(parentOf(x)), RED);      // 情况1
                x = parentOf(parentOf(x));                 // 情况1
            } else {
                if (x == rightOf(parentOf(x))) {
                    x = parentOf(x);                       // 情况2
                    rotateLeft(x);                         // 情况2
                }
                setColor(parentOf(x), BLACK);              // 情况3
                setColor(parentOf(parentOf(x)), RED);      // 情况3
                rotateRight(parentOf(parentOf(x)));        // 情况3
            }
        } else {
            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));
            if (colorOf(y) == RED) {
                setColor(parentOf(x), BLACK);              // 情况4
                setColor(y, BLACK);                        // 情况4
                setColor(parentOf(parentOf(x)), RED);      // 情况4
                x = parentOf(parentOf(x));                 // 情况4
            } else {
                if (x == leftOf(parentOf(x))) {
                    x = parentOf(x);                       // 情况5
                    rotateRight(x);                        // 情况5
                }
                setColor(parentOf(x), BLACK);              // 情况6
                setColor(parentOf(parentOf(x)), RED);      // 情况6
                rotateLeft(parentOf(parentOf(x)));         // 情况6
            }
        }
    }
    root.color = BLACK;
}
</code></pre>

<h3 id="toc_9">remove()</h3>

<p><code>remove(Object key)</code>的作用是删除key值对应的entry，该方法首先通过上文提到的<code>getEntry(Object key)</code>方法找到key值对应的entry，然后调用<code>deleteEntry(Entry&lt;K,V&gt; entry)</code>删除对应的entry，由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束条件，因此有可能要进行调整。<br/>
<code>getEntry()</code>函数前面已经讲解过，这里重点放在deleteEntry()上，该函数删除指定的entry并在红黑树的约束被破坏时调用<code>fixAfterDeletion(Entry&lt;K,V&gt; x)</code>进行调整。</p>

<p>由于红黑树是一颗增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整。现在考虑一颗普通二叉查找树的删除过程，可以分为两种情况：</p>

<ol>
<li>删除点p的左右子树都为空，或者只有一颗子树非空；</li>
<li>删除点p的左右子树都非空。</li>
</ol>

<p>对于上述情况1，处理起来比较简单，直接将p删除（左右子树均为空），或者用非空子树替代p（只有一颗子树为非空）；对于情况2，可以用p的后继s（数中大于x的最小的那个元素）代替p，然后使用情况1删除s。<br/>
基于以上的逻辑，红黑树的删除节点函数<code>deleteEntry()</code>代码如下： </p>

<pre><code class="language-java">private void deleteEntry(Entry&lt;K,V&gt; p) {
    modCount++;
    size--;
    if (p.left != null &amp;&amp; p.right != null) {// 2. 删除点p的左右子树都非空。
        Entry&lt;K,V&gt; s = successor(p);// 后继
        p.key = s.key;
        p.value = s.value;
        p = s;
    }
    Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right);
    if (replacement != null) {// 1. 删除点p只有一棵子树非空。
        replacement.parent = p.parent;
        if (p.parent == null)
            root = replacement;
        else if (p == p.parent.left)
            p.parent.left  = replacement;
        else
            p.parent.right = replacement;
        p.left = p.right = p.parent = null;
        if (p.color == BLACK)
            fixAfterDeletion(replacement);// 调整
    } else if (p.parent == null) {
        root = null;
    } else { // 1. 删除点p的左右子树都为空
        if (p.color == BLACK)
            fixAfterDeletion(p);// 调整
        if (p.parent != null) {
            if (p == p.parent.left)
                p.parent.left = null;
            else if (p == p.parent.right)
                p.parent.right = null;
            p.parent = null;
        }
    }
}
</code></pre>

<p>上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数<code>fixAfterDeletion()</code>。首先请思考一下，删除了那些点才会调整？只有删除点是黑色时，才会触发调整函数，因为红色节点不会破坏红黑树的任何约束，而删除黑色点会破坏规则4。<br/>
跟上文中讲过的<code>fixAfterInsertion()</code>函数一样，这里也要分成若干种情况。无论有多少情况，具体的调整操作只有两种：1.改变某些节点的颜色；2.对某些节点进行旋转。</p>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14879160078690.png" alt=""/></p>

<p>上述图解的总体思想是：将情况 1 首先转换成情况 2，或者转换成情况 3 和情况 4。当然，该图解并不意味着调整过程一定是从情况 1 开始。通过后续代码我们还会发现几个有趣的规则：a). 如果是由情况 1 之后紧接着进入的情况 2，那么情况 2 之后一定会退出循环（因为 x 为红色）；b). 一旦进入情况 3 和情况 4，一定会退出循环（因为 x 为 root）。</p>

<p>删除后调整函数fixAfterDeletion()的具体代码如下，其中用到了上文中提到的rotateLeft()和rotateRight()函数。通过代码我们能够看到，情况 3 其实是落在情况 4 内的。情况 5～情况 8 跟前四种情况是对称的，因此图解中并没有画出后四种情况，读者可以参考代码自行理解。</p>

<pre><code class="language-java">private void fixAfterDeletion(Entry&lt;K,V&gt; x) {
    while (x != root &amp;&amp; colorOf(x) == BLACK) {
        if (x == leftOf(parentOf(x))) {
            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));
            if (colorOf(sib) == RED) {
                setColor(sib, BLACK);                   // 情况1
                setColor(parentOf(x), RED);             // 情况1
                rotateLeft(parentOf(x));                // 情况1
                sib = rightOf(parentOf(x));             // 情况1
            }
            if (colorOf(leftOf(sib))  == BLACK &amp;&amp;
                colorOf(rightOf(sib)) == BLACK) {
                setColor(sib, RED);                     // 情况2
                x = parentOf(x);                        // 情况2
            } else {
                if (colorOf(rightOf(sib)) == BLACK) {
                    setColor(leftOf(sib), BLACK);       // 情况3
                    setColor(sib, RED);                 // 情况3
                    rotateRight(sib);                   // 情况3
                    sib = rightOf(parentOf(x));         // 情况3
                }
                setColor(sib, colorOf(parentOf(x)));    // 情况4
                setColor(parentOf(x), BLACK);           // 情况4
                setColor(rightOf(sib), BLACK);          // 情况4
                rotateLeft(parentOf(x));                // 情况4
                x = root;                               // 情况4
            }
        } else { // 跟前四种情况对称
            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));
            if (colorOf(sib) == RED) {
                setColor(sib, BLACK);                   // 情况5
                setColor(parentOf(x), RED);             // 情况5
                rotateRight(parentOf(x));               // 情况5
                sib = leftOf(parentOf(x));              // 情况5
            }
            if (colorOf(rightOf(sib)) == BLACK &amp;&amp;
                colorOf(leftOf(sib)) == BLACK) {
                setColor(sib, RED);                     // 情况6
                x = parentOf(x);                        // 情况6
            } else {
                if (colorOf(leftOf(sib)) == BLACK) {
                    setColor(rightOf(sib), BLACK);      // 情况7
                    setColor(sib, RED);                 // 情况7
                    rotateLeft(sib);                    // 情况7
                    sib = leftOf(parentOf(x));          // 情况7
                }
                setColor(sib, colorOf(parentOf(x)));    // 情况8
                setColor(parentOf(x), BLACK);           // 情况8
                setColor(leftOf(sib), BLACK);           // 情况8
                rotateRight(parentOf(x));               // 情况8
                x = root;                               // 情况8
            }
        }
    }
    setColor(x, BLACK);
}
</code></pre>

<h2 id="toc_10">TreeSet</h2>

<p>上面已经说过TreeSet实质上就是对TreeMap的简单包装，对TreeSet的函数调用都会转换成合适TreeMap的方法。因此TreeSet的实现十分简单。</p>

<pre><code class="language-java">public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;
    implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable {
    ......
    private transient NavigableMap&lt;E,Object&gt; m;
    // Dummy value to associate with an Object in the backing Map
    private static final Object PRESENT = new Object();
    public TreeSet() {
        this.m = new TreeMap&lt;E,Object&gt;();// TreeSet里面有一个TreeMap
    }
    ......
    public boolean add(E e) {
        return m.put(e, PRESENT)==null;
    }
    ......
}
</code></pre>

<h2 id="toc_11">声明</h2>

<p>本系列博文装载自：<a href="https://github.com/CarpenterLee/JCFInternals">https://github.com/CarpenterLee/JCFInternals</a><br/>
作者：CarpenterLee</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java容器框架分析(四)——ArrayDeque源码分析]]></title>
    <link href="http://swuzjb.github.io/14878305448928.html"/>
    <updated>2017-02-23T14:15:44+08:00</updated>
    <id>http://swuzjb.github.io/14878305448928.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">ArrayDeque简介</h2>

<p>Java中有一个叫做Stack的实现类，却没有Queue的实现类（只有Queue接口）。当需要使用栈时，Java官方已经不推荐使用Stack而是推荐使用更高效的ArrayDeque；既然Queue只是一个接口，当需要使用队列是也就首选ArrayDeque了，其次就是LinkedList啦。</p>

<h2 id="toc_1">Deque接口</h2>

<p>要将栈和队列，首先需要介绍Deque接口，Deque全称Double Ended Queue，即双端队列。它既可以当做栈使用，也可以当做队列使用。<br/>
下标展示Deque和Queue的接口对照表：</p>

<table>
<thead>
<tr>
<th>Queue方法</th>
<th>Deque方法</th>
<th>方法说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>add(e)</td>
<td>addLast(e)</td>
<td>向队尾插入元素，失败则抛出异常</td>
</tr>
<tr>
<td>offer(e)</td>
<td>offerLast(e)</td>
<td>向队尾插入元素，失败则返回false</td>
</tr>
<tr>
<td>remove()</td>
<td>removeFirst()</td>
<td>获取并删除队首元素，失败则抛出异常</td>
</tr>
<tr>
<td>poll()</td>
<td>pollFrist()</td>
<td>获取并删除队首元素，失败则返回null</td>
</tr>
<tr>
<td>element()</td>
<td>getFirst()</td>
<td>获取但不删除队首元素，失败则抛出异常</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
<td>获取但不删除队首元素，失败则返回null</td>
</tr>
</tbody>
</table>

<p>下表列出了Deque和Stack的接口对应关系：</p>

<table>
<thead>
<tr>
<th>Stack方法</th>
<th>Deque方法</th>
<th>方法说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>push(e)</td>
<td>addFirst(e)</td>
<td>向栈顶插入元素，失败则抛出异常</td>
</tr>
<tr>
<td>-</td>
<td>offerFirst(e)</td>
<td>向栈顶插入元素，失败则返回false</td>
</tr>
<tr>
<td>pop()</td>
<td>removeFirst(e)</td>
<td>获取并删除栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td>-</td>
<td>pollFirst()</td>
<td>获取并删除栈顶元素，失败则返回null</td>
</tr>
<tr>
<td>peek()</td>
<td>getFirst()</td>
<td>获取但不删除栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td>-</td>
<td>peekFirst()</td>
<td>获取但不删除栈顶元素，失败则返回null</td>
</tr>
</tbody>
</table>

<p>上面两个表共定义了Deque的12个接口，添加、删除、查询都有2套接口，它们功能相同，区别就在于对于失败情况的处理方式是不同的。<strong>一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值（false或者null）</strong>。除非某种实现对于容量有限制，大多数情况之下，添加操作是不会失败的。虽然上面列举了12个接口，但是无非就是对容器的两端进行添加、删除、查询操作。</p>

<h2 id="toc_2">ArrayDeque简介</h2>

<p>ArrayDeque和LinkedList是Deque的两个通用实现，由于官方更加推荐使用ArrayDeque用作栈和队列，加之上一篇已经对LinkedList进行了讲解，本文着重讲解ArrayDeque的具体实现。<br/>
从名字就可以看出ArrayDeque的底层使用数组实现，为了满足可以在数组的两端插入或删除元素的要求，该数组还必须是循环的，即循环数组，也就是说数组的任何一点都可以被看作为终点或是起点。<br/>
ArrayDeque是线程不安全的，当多个线程同时操作时，需要程序员自己进行同步维护。另外，该容器不允许放入null值。</p>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14878324914756.png" alt=""/></p>

<p>上图中我们看到，<strong><code>head</code>指向首端第一个有效元素，<code>tail</code>指向尾端第一个可以插入元素的空位</strong>。因为是循环数组，所以head不一定总等于 0，tail也不一定总是比head大。</p>

<h2 id="toc_3">常用方法剖析</h2>

<h3 id="toc_4">addFirst()</h3>

<p><code>addFirst(E e)</code>的作用是在Deque的首端插入元素，也就是在<code>head</code>之前插入元素，在空间足够且下标没有越界的情况之下需要将<code>elements[--head] = e</code>即可。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14878327863308.png" alt=""/></p>

<p>实际需要特别考虑的问题：1、空间是否够用；2、下标是否越界的问题。上图之中，如果head的位置为0之后，在调用<code>addFirst()</code>虽然空余空间还有但是head的值为-1，就造成了下标越界。下列代码很好的解决了这个问题：</p>

<pre><code class="language-java">public void addFirst(E e) {
    if (e == null)//不允许放入null
        throw new NullPointerException();
    elements[head = (head - 1) &amp; (elements.length - 1)] = e;//2.下标是否越界
    if (head == tail)//1.空间是否够用
        doubleCapacity();//扩容
}
</code></pre>

<p>上述代码我们看到，<strong>空间问题是在插入之后解决的</strong>。因为tail总是指向下一个可插入的空位，也就意味着<code>elements</code>数组至少有一个空位，所以插入元素的时候不需要考虑空间问题。<br/>
下标越界的处理起来非常简单，<code>head=(head-1)&amp;(elements.length - 1)</code>就可以了，<strong>这段代码相当于取余，同时解决了head为负值的情况</strong>。因为elements.length必须是2的指数倍，elements.length - 1就是二进制低位全1，跟head-1 进行 与（&amp;）运算之后就起到了取模的作用，如果head-1为负数（只可能为-1）,则相当于对其取相对于elements.length的补码。</p>

<p>下面再说扩容函数<code>doubleCapacity()</code>，其逻辑是申请一个长度为原数组两倍的新数组，然后将原数组复制过去。复制分两次进行，第一次复制head右边的元素，第二次复制head左边的元素。如图所示：<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14878340364545.png" alt=""/></p>

<pre><code class="language-java">private void doubleCapacity() {
    assert head == tail;
    int p = head;
    int n = elements.length;
    int r = n - p; // head右边元素的个数
    int newCapacity = n &lt;&lt; 1;//原空间的2倍
    if (newCapacity &lt; 0)
        throw new IllegalStateException(&quot;Sorry, deque too big&quot;);
    Object[] a = new Object[newCapacity];
    System.arraycopy(elements, p, a, 0, r);//复制右半部分，对应上图中绿色部分
    System.arraycopy(elements, 0, a, r, p);//复制左半部分，对应上图中灰色部分
    elements = (E[])a;
    head = 0;
    tail = n;
}
</code></pre>

<h3 id="toc_5">addLast()</h3>

<p><code>addLast(E e)</code>的作用是在Deque的尾端插入元素，也就是在<code>tail</code>的位置插入元素，由于tail总是指向下一个可以插入的空位，因此只需要<code>element[tail] = e</code>即可。插入完成之后再检查空间，如果空间已经用光，则调用<code>doubleCapacity()</code>进行扩容。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14878375459017.png" alt=""/></p>

<pre><code class="language-java">public void addLast(E e) {
    if (e == null)//不允许放入null
        throw new NullPointerException();
    elements[tail] = e;//赋值
    if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)//下标越界处理
        doubleCapacity();//扩容
}
</code></pre>

<h3 id="toc_6">pollFirst()</h3>

<p><code>pollFirst()</code>的作用是返回并删除Deque的首部元素，也就是head位置的元素。如果容器不空，只需要直接返回<code>elements[head]</code>即可，当然还需要处理下标的问题，由于ArrayDeque不允许放入<code>null</code>值，则当<code>elements[head]=null</code>时，意味着容器为空。</p>

<pre><code class="language-java">public E pollFirst() {
    E result = elements[head];
    if (result == null)//null值意味着deque为空
        return null;
    elements[head] = null;//let GC work
    head = (head + 1) &amp; (elements.length - 1);//下标越界处理
    return result;
}
</code></pre>

<h3 id="toc_7">pollLast()</h3>

<p><code>pollLast()</code>的作用是返回并删除Deque的尾端元素，也就是<code>tail</code>位置前面的那个元素。</p>

<pre><code class="language-java">public E pollLast() {
    int t = (tail - 1) &amp; (elements.length - 1);//tail的上一个位置是最后一个元素
    E result = elements[t];
    if (result == null)//null值意味着deque为空
        return null;
    elements[t] = null;//let GC work
    tail = t;
    return result;
}
</code></pre>

<h3 id="toc_8">peekFirst()</h3>

<p><code>peekFrist()</code>的作用是返回但不删除Deque的首端元素，也就是<code>head</code>位置的元素，只需要直接返回element[head]即可。</p>

<pre><code class="language-java">public E peekFirst() {
    return elements[head]; // 如果Deque为空，则返回null
}
</code></pre>

<h3 id="toc_9">peekLast()</h3>

<p><code>peekLast()</code>的作用是返回单不删除Deque的尾端函数，也就是<code>tail</code>的前一个位置的元素，只需要处理一下坐标位置即可。</p>

<pre><code class="language-java">public E peekLast() {
    return elements[(tail - 1) &amp; (elements.length - 1)];
}
</code></pre>

<h2 id="toc_10">声明</h2>

<p>本系列博文装载自：<a href="https://github.com/CarpenterLee/JCFInternals">https://github.com/CarpenterLee/JCFInternals</a><br/>
作者：CarpenterLee</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java容器框架分析(三)——LinkedList源码分析]]></title>
    <link href="http://swuzjb.github.io/14878187570598.html"/>
    <updated>2017-02-23T10:59:17+08:00</updated>
    <id>http://swuzjb.github.io/14878187570598.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">LinkedList简介</h2>

<p>LinkedList同时实现了List接口和Deque接口，所以它可以看作一个顺序容器，又可以看作是一个队列（Queue），同时又可以看作为一个栈（Stack）。所以当你需要使用栈和队列时，可以考虑使用LinkedList，一方面是因为Java官方文档已经声明不建议使用Stack类，而且Java也没有官方的Queue的实现类。关于栈或者队列，现在的首选是ArrayDeque，当作为栈或者队列使用时，它具有更好的性能（相比LinkedList）。<br/>
LinkedList的底层通过双向链表作为基础数据结构进行实现。本节将对LinkedList作为线性顺序容器的维护过程予以说明。<br/>
双向列表的每个节点用内部类Node表示。LinkedList通过其<code>first</code>和<code>last</code>引用分别指向链表的第一个和最后一个元素。当链表为空时，<code>first</code>和<code>last</code>引用均为<code>null</code>。</p>

<pre><code class="language-java">//Node内部类
private static class Node&lt;E&gt; {
    E item;
    Node&lt;E&gt; next;
    Node&lt;E&gt; prev;
    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
</code></pre>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14878256240088.png" alt="LinkedList示意图"/></p>

<p>鉴于LinkedList的实现方式，所有和下标有关的操作的时间复杂度都是线性的。而在末尾或首部删除元素仅需要常数时间。为追求效率LinkedList没有实现同步，如果需要多个线程并发访问，可以采用<code>Collections.synchronizedList()</code>对其进行包装。</p>

<h2 id="toc_1">常用方法剖析</h2>

<h3 id="toc_2">add()</h3>

<p><code>add()</code>方法有两个版本，一个是<code>add(E e)</code>，该方法在LinkedList的末尾插入元素，因为有<code>last</code>指向链表末尾，在末尾插入元素的花费是常数时间。只需要几个简单的修改几个相关引用即可；另一个是<code>add(int index,E e)</code>，该方法是在指定位置插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14878263883597.png" alt="add方法示意"/></p>

<p>如上图，可以看出<code>add(E e)</code>的逻辑非常简单，代码如下：</p>

<pre><code class="language-java">public boolean add(E e) {
    final Node&lt;E&gt; l = last;
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
    last = newNode;
    if (l == null)
        first = newNode;//原来链表为空，这是插入的第一个元素
    else
        l.next = newNode;
    size++;
    return true;
}
</code></pre>

<p><code>add(int index,E e)</code>的逻辑相比就复杂一些，可以分成两个部分：先根据index找到需要插入的位置；再修改对应的引用，完成插入操作。代码如下：</p>

<pre><code class="language-java">public void add(int index, E element) {
     //位置越界检查index &gt;= 0 &amp;&amp; index &lt;= size;
    checkPositionIndex(index);
    if (index == size)//插入位置是末尾，包括列表为空的情况
        add(element);
    else{
        Node&lt;E&gt; succ = node(index);//1.先根据index找到要插入的位置
        //2.修改引用，完成插入操作。
        final Node&lt;E&gt; pred = succ.prev;
        final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);
        succ.prev = newNode;
        if (pred == null)//插入位置为0
            first = newNode;
        else
            pred.next = newNode;
        size++;
    }
}
</code></pre>

<p>其中<code>node</code>函数的实现有一些小技巧，因为链表是双向的，所以可以从前往后也可以从后往前，具体从那边开始就取决于<code>index&lt; (size &gt;&gt; 1)</code>即index是靠近前端还是后端。</p>

<h3 id="toc_3">remove()</h3>

<p>remove()方法也有两个版本：<code>remove(Object o)</code>删除第一个和对应元素相同的元素；<code>remove(int index)</code>删除指定位置的元素。<br/>
两个删除操作都需要：先找到对应的目标元素在修改相关引用，完成删除操作。在寻找被删除元素引用的时候<code>remove(Object o)</code>调用的是元素的equals方法，而<code>remove(int index)</code>使用的是下标计数，两种方式都是线性的时间复杂度。在修改引用过程中，都是通过<code>unlink(Node&lt;E&gt; x)</code>方法完成的，需要特别考虑删除元素是首尾的情况。</p>

<pre><code class="language-java">E unlink(Node&lt;E&gt; x) {
    final E element = x.item;
    final Node&lt;E&gt; next = x.next;
    final Node&lt;E&gt; prev = x.prev;
    if (prev == null) {//删除的是第一个元素
        first = next;
    } else {
        prev.next = next;
        x.prev = null;
    }
    if (next == null) {//删除的是最后一个元素
        last = prev;
    } else {
        next.prev = prev;
        x.next = null;
    }
    x.item = null;//let GC work
    size--;
    return element;
}
</code></pre>

<h3 id="toc_4">get()</h3>

<p><code>get(int index)</code>得到指定下标处元素的引用，通过调用上文中提到的<code>node(int index)</code>方法实现。</p>

<pre><code class="language-java">public E get(int index) {
    //检测index是否越界
    checkElementIndex(index);
    return node(index).item;
}
</code></pre>

<h3 id="toc_5">set()</h3>

<p><code>set(int index,E e)</code>方法将指定下标处的元素修改成指定值，也是先通过<code>node(int index)</code>方法找到对应下标的元素的引用，然后修改Node中的item值。</p>

<pre><code class="language-java">public E set(int index, E element) {
    checkElementIndex(index);
    Node&lt;E&gt; x = node(index);
    E oldVal = x.item;
    x.item = element;//替换新值
    return oldVal;
}
</code></pre>

<h2 id="toc_6">声明</h2>

<p>本系列博文装载自：<a href="https://github.com/CarpenterLee/JCFInternals">https://github.com/CarpenterLee/JCFInternals</a><br/>
作者：CarpenterLee</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java容器框架分析（二）——ArrayList源码解析]]></title>
    <link href="http://swuzjb.github.io/14876660718478.html"/>
    <updated>2017-02-21T16:34:31+08:00</updated>
    <id>http://swuzjb.github.io/14876660718478.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">ArrayList简介</h2>

<p>ArrayList实现了List接口，是顺序容器（即元素存放的顺序和加入列表的顺序相同），允许放入<code>null</code>元素，底层通过数组实现。该实现除了没有实现多线程同步之外，其余跟Vector大致相同，即ArrayList是线程不安全的。<br/>
每个ArrayList都一个容量（Capacity）属性，表示底层数组的实际大小，容器内存储元素的个数不大于当前的容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java 泛型只是编译器提供的语法糖，所以这里的数组是一个 Object 数组，以便能够容纳任何类型的对象。<br/>
size(), isEmpty(), get(), set() 方法均能在常数时间内完成，add() 方法的时间开销跟插入位置有关，addAll() 方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。<br/>
为追求效率，ArrayList 没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用 Vector 替代。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14876663843643.png" alt=""/></p>

<h2 id="toc_1">常用方法剖析</h2>

<h3 id="toc_2">set(int index, E element)</h3>

<p>set()方法可以直接设定某个下标对应的元素。既然ArrayList的底层是数组实现的，set()方法的实现也就变得极为简单，直接赋值即可，复杂度为<em>O(1)</em>。</p>

<pre><code class="language-java">public E set(int index, E element) {
    rangeCheck(index);//下标越界检查
    E oldValue = elementData(index);
    elementData[index] = element;//赋值到指定位置，复制的仅仅是引用
    return oldValue;
}
</code></pre>

<h3 id="toc_3">get(int index)</h3>

<p>get()方法可以获取指定下标对应的对象，唯一需要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换，复杂度为<em>O(1)</em>。</p>

<pre><code class="language-java">public E get(int index) {
    rangeCheck(index);
    return (E) elementData[index];//注意类型转换
}
</code></pre>

<h3 id="toc_4">add(E element)和add（int index,E element）</h3>

<p>跟C++的vector不同，ArrayList没有push_back()方法，对应的方法是add(E e)，ArrayList也没有insert()方法，对应的方法是add(int index, E e)。这两个方法都是向容器中添加新元素，这可能会导致 capacity 不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过grow()方法完成的。</p>

<pre><code class="language-java">private void grow(int minCapacity) {
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//原来的1.5倍
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);//扩展空间并复制
}
</code></pre>

<p>由于Java GC自动管理了内存，这里也就不需要考虑源数组释放的问题。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14876673586219.png" alt=""/><br/>
空间的问题解决之后，插入就变得非常简单了。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-24-14876674357716.png" alt=""/><br/>
<code>add(int index,E e)</code>需要先对元素进行移动，然后完成插入，该方法时间复杂度为<em>O(n)</em>。</p>

<h3 id="toc_5">addAll()</h3>

<p>addAll()方法可以一次添加多个元素，根据插入的起始位置不同也用两个版本：一个是在末尾添加<code>addAll(Collection&lt;? extends E&gt; c)</code>;一个是从指定位置开始插入的<code>addAll(int index, Collection&lt;? extends E&gt; c)</code>方法。对应的实现方式和上述的add方法类似，在插入之前，需要对容量进行判断，如果需要则自动扩容，如果从指定位置插入，还需要先对数组元素进行移动。</p>

<h3 id="toc_6">remove()</h3>

<p>remove方法可以删除列表中的元素，其也有两个版本：一个是<code>remove(int index)</code>删除指定位置的元素；一个是<code>remove(Object o)</code>删除第一个满足<code>o.equals(elementData[index])</code>的元素。删除操作是<code>add()</code>的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必选显示的为最后一个位置赋<code>null</code>值。</p>

<pre><code class="language-java">public E remove(int index) {
    rangeCheck(index);
    modCount++;
    E oldValue = elementData(index);
    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index, numMoved);
    elementData[--size] = null; //清除该位置的引用，让GC起作用
    return oldValue;
}
</code></pre>

<p>关于Java GC 这里需要特别说明一下，<strong>有了垃圾收集器并不意味着一定不会有内存泄漏</strong>。对象能否被 GC 的依据是是否还有引用指向它，上面代码中如果不手动赋null值，除非对应的位置被其他元素覆盖，否则原来的对象就一直不会被回收。</p>

<h2 id="toc_7">使用技巧</h2>

<p>关于List的容量，可以在一开始就给定一个比较合理的值，避免内存复制所带来的不必要的时间开销。</p>

<h2 id="toc_8">转载声明</h2>

<p>本文转载自：<a href="https://github.com/CarpenterLee/JCFInternals">https://github.com/CarpenterLee/JCFInternals</a><br/>
作者：CarpenterLee</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java容器框架分析（一）——相关概念综述]]></title>
    <link href="http://swuzjb.github.io/14876629153312.html"/>
    <updated>2017-02-21T15:41:55+08:00</updated>
    <id>http://swuzjb.github.io/14876629153312.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">概述</h2>

<p>容器，就是用于容纳其它对象的对象。在Java API中已经实现了很多常用的容器统称为Java Collections Framework（JCF）。JCF起始于JDK 1.2 使用JCF的优点在于：</p>

<ul>
<li>降低编程难度<br/></li>
<li>提高程序性能</li>
<li>提高API之间的互操作性</li>
<li>降低学习难度</li>
<li>降低设计和实现相关API的难度</li>
<li>增强程序的重用性</li>
</ul>

<p>Java容器只能存放对象，对于基础类型（如int、double、float等），需要将其包装成对应的包装类型对象后才能放到容器之中，当然很多情况之下拆包和解包过程可以由虚拟机自动完成。</p>

<h2 id="toc_1">泛型</h2>

<p>Java 容器能够容纳任何类型的对象，这一点表面上是通过泛型机制完成，Java 泛型不是什么神奇的东西，只是编译器为我们提供的一个 “语法糖”，泛型本身并不需要Java虚拟机的支持，只需要在编译阶段做一下简单的字符串替换即可。实质上Java的单继承机制才是保证这一特性的根本，因为所有的对象都是Object的子类，容器里只要能够存放Object对象就行了。<br/>
事实上，所有容器的内部存放的都是Object对象，泛型机制只是简化了编程，由编译器自动帮我们完成了强制类型转换和类型检测而已。JDK 1.4 以及之前版本不支持泛型，类型转换需要程序员显式完成。</p>

<pre><code class="language-java">//JDK 1.4 or before
ArrayList list = new ArrayList();
list.add(new String(&quot;Monday&quot;));
list.add(new String(&quot;Tuesday&quot;));
list.add(new String(&quot;Wensday&quot;));
for(int i = 0; i &lt; list.size(); i++){
    String weekday = (String)list.get(i);//显式类型转换
    System.out.println(weekday.toUpperCase());
}
//JDK 1.5 or latter
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();//参数化类型
list.add(new String(&quot;Monday&quot;));
list.add(new String(&quot;Tuesday&quot;));
list.add(new String(&quot;Wensday&quot;));
for(int i = 0; i &lt; list.size(); i++){
    String weekday = list.get(i);//隐式类型转换，编译器自动完成
    System.out.println(weekday.toUpperCase());
}
</code></pre>

<h2 id="toc_2">内存管理</h2>

<p>Java不需要程序员来管理内存回收，而是有着一套自动的垃圾回收机制。另外，由于Java里的对象都在堆上，所以容器中放的其实是对象的引用而不是对象本身，这就避免了容器对象的拷贝复制问题。</p>

<h2 id="toc_3">接口与实现</h2>

<h3 id="toc_4">接口</h3>

<p>为了规范容器的行为，统一设计，JCF定义了14种容器接口，他们之间的关系如下图:<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-21-14876644819118.png" alt=""/><br/>
Map接口并没有继承自Collection接口，因为Map表示的是关联式容器而不是集合，但是Java在Map接口中提供了从Map转化为Collection的方法，可以方便的将Map切换到集合视图。上图中提供了Queue接口，却没有Stack接口，是因为在JDk 1.6之后Stack接口的功能已经被Deque取代。</p>

<h3 id="toc_5">实现</h3>

<p>上述接口的通用实现类见下表：<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-21-14876650570700.jpg" alt=""/></p>

<h2 id="toc_6">迭代器（Iterator）</h2>

<p>跟C++的STL一样，JCF的迭代器为我们提供了遍历容器中元素的方法，只有容器本身清楚容器里元素的组织方式，因此迭代器只能通过容器本身得到。每个容器都会通过内部类的形式来实现自己的迭代器，相比C++ STL的迭代器，JCF的迭代器更容易使用。<br/>
实例代码：</p>

<pre><code class="language-java">//通过迭代器来访问容器元素
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
list.add(new String(&quot;Monday&quot;));
list.add(new String(&quot;Tuesday&quot;));
list.add(new String(&quot;Wensday&quot;));
//得到迭代器
Iterator&lt;String&gt; it = list.iterator();
while(it.hasNext()){
    String weekday = it.next();//访问元素
    System.out.println(weekday.toUpperCase());
}
//JDK 1.5引入了增强的for循环，简化了迭代容器时的写法。
//使用foreach迭代
ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
list.add(new String(&quot;Monday&quot;));
list.add(new String(&quot;Tuesday&quot;));
list.add(new String(&quot;Wensday&quot;));
for(String weekday : list){
    System.out.println(weekday.toUpperCase());
}
</code></pre>

<h2 id="toc_7">声明</h2>

<p>本系列博文装载自：<a href="https://github.com/CarpenterLee/JCFInternals">https://github.com/CarpenterLee/JCFInternals</a><br/>
作者：CarpenterLee</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java内存管理]]></title>
    <link href="http://swuzjb.github.io/14875782735365.html"/>
    <updated>2017-02-20T16:11:13+08:00</updated>
    <id>http://swuzjb.github.io/14875782735365.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Java的内存区域</h2>

<p>Java的内存区域按照是否线程共享分为两个区域</p>

<ol>
<li>线程共享区域包括：方法区（Method Area）和堆（Heap）</li>
<li>线程独享的区域包括：虚拟机栈（VM Stack），本地方法栈（Native Method Stack）和程序计数器（Program Counter Register）</li>
</ol>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-20-14875809468666.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h3 id="toc_1">程序计数器</h3>

<p>程序计数器是一块较小的内存区域，指向当前执行的字节码。如果线程正在执行一个Java方法，这个计数器记录正在执行的虚拟机字节码指令的地址，如果执行的是Native方法，则计数器为空。<br/>
此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError的区域。</p>

<h3 id="toc_2">Java虚拟机栈</h3>

<p>线程私有区域，其生命周期和线程一致。该区域描述的是Java方法执行的内存模型：每个方法在执行的时候都会创建一个栈帧（方法运行时的基本数据结构）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。<br/>
在Java虚拟机规范中，对这个区域规定了两种异常情况：</p>

<ol>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；</li>
<li>如果虚拟机栈可以动态扩展（当前大部分虚拟机实现都是动态的、但是固定长度的栈也是被允许的）在扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</li>
</ol>

<h3 id="toc_3">本地方法栈</h3>

<p>与虚拟机栈功能类似，只不过虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为使用到的Native方法服务。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError异常和OutOfMemoryError异常。</p>

<h3 id="toc_4">Java堆</h3>

<p>是虚拟机管理内存中最大的一块，被所有线程共享，该区域用于存放对象实例，几乎所有的对象都在改区域分配。Java堆是内存回收的主要区域，也被称为GC堆。从内存回收的角度来看，由于现在的垃圾收集器大都采用分代收集算法，所以还可以将Java堆细分为：新生代和老年代，或继续细分为Eden空间、From Survivor空间、To Survivor空间等。<br/>
根据Java虚拟机规范，Java堆可以处于物理上不连续的空间，只要逻辑上是连续的就行，在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的都是可扩展的（通过<code>-Xmx</code>和<code>-Xms</code>参数控制）。<br/>
如果在堆中没有内存完成实例分配，而堆又无法继续扩展时，抛出OutOfMemoryError异常。</p>

<h3 id="toc_5">方法区</h3>

<p>与Java一样，是各个线程所共享的，用于存储已被虚拟机加载类信息、常亮、静态变量、即时编译器编译后的代码等数据。<br/>
根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，抛出OutOfMemoryError异常。</p>

<h3 id="toc_6">运行时常量池</h3>

<p>运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。运行期间可以将新的常量放入常量池中，用得比较多的就是String类的intern()方法，当一个String实例调用intern时，Java查找常量池中是否有相同的Unicode的字符串常量，若有，则返回其引用；若没有，则在常量池中增加一个Unicode等于该实例字符串并返回它的引用。</p>

<h2 id="toc_7">Java堆的内存模型</h2>

<p>内存模型如图所示：<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-20-14875816888809.jpg" alt=""/></p>

<p>广泛地说，JVM堆内存被分为两部分——年轻代（Young Generation）和老年代（Old Generation）。</p>

<h3 id="toc_8">年轻代</h3>

<p>年轻代是所有新对象产生的地方。当年轻代内存空间被用完时，就会触发垃圾回收。这个垃圾回收叫做Minor GC。年轻代被分为3个部分——Eden区和2个Survivor区。</p>

<h4 id="toc_9">年轻代的空间要点</h4>

<ul>
<li>大多数新建对象都位于Eden区；</li>
<li>当Eden区域被填满时，就会触发Minor GC，并把所有存活下来的对象复制到其中一个survivor区域；</li>
<li>Minor GC同样会检查存活下来的对象，并把它们转移到另一个Survivor区域，这样在一段时间内，总有一个空的Survivor区；</li>
<li>经过多次GC周期后，仍然存活下来的对象会被转移到年老代空间，通常这是在年轻代有资格提升到老年代前通过年龄阈值来完成的。</li>
</ul>

<h3 id="toc_10">年老代</h3>

<p>年老代内存里包含了长期存活的对象和经过多次Minor后依然存活下来的对象。年老代在空间不足时，将触发Major GC，将会花费更多时间进行垃圾收集。</p>

<h2 id="toc_11">垃圾回收</h2>

<h3 id="toc_12">如何确定垃圾对象</h3>

<p>Java堆当中几乎储存了所有的对象实例，要想实现自动的垃圾回收，知道哪些对象是‘垃圾’就十分必要了。目前，比较流行的自动垃圾回收，都是基于两个思路实现的。</p>

<h4 id="toc_13">引用计数法</h4>

<p>引用计数法实现简单，效率较高，在大部分情况下是一个不错的算法。其原理是：给对象添加一个引用计数器，每当有一个地方引用该对象时，计数器加1，当引用失效时，计数器减1，当计数器值为0时表示该对象不再被使用。需要注意的是：引用计数法很难解决对象之间相互循环引用的问题，主流Java虚拟机没有选用引用计数法来管理内存。</p>

<h4 id="toc_14">可达性分析法</h4>

<p>Java虚拟机使用可达性分析法来进行对象的可用性判断。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。如图所示，对象object 5、object 6、object 7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-20-14875947879603.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h5 id="toc_15">Java中的GC ROOT</h5>

<ul>
<li>虚拟机栈中的引用对象</li>
<li>方法区中的静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中本地方法引用的对象</li>
</ul>

<h5 id="toc_16">对象的救赎</h5>

<p>在可达性分析中不可用的对象并不是立刻被虚拟机销毁，而是被标记为待回收，要真正的宣告一个对象死亡，至少需要经历两次标记：如果对象在可达性分析后发现没有与GC ROOT相连的引用链，那么他会被第一次被标记并进行一次筛选，筛选是判断此对象是否有必要执行finalize()方法，当对象没有覆盖Object类的finalize()方法或该类的finalize（）方法已经被虚拟机调用过，虚拟机将视为没有必要执行，对象会被销毁。反之，将会将该对象加入一个优先级非常低的队列中等待执行finalize()方法，但不保证等待其执行完，这是对象进行自我救赎的最后也是唯一的机会。</p>

<h3 id="toc_17">典型的垃圾回收算法</h3>

<h4 id="toc_18">标记-清楚（Mark-Sweep）算法</h4>

<p>这是最基础的垃圾回收算法，标记-清楚算法顾名思义，分为两个阶段，标记和删除。标记阶段的任务是标记出那些对象需要被回收（即我们上面说的不可达或不可用对象），清楚阶段就是回收（释放）被标记对象所占用的内存空间。具体样例如下图：<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-20-14875956126004.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<p>通过观察图片我们可以非常轻松的发现，标记-清楚算法虽然非常简单，但是有一个比较严重的问题，那就是非常容易产生大量的内存碎片，碎片的数量一旦过多就会导致在后续为大对象分配内存空间时午饭找到足够的内存空间而提前出发新一轮的垃圾收集严重时会导致内存溢出。</p>

<h4 id="toc_19">复制（Copying）算法</h4>

<p>为了解决标记-清楚算法的缺陷，复制算法应运而生。复制算法的思路是，将可用内存按容量划分为大小相同的两块，每次创建对象时只使用其中的一块儿。当这一块儿内存用完时，就触发垃圾回收，将还存活的对象复制到另外一块儿内存空间之上，再把已经使用的内存空间一次释放掉，这样一来就不会出现内存碎片的问题了。操做实例如图：<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-20-14875960340164.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<p>复制算法虽然实现简单，运行效率高而且也不会出现内存碎片，但是对内存空间的使用却付出了高昂的代价，可用内存缩减为了原先的一半。同时复制算法的效率和存活对象数目的多少直接相关，若存活对象数量较多，效率就会大大的降低。</p>

<h4 id="toc_20">标记整理算法</h4>

<p>为了解决上面两种算法的缺陷，提出了标记整理（Mark-Compact）算法。该算法在标记阶段和标记清理算法完全一致，但是在完成标记之后，不是直接清理可回收对象，而是将存活的对象都向内存一段移动，然后清理端边界以外的内存，具体过程如下图：<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-20-14875963334710.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h4 id="toc_21">分代收集算法</h4>

<p>分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。<br/>
目前大部分垃圾收集器对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间（一般为8:1:1），每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。<br/>
而由于老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compact算法。</p>

<h2 id="toc_22">Java堆的配置参数</h2>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2017-02-20-14875967441636.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_23">Java中的引用</h2>

<p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。<br/>
在JDK 1.2以前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。<br/>
在JDK 1.2之后，Java对引用的概念进行了扩充，提出了四种不同的引用。</p>

<h3 id="toc_24">强引用</h3>

<p>就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p>

<h3 id="toc_25">软引用</h3>

<p>是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。</p>

<h3 id="toc_26">弱引用</h3>

<p>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。</p>

<h3 id="toc_27">虚引用</h3>

<p>也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTPS技术简要介绍]]></title>
    <link href="http://swuzjb.github.io/14814626217350.html"/>
    <updated>2016-12-11T21:23:41+08:00</updated>
    <id>http://swuzjb.github.io/14814626217350.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">背景</h2>

<p>随着互联网技术应用的广泛应用，越来越多的信息在网络上被交换和利用，网络信息安全也就成为了一个被关注的热点。我们当前的互联网服务多数是基于HTTP协议之上进行开发设计，但是由于HTTP的设计缺陷，信息数据在传输过程中有极大的泄露风险，HTTPS技术也应运而生。<br/>
近日，各大互联网公司纷纷宣布旗下服务必须强制使用HTTPS技术进行网络通讯。如2017年1月1日苹果iOS应用推行ATS安全标准，将强制使用HTTPS安全连接；谷歌Chrome将把所有的HTTP网站标记为「不安全」；在国内热火朝天的小程序也要求必须使用HTTPS请求等。<br/>
本文将对HTTPS的定义、工作原理、使用、与HTTP的不同等方面对HTTPS技术进行简要的介绍。</p>

<h2 id="toc_1">HTTS工作原理</h2>

<h3 id="toc_2">HTTP在安全方面的缺陷</h3>

<p>HTTP本身是明文传输的，没有经过任何安全处理。例如用户在百度搜索了一个关键字，比如“苹果手机”，中间者完全能够查到到这个信息，并且有可能打电话过来骚扰用户。也有一些用户投诉使用百度时，发现首页或者结果页浮了一个很长很大的广告，这也肯定是中间者往页面插的广告内容。如果劫持技术比较低劣的话，用户甚至无法访问百度。<br/>
这里提到的一些中间者主要指一些网络节点，使用户数据在浏览器和百度服务器之间传输必须要经过的节点，比如WIFI热点、路由器、防火墙、反向代理、缓存服务器等。<br/>
在HTTP协议下，中间者可以随意嗅探用户搜索内容，窃取隐私甚至篡改网页。不过HTTPS是这些劫持行为的克星，能够完全有效地防御。总体来说，HTTPS协议提供了三个强大的功能来对抗上述的劫持行为：</p>

<ol>
<li>内容加密。浏览器到百度服务器的内容都是以加密形式传输的，中间者无法直接查看原始内容</li>
<li>身份认证。保证用户访问的是百度服务，即使被DNS劫持到了第三方站点，也会提醒用户没有访问百度服务</li>
<li>数据完整。防止内容被第三方冒充或篡改</li>
</ol>

<h3 id="toc_3">HTTPS的定义</h3>

<p>HTTPS（Hypertext Transfer Protocol Secure，超文本传输安全协议）是一种网络安全传输协议。在计算机网络上，HTTPS经由超文本传输协议进行通信，但利用SSL/TLS来对数据包进行加密。HTTPS开发的主要目的，是提供对网络服务器的身份认证，保护交换数据的隐私与完整性。简单而言HTTPS就是在HTTP协议发送数据的过程中使用SSL协议对数据进行加密，从而保证数据的安全。<br/>
SSL目前的版本是3.0，被IETF（Internet Engineering Task Force）定义在RFC 6101中，之后IETF对SSL 3.0进行了升级，于是出现了TLS（Transport Layer Security）1.0，定义在RFC 2246。实际上我们现在的HTTPS都是用的TLS协议，但是由于SSL出现的时间比较早，并且依旧被现在浏览器所支持，因此SSL依然是HTTPS的代名词，但无论是TLS还是SSL都是上个世纪的事情，SSL最后一个版本是3.0，今后TLS将会继承SSL优良血统继续为我们进行加密服务。目前TLS的版本是1.2，定义在RFC 5246中，暂时还没有被广泛的使用。<br/>
<img src="media/14814626217350/14814628384569.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h3 id="toc_4">TLS/SSL工作原理</h3>

<p>HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，本节分析安全协议的实现原理。<br/>
TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。<br/>
<img src="media/14814626217350/14814628187370.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<p>散列函数Hash，常见的有MD5、SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性;对称加密，常见的有 AES-CBC、DES、3DES、AES-GCM等，相同的密钥可以用于信息的加密和解密，掌握密钥才能获取信息，能够防止信息窃听，通信方式是1对1;非对称加密，即常见的 RSA 算法，还包括 ECC、DH 等算法，算法特点是，密钥成对出现，一般称为公钥(公开)和私钥(保密)，公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。因此掌握公钥的不同客户端之间不能互相解密信息，只能和掌握私钥的服务器进行加密通信，服务器可以实现1对多的通信，客户端也可以用来验证掌握私钥的服务器身份。<br/>
在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密;对称加密的优势是信息传输1对1，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录，且缺少修改密码的机制;非对称加密的特点是信息传输1对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密速度慢。<br/>
结合三类算法的特点，TLS的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥，然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。</p>

<h3 id="toc_5">HTTPS的工作原理</h3>

<p>HTTPS其实是有两部分组成：HTTP + SSL/TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。请求流程如图所示：<br/>
<img src="media/14814626217350/14814628698302.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<ol>
<li><p>客户端发起HTTPS请求<br/>
与HTTP发送请求类似，用户在浏览器或者通过其他方式请求一个HTTPS连接如（<a href="https://www.baidu.com">https://www.baidu.com</a>），然后连接到服务器的443端口。在此过程中客户端会发送一个密文族给服务器，密文族是浏览器所支持的加密算法的清单。</p></li>
<li><p>服务器配置<br/>
采用HTTPS协议的服务器必须要有一套数字证书，该证书可以自己制作，也可以向组织申请。区别就是自己制作的证书需要客户端验证通过才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。<br/>
证书其实就是一对公钥和私钥，可以这么理解，公钥就是一把锁头，私钥就是这把锁的钥匙，锁头可以给别人对某个东西进行加锁，但是加锁完毕之后，只有持有这把锁的钥匙才可以解锁看到加锁的内容。<br/>
前面说过客户端会传送密文族给服务端，服务端则会从这些密文族中，挑选出一个，比如百度采用的就是RSA公钥加密算法来区分证书签名和交换密钥，通过AES算法来加密数据，至于GCM则是用来校验信息的。</p></li>
<li><p>传送证书<br/>
证书将在接收到客户端请求后由服务器端发送到客户端。该证书包含了公钥、证书的颁发机构、过期时间等重要信息。</p></li>
<li><p>客户端解析证书<br/>
这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，如颁发机构、过期时间等等，如果发现异常则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密。<br/>
注意一下上面提到的“发现异常”。证书中会包含数字签名，该数字签名是加密过的，是用颁发机构的私钥对本证书的公钥、名称及其他信息做hash散列加密而生成的。客户端浏览器会首先找到该证书的根证书颁发机构，如果有，则用该根证书的公钥解密服务器下发的证书，如果不能正常解密，则就是“发现异常”，说明该证书是伪造的。</p></li>
<li><p>传送加密信息<br/>
这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，然后客户端和服务端的通信就可以通过这个随机值生成对称加密的秘钥来进行加密和解密了。</p></li>
<li><p>服务端解密信息<br/>
服务端用私钥解密后，得到了客户端传过来的随机值，至此一个非对称加密的过程结束，至此TLS利用非对称加密实现了身份认证和密钥协商。然后把内容通过该值进行对称加密。</p></li>
<li><p>传输加密后的信息<br/>
当对称加密秘钥生成完成之后，服务器和客户端之间的信息通信将被该秘钥进行加密。加密后进行正常的HTTP的信息发送，该信息可在客户端被揭秘还原。</p></li>
<li><p>客户端解密信息<br/>
客户端用之前生成的随机值解密服务端传送过来的信息，于是获取了解密后的内容，至此一个对称加密的过程结束，看到对称加密是用于对服务器待传送给客户端的数据进行加密用的。整个过程即使第三方监听了数据，也束手无策。</p></li>
</ol>

<h2 id="toc_6">HTTPS的使用</h2>

<h3 id="toc_7">SSL证书类型</h3>

<p>通常来说，SSL证书分为三大类，他们的安全性是递增的，当然价格和安全系数成正比。</p>

<ol>
<li>DV（Domain Validation Certificate）。DV证书适合个人网站使用，申请证书时，CA只验证域名信息。几分钟之内就能签发。</li>
<li>OV（Organization Validation Certificate）。OV证书需要认证公司的信息。1-2天签发。</li>
<li>EV（Extended Validation Certificate）。EV证书的认证最为严格，一般会要求提供纸质材料。签发时间也较久。
<img src="media/14814626217350/14814632071178.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></li>
</ol>

<h3 id="toc_8">SSL证书供应商简单对比</h3>

<p>Let&#39;s Encrypt是国外一个公共的免费SSL项目，由Linux基金会托管，由Mozilla、思科、Akamai、IdenTrust和EFF等组织发起，目的就是向网站自动签发和管理免费证书，以便加速互联网由HTTP过渡到HTTPS。<br/>
StartSSL是StartCom公司旗下的SSL证书，应该算是免费SSL证书中的鼻祖，最早提供完全免费的SSL证书并且被各大浏览器所支持的恐怕就只有 StartSSL证书了。首次申请StartSSL免费SSL证书是免费一年，但是你可以在第二年继续续期。<br/>
七牛免费SSL，七牛最近和亚洲诚信合作推了赛门铁克Symantec签发的DV证书。</p>

<h4 id="toc_9">对比结果：</h4>

<ol>
<li>申请便利性：StartSSL和七牛的申请起来都相对便利，Let&#39;s Encrypt对环境要求比较多。</li>
<li>有效期：StartSSL和七牛都是一年，Let&#39;s Encrypt 90天。</li>
<li>证书兼容性：StartSSL 的一年免费 DV SSL 已经被 Chrome、Mozilla 封杀。要慎重选择。Let&#39;s Encrypt总体来说兼容性还不错，不过肯定是赛门铁克的兼容性最好。</li>
<li>售后：免费证书其实基本都没啥售后可言，Let&#39;s Encrypt 基本上只能求助于社区，StartSSL和七牛都有官方客服可以咨询，七牛对中文服务的支持更好。</li>
</ol>

<h3 id="toc_10">七牛免费证书的申请和使用</h3>

<ol>
<li><p>在个人面板-&gt;证书管理申请证书<br/>
<img src="media/14814626217350/14814632233597.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>申请完证书后跳转到证书列表而不是订单列表，具体设置要在订单列表中完成。<br/>
<img src="media/14814626217350/14814632320729.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>DNS验证</p>

<ol>
<li> 记录类型选择 CNAME</li>
<li><p>主机记录填写 cnamekey，点击复制 Key 是复制全部字段（注：万网和DNSpod平台cnamekey不需要主域名部分），见下图<br/>
<img src="media/14814626217350/14814632427561.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>记录值填写cnamevalue，复制全部字段，见图<br/>
<img src="media/14814626217350/14814632609686.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>其他选项默认即可，见图<br/>
<img src="media/14814626217350/14814632750932.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>CName Key 的 DNS 解析指向 CName Value 操作完成后，系统会循环自动检测验证，最长不超过24小时，您可以用 dig 命令来自我检测下DNS解析是否配置成功，见图<br/>
<img src="media/14814626217350/14814632882974.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
</ol></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hadoop搭建实例]]></title>
    <link href="http://swuzjb.github.io/14786108252793.html"/>
    <updated>2016-11-08T21:13:45+08:00</updated>
    <id>http://swuzjb.github.io/14786108252793.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>本次课程要求自主搭建Hadoop集群环境，并进行MapReduce作业操作<br/>
本文以统计知乎用户地域分布情况为例进行统计展示</p>
</blockquote>

<h2 id="toc_0">数据获取与格式说明</h2>

<h3 id="toc_1">数据获取</h3>

<p>实验数据采用爬虫方式从知乎进行爬取，并保存进入数据库，总数据量3383054条。为了后续处理方便，我们将数据从数据库中倒成csv文件进行存储。<br/>
数据爬取代码：<a href="https://github.com/wycm/mycrawler">知乎爬虫</a></p>

<h3 id="toc_2">数据格式</h3>

<p>导出的数据格式为：<code>id,name,headline,gender,school,major,address,industry,company,job</code><br/>
<img src="media/14786108252793/14786149854526.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_3">Hadoop集群搭建</h2>

<p>Hadoop是一个由Apache基金会所开发的分布式系统基础架构。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。<br/>
本次课程实例基于ubuntu12.04、jdk1.8.111、hadoop2.7.3进行说明，其中ubuntu服务器以虚拟机的形式搭建。</p>

<ol>
<li><p>ubuntu虚拟机搭建</p>

<p>虚拟机创建的步骤在本文中不加以介绍，如有需要请自行百度。ps.为了简便操作，我们可以先创建并配置一台虚拟机然后进行克隆。为了简便操作，可以使用<code>sudo apt-get install ubuntu-desktop</code>安装ubuntu的图形操作界面。</p></li>
<li><p>建立软件目录</p>

<p>为了后续更好的管理我们按照的软件。我们使用mkdir命令，建立软件的安装目录。命令：<code>sudo mkdir /usr/soft</code></p></li>
<li><p>jdk的安装与环境变量设置</p>

<ol>
<li>首先我们从Oracle的官网上下载jdk的压缩文件。下载地址：<a href="http://download.oracle.com/otn-pub/java/jdk/8u111-b14/jdk-8u111-linux-x64.tar.gz">jdk</a>;</li>
<li>使用<code>tar -xzvf 文件名</code>对安装包进行解压;</li>
<li>将解压后的文件夹移至上一步我们建立的软件安装目录。<code>mv jdk1.8.0_111/ /usr/soft</code></li>
<li><p>设置java所需要的环境变量:</p>

<ol>
<li>打开配置文件 <code>sudo vi /etc/profile</code>；</li>
<li>在配置文件中加入<code>export JAVA_HOME=&quot;/usr/soft/jdk1.8.0_111&quot;</code>；</li>
<li>在配置文件中加入<code>export PATH=&quot;$PATH:$JAVA_HOME/bin&quot;</code>；</li>
<li>保存配置文件退出；</li>
<li>使用source命令让配置文件生效，<code>source /etc/profile</code></li>
</ol></li>
<li><p>调用<code>javac -version</code>命令，检查配置是否生效,安装是否成功。</p></li>
</ol></li>
<li><p>Hadoop的安装与环境变量设置</p>

<ol>
<li>从Apache Hadoop网站上下载对应的Hadoop安装包。下载地址：<a href="http://mirrors.cnnic.cn/apache/hadoop/common/hadoop-2.7.3/hadoop-2.7.3.tar.gz">Hadoop2.7.3</a>；</li>
<li>使用<code>tar -xzvf 文件名</code>对安装包进行解压;</li>
<li>将解压后的文件夹移至上一步我们建立的软件安装目录。<code>mv Hadoop-2.7.3 /usr/soft</code></li>
<li>打开配置文件 <code>sudo vi /etc/profile</code>；</li>
<li>在配置文件中加入<code>export PATH=&quot;$PATH:$JAVA_HOME/bin:/usr/soft/hadoop-2.7.3/bin:/usr/soft/hadoop-2.7.3/sbin&quot;</code>；</li>
<li>保存配置文件退出；</li>
<li>使用source命令让配置文件生效，<code>source /etc/profile</code></li>
<li>调用<code>Hadoop version</code>命令，检查配置是否生效,安装是否成功。</li>
</ol></li>
<li><p>SSH免密码登录配置</p>

<ol>
<li>使用<code>sudo apt-get install ssh</code>安装完整的ssh客户端；</li>
<li>使用<code>ssh-keygen -t rsa -P &#39;&#39; -f ~/.ssh/id_rsa</code>生成公私钥；</li>
<li>使用<code>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code>将公钥复制；</li>
<li>使用<code>ssh localhost</code>命令检验是否可以免密码登录系统。</li>
</ol></li>
<li><p>修改服务器的名称</p>

<ol>
<li>使用<code>sudo vi /etc/hostname</code>,修改服务器的名称</li>
<li>重启服务器使配置生效</li>
</ol></li>
<li><p>配置Hadoop配置文件</p>

<p>Hadoop的配置文件位于其安装目录下的etc/hadoop/目录下</p>

<ol>
<li><p>修改yarn-site.xml，内容如下（master代表主服务器名）：</p>

<pre><code class="language-xml">&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;fs.defaultFS&lt;/name&gt;
        &lt;value&gt;hdfs://master/&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;
        &lt;value&gt;~/hadoop/data&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre></li>
<li><p>修改hdfs-site.xml，内容如下:</p>

<pre><code class="language-xml">&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.replication&lt;/name&gt;
        &lt;value&gt;3&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre></li>
<li><p>修改mapred-site.xml（此文件需要从mapred-site.xml.template复制），内容如下：</p>

<pre><code class="language-xml">&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;
        &lt;value&gt;yarn&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre></li>
<li><p>修改yarn-site.xml,内容如下：</p>

<pre><code class="language-xml">&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;
        &lt;value&gt;master&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;
        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt;
        &lt;value&gt;master:8032&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt;
        &lt;value&gt;master:8030&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre></li>
<li><p>修改slaves文件，将附属机主机名添加入内，每行一个，样例为:</p>

<pre><code class="language-xml">s1
s3
</code></pre></li>
</ol></li>
<li><p>克隆宿主机，配置hosts文件</p>

<ol>
<li>使用VM的克隆功能，克隆虚拟机，并依次修改主机名</li>
<li><p>根据实际IP修改各个机器的hosts文件，ip查看可以使用<code>ifconfig</code>命令，样例如下：</p>

<pre><code>127.0.0.1  localhost    
10.104.234.203  master
182.254.216.245 s1
123.207.252.11 s2
123.207.24.98 s3
</code></pre></li>
</ol></li>
<li><p>格式化HDFS文件系统，执行<code>hdfs namenode -format</code>命令，对HDFS进行格式化。</p></li>
<li><p>启动Hadoop集群</p>

<ol>
<li>启动文件系统,<code>start-dfs.sh</code>;</li>
<li>启动yarn，<code>start-yarn.sh</code>;</li>
<li>可以使用<code>jps</code>命令，检查各个服务的启动情况</li>
</ol></li>
</ol>

<h2 id="toc_4">统计程序的编写与运行</h2>

<p>本次实验所用的MapReduce程序采用Maven的方式进行构建，具体操作可以参考文章：<a href="http://www.cnblogs.com/Leo_wl/p/4862820.html">Maven构建Hadoop工程</a></p>

<ol>
<li><p>编写Mapper类，本次我们实现的功能从原理上与Hadoop自带的WordCount实验非常相似。</p>

<pre><code class="language-java">package com.swu.count;

import java.io.IOException;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;

public class CountMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt; {

    private final static IntWritable one = new IntWritable(1);
    private Text word = new Text();

    @Override
    protected void map(Object key, Text value, Mapper&lt;Object, Text, Text, IntWritable&gt;.Context context)
            throws IOException, InterruptedException {
        // 获取每一行数据，并以逗号为基准进行分割
        String[] data = value.toString().split(&quot;,&quot;);
        // 设置word的key为地址信息
        word.set(data[5]);
        // 设置value为1
        context.write(word, one);
    }

}
</code></pre></li>
<li><p>编写Reducer类。</p>

<pre><code class="language-java">package com.swu.count;

import java.io.IOException;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Reducer;

public class CountReduce extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {
    private IntWritable result = new IntWritable();
    private Text keyEx = new Text();

    @Override
    protected void reduce(Text key, Iterable&lt;IntWritable&gt; values,
            Reducer&lt;Text, IntWritable, Text, IntWritable&gt;.Context context) throws IOException, InterruptedException {
        int sum = 0;
        // 遍历value相加
        for (IntWritable val : values) {
            sum += val.get();
        }
        // 返回新的key-value
        result.set(sum);
        keyEx.set(key);
        context.write(keyEx, result);
    }
}
</code></pre></li>
<li><p>编写Comparator类，用于第二次作业的排序。</p>

<pre><code class="language-java">package com.swu.count;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.WritableComparable;

public class CountComparator extends IntWritable.Comparator {

    @Override
    public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {
        // TODO Auto-generated method stub
        return -super.compare(b1, s1, l1, b2, s2, l2);
    }
    public int compare(WritableComparable a, WritableComparable b) {
        // TODO Auto-generated method stub
        return -super.compare(a, b);
    }
}
</code></pre></li>
<li><p>编写主方法。</p>

<pre><code class="language-java">package com.swu.count;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.util.GenericOptionsParser;
import java.util.Random;

import org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat;
import org.apache.hadoop.mapreduce.lib.input.SequenceFileInputFormat;
import org.apache.hadoop.mapreduce.lib.map.InverseMapper;

public class Main {
    public static void main(String[] args) throws Exception {
        Configuration conf = new Configuration();
        String[] otherArgs = new GenericOptionsParser(conf, args).getRemainingArgs();
        if (otherArgs.length != 2) {
            System.err.println(&quot;Usage: zhihuCount &lt;in&gt; &lt;out&gt;&quot;);
            System.exit(2);
        }
        Path tempDir = new Path(&quot;wordcount-temp-&quot; + Integer.toString(new Random().nextInt(Integer.MAX_VALUE))); // 定义一个临时目录

        Job job = new Job(conf, &quot;zhihuCount&quot;);
        job.setJarByClass(Main.class);
        try {
            job.setMapperClass(CountMapper.class);
            job.setCombinerClass(CountReduce.class);
            job.setReducerClass(CountReduce.class);

            job.setOutputKeyClass(Text.class);
            job.setOutputValueClass(IntWritable.class);

            FileInputFormat.addInputPath(job, new Path(otherArgs[0]));
            FileOutputFormat.setOutputPath(job, tempDir);
            // 先将词频统计任务的输出结果写到临时目录中,下一个排序任务以临时目录为输入目录。
            job.setOutputFormatClass(SequenceFileOutputFormat.class);
            if (job.waitForCompletion(true)) {
                Job sortJob = new Job(conf, &quot;sort&quot;);
                sortJob.setJarByClass(Main.class);
                FileInputFormat.addInputPath(sortJob, tempDir);
                sortJob.setInputFormatClass(SequenceFileInputFormat.class);

                /* InverseMapper由hadoop库提供，作用是实现map()之后的数据对的key和value交换 */
                sortJob.setMapperClass(InverseMapper.class);
                /* 将 Reducer 的个数限定为1, 最终输出的结果文件就是一个。 */
                sortJob.setNumReduceTasks(1);
                FileOutputFormat.setOutputPath(sortJob, new Path(otherArgs[1]));

                sortJob.setOutputKeyClass(IntWritable.class);
                sortJob.setOutputValueClass(Text.class);
                /*
                 * Hadoop 默认对 IntWritable 按升序排序，而我们需要的是按降序排列。 因此我们实现了一个
                 * IntWritableDecreasingComparator 类, 并指定使用这个自定义的 Comparator
                 * 类对输出结果中的 key (词频)进行排序
                 */
                sortJob.setSortComparatorClass(CountComparator.class);

                System.exit(sortJob.waitForCompletion(true) ? 0 : 1);
            }
        } finally {
            FileSystem.get(conf).deleteOnExit(tempDir);
        }
    }
}
</code></pre></li>
<li><p>将写好的程序编译为jar包(注意指定Main方法)，上传至服务器。</p></li>
<li><p>执行<code>hadoop jar XXX.jar /inputFile /outputFile</code>，执行作业。</p></li>
</ol>

<h2 id="toc_5">结果展示与说明</h2>

<p>上述作业结束后，我们就可以通过查询输出文件得到我们的统计结果。本次实验统计结果如下：<br/>
<img src="media/14786108252793/14787497512630.jpg" alt=""/><br/>
输出文件如下：<br/>
<img src="media/14786108252793/14787497741393.jpg" alt=""/></p>

<h2 id="toc_6">相关代码</h2>

<p>本次实验相关代码和所用的数据资料，均已上传至码云仓库（OSChina git）地址为：<a href="https://git.oschina.net/cobber/HadoopPractice">HadoopPractice</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网易Java Web微专业Spring-Web框架单元作业]]></title>
    <link href="http://swuzjb.github.io/14773646522828.html"/>
    <updated>2016-10-25T11:04:12+08:00</updated>
    <id>http://swuzjb.github.io/14773646522828.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>完成包含以下功能的Web工程，提供一个接口，该接口可以根据需要（扩展名，Accep头）返回一个HTML文档或者JSON数据，要求：<br/>
返回的JSON数据是一个用户列表，每个用户包含两个信息：用户Id（userId），用户名（userName），最终的数据类似：<br/>
{&quot;userList&quot; : [<br/>
    {<br/>
        &quot;userId&quot;: 1001,<br/>
        &quot;userName&quot;: &quot;test1&quot;<br/>
    },<br/>
    {<br/>
        &quot;userId&quot;: 1002,<br/>
        &quot;userName&quot;: &quot;test2&quot;<br/>
    }<br/>
    ...<br/>
]}<br/>
2. 返回的HTML文档基于FreeMarker生成，内容是一个用户列表的表格，对HTML表格不熟悉的同学可以参考 <a href="http://www.w3school.com.cn/tiy/t.asp?f=html_tables">http://www.w3school.com.cn/tiy/t.asp?f=html_tables</a> 了解；<br/>
3. 以自己能力为基础，返回的数据可以是接口内直接返回的，也可以是从数据库表里查询出来的（加分）；<br/>
4. 尽可能根据项目模板里介绍的内容组织代码及资源。</p>
</blockquote>

<h2 id="toc_0">项目架构</h2>

<p><img src="media/14773646522828/14773699877029.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_1">相关概念</h2>

<h3 id="toc_2">SpringMVC</h3>

<p>SpringMVC是Spring自身提供的一套基于MVC设计理念的开发框架，用于替代安全性较低的Sturts框架</p>

<h3 id="toc_3">JSON</h3>

<p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C、C++、C#、Java、JavaScript、Perl、Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。</p>

<h3 id="toc_4">视图解析器</h3>

<p>控制器在选择好适合处理请求的方法时，传入收到的请求(根据方法参数类型，可能以不同的类型传入)，并且 调用该方法中的逻辑来进行处理(也可以是调用Service来真正处理)。方法逻辑可能也会在参数中添加或者删除数据。处理方法处理完之后，会委派给一个 视图，由该视图来处理方法的返回值。处理程序的返回值并不代表视图的具体实现，可以只是String类型，代表视图名，甚至是void(这时候 Spring MVC可以根据方法名或者控制器名找默认视图)。也不需要担心返回值只是视图名称的话，视图拿不到要显示的数据。因为方法参数对于视图来说也是可以拿到 的。比如说，如果处理方法以Map为参数，那么这个Map对于视图也是可以拿到的。<br/>
返回的视图名称会返回给DispatcherServlet，它会根据一个视图解析器将视图名称解析为一个具体的视图实现。这里说到的视图解析器是一个实现了ViewResolver借口的Bean，它的任务就是返回一个视图的具体实现(HTML、jsonp、json等等)。</p>

<h4 id="toc_5">内容协商视图解析器</h4>

<p>可以根据请求的内容，自动匹配对应的视图解析器，对视图进行解析。</p>

<h2 id="toc_6">作业实现</h2>

<p>我们按照模块图有下自上对本次作业实现进行说明。</p>

<ol>
<li><p>User模型</p>

<pre><code class="language-java">package site.zhanjingbo.course.meta;

public class User {
    private int userId;
    private String userName;

    public int getUserId() {
        return userId;
    }

    public void setUserId(int userId) {
        this.userId = userId;
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }
}
</code></pre></li>
<li><p>UserDao。User数据库访问接口</p>

<pre><code class="language-java">package site.zhanjingbo.course.dao;
import java.util.List;
import site.zhanjingbo.course.meta.User;
public interface UserDao {
    public List&lt;User&gt; getUserList();
}
</code></pre></li>
<li><p>UserDaoMapper。使用Mybatis对UserDao进行实现。</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;site.zhanjingbo.course.dao.UserDao&quot;&gt;
    &lt;resultMap type=&quot;User&quot; id=&quot;UserResult&quot;&gt;
        &lt;result property=&quot;userId&quot; column=&quot;userId&quot; /&gt;
        &lt;result property=&quot;userName&quot; column=&quot;userName&quot; /&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;getUserList&quot; resultMap=&quot;UserResult&quot;&gt;
        select * from user
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre></li>
<li><p>UserService。User的对应业务逻辑层</p>

<pre><code class="language-java">package site.zhanjingbo.course.service.impl;
import java.util.List;
import javax.annotation.Resource;
import org.springframework.stereotype.Service;
import site.zhanjingbo.course.dao.UserDao;
import site.zhanjingbo.course.meta.User;
import site.zhanjingbo.course.service.UserService;  
@Service
public class UserServiceImpl implements UserService {
    @Resource
    private UserDao userDao;
    public List&lt;User&gt; getUserList() {
        return userDao.getUserList();
    }
}
</code></pre></li>
<li><p>UserController。User的控制器层，调用业务逻辑，返回对应视图名称和数据。</p>

<pre><code class="language-java">package site.zhanjingbo.course.web.controller;

import javax.annotation.Resource;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;
import site.zhanjingbo.course.service.UserService;

@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {
    @Resource
    private UserService userService;
    @RequestMapping(&quot;/userList&quot;)
    public ModelAndView getUserList() {
        ModelAndView mav = new ModelAndView();
        mav.setViewName(&quot;userList&quot;);
        mav.addObject(&quot;userList&quot;, userService.getUserList());
        return mav;
    }
}
</code></pre></li>
<li><p>userList.ftl。使用FreeMarker渲染的视图文件</p>

<pre><code class="language-html">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;用户列表&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;table border=&quot;1px&quot;&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;td&gt;userId&lt;/td&gt;
              &lt;td&gt;userName&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;#list userList as user&gt; 
                &lt;tr&gt;
                    &lt;td&gt;${user.userId}&lt;/td&gt; 
                    &lt;td&gt;${user.userName}&lt;/td&gt;
                &lt;/tr&gt;
            &lt;/#list&gt;
          &lt;/tbody&gt;  
        &lt;/table&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre></li>
<li><p>DispatcherServlet的配置文件，主要配置对应View的渲染方案，即内容协商视图响应。</p>

<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd
http://www.springframework.org/schema/mvc
http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

&lt;context:component-scan base-package=&quot;site.zhanjingbo.course.web.controller&quot; /&gt;

&lt;bean id=&quot;contentNegotiationManager&quot;
    class=&quot;org.springframework.web.accept.ContentNegotiationManagerFactoryBean&quot;&gt;
    &lt;!-- 扩展名至mimeType的映射,即 /user.json =&gt; application/json --&gt;
    &lt;property name=&quot;favorPathExtension&quot; value=&quot;true&quot; /&gt;
    &lt;!-- 用于开启 /userinfo/123?format=json 的支持 --&gt;
    &lt;property name=&quot;favorParameter&quot; value=&quot;true&quot; /&gt;
    &lt;property name=&quot;parameterName&quot; value=&quot;format&quot; /&gt;
    &lt;!-- 是否忽略Accept Header --&gt;
    &lt;property name=&quot;ignoreAcceptHeader&quot; value=&quot;false&quot; /&gt;
    &lt;property name=&quot;mediaTypes&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;json&quot; value=&quot;application/json&quot; /&gt;
            &lt;entry key=&quot;xml&quot; value=&quot;application/xml&quot; /&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;!-- 默认的content type --&gt;
    &lt;property name=&quot;defaultContentType&quot; value=&quot;text/html&quot; /&gt;
&lt;/bean&gt;
&lt;!-- freeMarker --&gt;
&lt;bean id=&quot;freemarkerConfig&quot;
    class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;
    &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/freemarker/&quot; /&gt;
&lt;/bean&gt;
&lt;bean
    class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt;
    &lt;property name=&quot;contentNegotiationManager&quot; ref=&quot;contentNegotiationManager&quot; /&gt;
    &lt;property name=&quot;viewResolvers&quot;&gt;
        &lt;list&gt;
            &lt;bean id=&quot;viewResolver&quot;
                class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;
                &lt;property name=&quot;cache&quot; value=&quot;true&quot; /&gt;
                &lt;property name=&quot;prefix&quot; value=&quot;&quot; /&gt;
                &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot; /&gt;
                &lt;property name=&quot;contentType&quot; value=&quot;text/html; charset=utf-8&quot; /&gt;
            &lt;/bean&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;defaultViews&quot;&gt;
        &lt;list&gt;
            &lt;!-- JSON --&gt;
            &lt;bean
                class=&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot; /&gt;
            &lt;!-- XML --&gt;
            &lt;bean class=&quot;org.springframework.web.servlet.view.xml.MarshallingView&quot;&gt;
                &lt;property name=&quot;marshaller&quot;&gt;
                    &lt;bean class=&quot;org.springframework.oxm.xstream.XStreamMarshaller&quot; /&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;/beans&gt;
</code></pre></li>
</ol>

<h2 id="toc_7">结果展示</h2>

<p>为了更好的展示不同URL后缀以及不同Accept头对应的不同返回结果，我们使用curl命令对项目进行请求，观察返回结果。</p>

<ol>
<li><p>无后缀，默认URL</p>

<pre><code>curl http://localhost:8080/SpringHomework5_1/api/user/userList
</code></pre>

<p><img src="media/14773646522828/14773731907095.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>html后缀</p>

<pre><code>http://localhost:8080/SpringHomework5_1/api/user/userList.html
</code></pre>

<p><img src="media/14773646522828/14773756220422.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>JSON后缀</p>

<pre><code>http://localhost:8080/SpringHomework5_1/api/user/userList.json
</code></pre>

<p><img src="media/14773646522828/14773756553739.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>XML后缀</p>

<pre><code>curl http://localhost:8080/SpringHomework5_1/api/user/userList.xml
</code></pre>

<p><img src="media/14773646522828/14773755762050.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>JSON头</p>

<pre><code>curl -H &#39;Accept:application/json&#39; http://localhost:8080/SpringHomework5_1/api/user/userList
</code></pre>

<p><img src="media/14773646522828/14773757816596.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>XML头</p>

<pre><code>curl -H &#39;Accept:application/xml&#39; http://localhost:8080/SpringHomework5_1/api/user/userList
</code></pre>

<p><img src="media/14773646522828/14773757471295.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
</ol>

<h2 id="toc_8">总结</h2>

<p>虽然完成了目标任务，但是对于Spring整合其它框架以及SpringMVC的相关功能的具体熟悉还需要进一步学习。</p>

<h2 id="toc_9">代码</h2>

<p><a href="http://git.oschina.net/cobber/SpringHomework5_1">Demo</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网易Java Web微专业Spring-数据访问单元作业]]></title>
    <link href="http://swuzjb.github.io/14766902757975.html"/>
    <updated>2016-10-17T15:44:35+08:00</updated>
    <id>http://swuzjb.github.io/14766902757975.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>根据本单介绍的Spring JDBC，事务管理，MyBatis等内容，分别使用Spring JDBC及MyBatis提供一个转帐服务（保证事务），提供一个transferMoney接口：<br/>
transferMoney(Long srcUserId, Long targetUserId, double count)；// srcUserId及targetUserId为转帐用户标识</p>
</blockquote>

<h2 id="toc_0">相关表结构</h2>

<table>
<thead>
<tr>
<th style="text-align: center">列名</th>
<th style="text-align: center">类型</th>
<th style="text-align: center">备注</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">userId</td>
<td style="text-align: center">Long</td>
<td style="text-align: center">唯一用户标识</td>
</tr>
<tr>
<td style="text-align: center">balance</td>
<td style="text-align: center">double</td>
<td style="text-align: center">账户余额</td>
</tr>
</tbody>
</table>

<h2 id="toc_1">程序架构</h2>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-10-17-14766906872633.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h3 id="toc_2">说明</h3>

<ul>
<li>UserDao 为统一的User数据库访问接口</li>
<li>UserService 为外部服务提供直接调用的接口</li>
</ul>

<h2 id="toc_3">实现说明</h2>

<ol>
<li><p>application-config配置，相关配置均有注释说明。其中事务的处理可以采用注解或AOP的XML配置方式，下列代码均有体现。</p>

<pre><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
xmlns:mybatis=&quot;http://mybatis.org/schema/mybatis-spring&quot;
xsi:schemaLocation=&quot;
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop-2.0.xsd
http://www.springframework.org/schema/tx
http://www.springframework.org/schema/tx/spring-tx.xsd
http://mybatis.org/schema/mybatis-spring
http://mybatis.org/schema/mybatis-spring.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!-- 数据库连接配置文件导入 --&gt;
    &lt;context:property-placeholder location=&quot;db.properties&quot; /&gt;
    &lt;!-- 扫描注解 --&gt;
    &lt;context:component-scan base-package=&quot;site.zhanjingbo&quot; /&gt;
    &lt;!-- 使用注解声明事务 --&gt;
    &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; /&gt;
    &lt;!-- MyBatis的自动扫描 --&gt;
    &lt;mybatis:scan base-package=&quot;site.zhanjingbo&quot; /&gt;

    &lt;!-- 数据源配置 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;
        destroy-method=&quot;close&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driverClassName}&quot; /&gt;
        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;
        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
    &lt;/bean&gt;
    &lt;!-- 事务管理器 --&gt;
    &lt;bean id=&quot;txManager&quot;
        class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- 使用AOP-XML声明事务 --&gt;
    &lt;!-- &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt; &lt;tx:attributes&gt; 
        &lt;tx:method name=&quot;transfer*&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; 
        &lt;aop:pointcut id=&quot;daoOperation&quot; expression=&quot;execution(* site.zhanjingbo.service.*.*(..))&quot; 
        /&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;daoOperation&quot; /&gt; &lt;/aop:config&gt; --&gt;

    &lt;!-- 配置myBatis的sqlSessionFactory --&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;!-- 自动扫描mappers.xml文件 --&gt;
        &lt;property name=&quot;mapperLocations&quot;
            value=&quot;classpath:site/zhanjingbo/dao/myBatiesImpl/*.xml&quot;&gt;&lt;/property&gt;
        &lt;!-- myBatis配置文件 --&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre></li>
<li><p>UserDao的接口声明</p>

<pre><code class="language-java">public interface UserDao {
    public void reset();
    public List&lt;User&gt; getUserList();
    public void updateMoney(Long userId, double count);
}
</code></pre></li>
<li><p>UserDao的JDBC实现，其中JdbcTemplete由Spring进行装载。</p>

<pre><code class="language-java">@Component(&quot;UserJDBCDao&quot;)
public class UserDaoJDBCImpl implements UserDao {
    private JdbcTemplate jdbcTemplate;
    @Autowired
    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }
    public void reset() {
        this.jdbcTemplate.execute(&quot;update UserBalance set balance=1000&quot;);
    }
    public List&lt;User&gt; getUserList() {
        return this.jdbcTemplate.query(&quot;select * from UserBalance&quot;, new RowMapper&lt;User&gt;() {
            public User mapRow(ResultSet rs, int rowNum) throws SQLException {
                User user = new User();
                user.setUserId(rs.getLong(&quot;userId&quot;));
                user.setBalance(rs.getDouble(&quot;balance&quot;));
                return user;
            }
        });
    }
    public void updateMoney(Long userId, double count) {
        this.jdbcTemplate.update(&quot;update UserBalance set balance=balance+? where userId=?&quot;, count, userId);
    }
}
</code></pre></li>
<li><p>UserDao的MyBatis实现，采用Mapper.xml的方式进行声明实现</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;site.zhanjingbo.dao.UserDao&quot;&gt;
    &lt;resultMap type=&quot;User&quot; id=&quot;UserResult&quot;&gt;
        &lt;result property=&quot;userId&quot; column=&quot;userId&quot; /&gt;
        &lt;result property=&quot;balance&quot; column=&quot;balance&quot; /&gt;
    &lt;/resultMap&gt;
    &lt;update id=&quot;reset&quot;&gt;
        update UserBalance set balance=500
    &lt;/update&gt;

    &lt;select id=&quot;getUserList&quot; resultMap=&quot;UserResult&quot;&gt;
        select * from userBalance
    &lt;/select&gt;
    &lt;update id=&quot;updateMoney&quot;&gt;
        update UserBalance set balance=balance+#{param2} where userId=#{param1}
    &lt;/update&gt;
&lt;/mapper&gt; 
</code></pre></li>
<li><p>UserService的实现，其中主要为transferMoney方法的实现。由于该方法的业务逻辑，该方法应该确保事务性。采用注解的方式声明事务，则在该方法前添加<code>@Transactional</code>注解。采用配置文件方式对事务进行声明参考第1小节中的配置文件。</p>

<pre><code class="language-java">@Transactional(propagation = Propagation.REQUIRED)
public void transferMoney(Long srcUserId, Long targetUserId, double count) {
    userDao.updateMoney(srcUserId, 0 - count);
    userDao.updateMoney(targetUserId, count);
}
</code></pre>

<p>在UserService的实现过程中，我们需要调用UserDao的具体实例，在本次作业过程中我们采用了两种方法来实现UserDao。在测试不同的实现方式时只需要修改注入的UserDao的具体实例就可完成。为了明显区分两种实例的实现，我们在reset的方法中做了区别。其中JDBC实现方式Reset之后balance的值为1000，MyBatis实现方式reset之后的balance值为500。</p></li>
<li><p>Application调用代码</p>

<pre><code class="language-java">    public static void main(String[] args) {
        //加载Spring
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application-context.xml&quot;);
        //获取UserService实例
        UserService userService = applicationContext.getBean(UserService.class);
        userService.reset();
        try {
            userService.transferMoney(new Long(10000), new Long(10001), 100);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        List&lt;User&gt; userList = userService.getUserList();
        for (User user : userList) {
            System.out.println(user);
        }

        ((ConfigurableApplicationContext) applicationContext).close();
    }
</code></pre></li>
</ol>

<h2 id="toc_4">运行结果</h2>

<h3 id="toc_5">JDBC运行结果</h3>

<ol>
<li><p>正常执行<br/>
<img src="media/14766902757975/14766935577292.jpg" alt=""/></p></li>
<li><p>执行中异常，打印异常信息，数据回滚<br/>
<img src="media/14766902757975/14766935207561.jpg" alt=""/></p></li>
</ol>

<h3 id="toc_6">MyBatis运行结果</h3>

<ol>
<li><p>正常执行<br/>
<img src="media/14766902757975/14766936235948.jpg" alt=""/></p></li>
<li><p>执行中异常，打印异常信息，数据回滚<br/>
<img src="media/14766902757975/14766936425847.jpg" alt=""/></p></li>
</ol>

<h2 id="toc_7">程序地址</h2>

<p><a href="http://git.oschina.net/cobber/SpringHomework4_1">SpringHomework4_1</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网易Java Web微专业Spring-AOP容器作业]]></title>
    <link href="http://swuzjb.github.io/14759932535473.html"/>
    <updated>2016-10-09T14:07:33+08:00</updated>
    <id>http://swuzjb.github.io/14759932535473.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>完成一个基本的应用，提供若干个Service（&gt;=2），每个Service提供基本的增删查改的接口（实现随意，比如输出一行信息），通过AOP保证所有所有的Service接口在正常调用返回后以及抛出异常时（Service接口模拟），打出如下信息：函数名称，函数参数，并说明发生的事件：正常返回或者抛出异常。</p>
</blockquote>

<h2 id="toc_0">AOP模式示意图</h2>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-10-09-14759941824050.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_1">作业描述</h2>

<p>本次作业我设计了两个Service，分别是UserService和ProductService，每个Service分别提供增删改查操作（Print语句代替业务逻辑）。</p>

<ol>
<li><p>配置Spring配置文件，加入AOP相关的xsd文件。并配置AOP。</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd
http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop-2.0.xsd&quot;&gt;

    &lt;!-- 引入AOP --&gt;
    &lt;aop:aspectj-autoproxy /&gt;
    &lt;!-- 自动扫描annotation配置 --&gt;
    &lt;context:component-scan base-package=&quot;site.zhanjingbo&quot; /&gt;

    &lt;!-- 自定义的日志切面声明 --&gt;
    &lt;bean id=&quot;logAspect&quot; class=&quot;site.zhanjingbo.aspect.LogAspect&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre></li>
<li><p>编写Service。以UserService为例。</p>

<pre><code class="language-java">package site.zhanjingbo.service;
import org.springframework.stereotype.Component;

@Component
public class UserService {
    public void add(String username) throws Exception {
        System.out.println(&quot;添加用户:&quot; + username);
        throw new Exception(&quot;测试&quot;);
    }
    public void edit(String username) {
        System.out.println(&quot;添加用户:&quot; + username);
    }
    public void del(String username) {
        System.out.println(&quot;删除用户:&quot; + username);
    }
    public void find(String username) {
        System.out.println(&quot;查询用户:&quot; + username);
    }
}
</code></pre></li>
<li><p>编写Aspect，完成切面方法。</p>

<pre><code class="language-java">package site.zhanjingbo.aspect;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Aspect;

@Aspect
public class LogAspect {

    /**
     * 正常返回时调用
     * @param jp调用点信息
     */
    @AfterReturning(&quot;execution(* site.zhanjingbo.service.*.*(..))&quot;)
    public void logAfterReturning(JoinPoint jp){
        String className = jp.getSignature().getDeclaringTypeName();
        String methodName = jp.getSignature().getName();
        System.out.print(&quot;正常返回Log:调用&quot;+className+&quot;的&quot;+methodName+&quot;方法,参数为：&quot;);
        for (Object obj : jp.getArgs()) {
            System.out.print(obj.toString());
        }
        System.out.println(&quot;&quot;);
    }
    /**
     * 抛出异常返回时调用
     * @param jp 调用点信息
     * @param ex 异常信息
     */
    @AfterThrowing(pointcut=&quot;execution(* site.zhanjingbo.service.*.*(..))&quot;,throwing=&quot;ex&quot;)
    public void logAfterThrowing(JoinPoint jp,Exception ex){
        String className = jp.getSignature().getDeclaringTypeName();
        String methodName = jp.getSignature().getName();
        System.out.print(&quot;异常Log:调用&quot;+className+&quot;的&quot;+methodName+&quot;方法,参数为：&quot;);
        for (Object obj : jp.getArgs()) {
            System.out.print(obj.toString());
        }
        System.out.println(&quot;。抛出异常:&quot;+ex.getMessage()+&quot;!&quot;);
    }
}
</code></pre></li>
<li><p>编写模拟调用的Application类，来模拟业务。</p>

<pre><code class="language-java">public class Application {
    public static void main(String[] args){
        //加载Spring相关配置文件
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application-context.xml&quot;);

        //获取UserService实例
        UserService userService = applicationContext.getBean(UserService.class);
        //调用方法
        try {
            userService.add(&quot;ZhangSan&quot;);
        } catch (Exception e) {

        }
        //获取ProductService实例
        ProductService productService = applicationContext.getBean(ProductService.class);
        //调用方法
        productService.del(&quot;Pen&quot;);

        ((ConfigurableApplicationContext)applicationContext).close();
    }
}
</code></pre></li>
</ol>

<h2 id="toc_2">程序运行结果</h2>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-10-09-14759958614665.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<p>Service的方法正常调用或调用异常结束后，完成对应的切面方法响应，输出对应的Log。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网易Java Web微专业Spring-IoC容器作业]]></title>
    <link href="http://swuzjb.github.io/14748062329626.html"/>
    <updated>2016-09-25T20:23:52+08:00</updated>
    <id>http://swuzjb.github.io/14748062329626.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>假设我们有个应用（Application），它包含一个写文件的服务（FileWriterService），该服务在创建时会创建并打开一个文件，销毁时关闭该文件，并且该服务包含一个write(String content)方法：会将content写入到文件中，要求：<br/>
1. 使用Spring IoC的相关内容组织该程序；<br/>
2. 文件路径通过配置文件（properties）指定；<br/>
基本要求：必须附加一个项目说明文档，说明每个功能点对应程序的运行结果（截图），项目的接口说明或者关键代码（不要把全部代码贴出来）等可以反映项目结果的内容。提交作业的时候必须有这个项目说明文档，否则会影响最终评分</p>
</blockquote>

<h2 id="toc_0">程序结构</h2>

<p>根据题目要求，程序采用IoC的方式进行组织和构建。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-09-27-14749583867443.jpg" alt=""/></p>

<h2 id="toc_1">核心代码与结果</h2>

<ol>
<li><p>FileWriterService接口定义</p>

<pre><code class="language-java">public interface FileWirterService {
    public void write(String content);
}
</code></pre></li>
<li><p>FileWriterService实现类FileWriterServiceImpl</p>

<pre><code class="language-java">//声明一个Bean的id
@Component(&quot;fileWriterService&quot;)
public class FileWirterServiceImpl implements FileWirterService{

    //通过配置文件获取参数，注入到FileWirterServiceImpl中
    @Value(&quot;${filePath}&quot;)
    private File file;
    private FileWriter fw;
    //创建时调用，打开一个文件，获取输出流
    @PostConstruct
    public void init() {
        try {
            //判断文件是否存在，如不存在则创建文件
            if (!file.exists()) {
                file.createNewFile();
            }
            //打开文件
            fw = new FileWriter(file, true);
            System.out.println(&quot;打开文件&quot;);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public void write(String content) {
        try {
            //向文件中写入内容，并换行
            fw.write(content+&quot;\n&quot;);
            System.out.println(&quot;文件写入:&quot;+content);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    //销毁前调用，关闭文件输出流，释放文件
    @PreDestroy
    public void destory() {
        try {
            //关闭文件的输出流
            if (fw != null) {
                fw.flush();
                fw.close();
            }
            System.out.println(&quot;关闭文件&quot;);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre></li>
<li><p>读取配置文件获取FilePath参数。</p>

<ol>
<li>建立配置文件：<code>writer.properties</code>。写入配置<code>filePath=/Users/zhanjingbo/Desktop/spring.txt</code>，记录文件路径。</li>
<li><p>在Spring的<code>application-context.xml</code>中加入读取配置文件的配置。</p>

<pre><code class="language-xml">&lt;bean id=&quot;writerServiceProperties&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;
    &lt;property name=&quot;location&quot; value=&quot;classpath:writer.properties&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre></li>
</ol></li>
<li><p>编写Application的主类，实现main方法。</p>

<pre><code class="language-java">public static void main(String[] args) {
    //加载spring的配置文件，创建容器
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application-context.xml&quot;);
    //通过Bean的id来对FileWriterService进行注入
    FileWirterService fileWriterService = applicationContext.getBean(&quot;fileWriterService&quot;,FileWirterService.class);
    //调用业务逻辑
    fileWriterService.write(&quot;Hello World&quot;);
    //关闭容器
    ((ConfigurableApplicationContext)applicationContext).close();
}
</code></pre></li>
<li><p>结果展示</p>

<ul>
<li><p>控制台的相关输出<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-09-27-14749592874889.jpg" alt=""/></p></li>
<li><p>文件写入情况<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-09-27-14749593122837.jpg" alt=""/></p></li>
</ul></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据库连接池]]></title>
    <link href="http://swuzjb.github.io/14729975970385.html"/>
    <updated>2016-09-04T21:59:57+08:00</updated>
    <id>http://swuzjb.github.io/14729975970385.html</id>
    <content type="html"><![CDATA[
<p>建立数据库连接是一个非常耗时耗资源的行为，在大量并发的情况下，会降低服务器性能。同时，如果连接数超过最大的数据库允许连接值，数据库会直接抛出异常，非常不友好。为了解决上述的问题，我们引入了数据连接池的概念。<br/>
数据库连接池类似于线程池，通过连接池预先同数据库建立一些连接，放在内存中，应用程序需要建立数据库连接时直接到连接池中申请一个就行，用完后再放回去，避免频繁的新建和关闭连接对象</p>

<h2 id="toc_0">DBCP</h2>

<p>DBCP（DataBase Connection Pool）数据库连接池，是java数据库连接池的一种，由Apache开发，通过数据库连接池，可以让程序自动管理数据库连接的释放和断开。同时DBCP也是tomcat所使用的连接池组价。</p>

<h3 id="toc_1">DBCP的简单使用DEMO</h3>

<pre><code class="language-java">package site.zhanjingbo.HelloDB;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import org.apache.commons.dbcp2.BasicDataSource;

public class HelloDBCP {

    static final String DRIVER_NAME = &quot;com.mysql.jdbc.Driver&quot;;
    static final String DB_URL = &quot;jdbc:mysql://localhost:3307/cloud_study?characterEncoding=utf8&quot;;
    static final String DB_USER = &quot;root&quot;;
    static final String DB_PASSWORD = &quot;&quot;;

    public static BasicDataSource ds = null;

    public static void init() {
        ds = new BasicDataSource();
        ds.setDriverClassName(DRIVER_NAME);
        ds.setUsername(DB_USER);
        ds.setUrl(DB_URL);
        ds.setPassword(DB_PASSWORD);
    }

    public static void search() {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;

        try {
            conn = ds.getConnection();
            stmt = conn.createStatement();
            rs = stmt.executeQuery(&quot;select username from user&quot;);
            while (rs.next()) {
                System.out.println(&quot;Hello &quot; + rs.getString(&quot;username&quot;));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }
                if (stmt != null) {
                    stmt.close();
                }
                if (conn != null) {
                    conn.close();
                }
            } catch (SQLException e) {
            }
        }
    }

    public static void main(String[] args) {
        init();
        search();
    }
}

</code></pre>

<p>通过上述的demo可见，使用DBCP对数据进行访问实际操作与JDBC并无不同。唯一的区别就是Connection对象的获取是通过BasicDataSource对象来获得而不是DriverManage对象。<br/>
注：释放Connection对象同样是调用Connection的close()方法，不过这里的close()方法是被DBCP重写过的，是将连接对象重新放回连接池，而不是释放销毁。</p>

<h3 id="toc_2">DBCP高级API</h3>

<p>为了更好的设置和使用DBCP连接池，使数据库连接池效率更高，DBCP还提供了多个API接口供我们使用。</p>

<table>
<thead>
<tr>
<th style="text-align: center">接口</th>
<th style="text-align: center">作用</th>
<th style="text-align: center">建议</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.setInitialSize()</td>
<td style="text-align: center">设置初始化连接数</td>
<td style="text-align: center">设置为项目预期访问量</td>
</tr>
<tr>
<td style="text-align: center">.setMaxTotal()</td>
<td style="text-align: center">最大连接数</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">ds.setMaxWaitMillis()</td>
<td style="text-align: center">线程最大等待时间</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">.setMaxIdle()</td>
<td style="text-align: center">最大空闲连接数</td>
<td style="text-align: center">与MinIdle相同</td>
</tr>
<tr>
<td style="text-align: center">.setMinIdle()</td>
<td style="text-align: center">最小空闲连接数</td>
<td style="text-align: center">与MaxIdle相同</td>
</tr>
</tbody>
</table>

<h4 id="toc_3">DBCP定期检查</h4>

<p>为了保证连接池中的连接都是有效的，我们需要定期的对连接池中的连接进行检查，对失效的连接及时进行关闭。相关API如下：</p>

<table>
<thead>
<tr>
<th style="text-align: center">API</th>
<th style="text-align: center">作用</th>
<th style="text-align: center">建议</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.setTestWhileIdle(true)</td>
<td style="text-align: center">是否开启定期检查</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">.setMinEvictableIdle</td>
<td style="text-align: center">最小空闲时间，超过该值被销毁</td>
<td style="text-align: center">小于服务器连接失效时间(一般为8小时)</td>
</tr>
<tr>
<td style="text-align: center">.setTimeBetweenEvictionRunsMillis</td>
<td style="text-align: center">检查时间间隔</td>
<td style="text-align: center"></td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cookie与Session]]></title>
    <link href="http://swuzjb.github.io/14728168486763.html"/>
    <updated>2016-09-02T19:47:28+08:00</updated>
    <id>http://swuzjb.github.io/14728168486763.html</id>
    <content type="html"><![CDATA[
<p>在开发过程中我们经常需要保存一些状态信息如用户登录状态等，但是由于HTTP协议的无状态特性，这些功能无法直接实现。所以我们引入了Cookie与Session这两个概念用于保存一些信息。</p>

<h2 id="toc_0">Cookie</h2>

<p>Cookie的作用通俗地说就是当一个用户通过HTTP协议访问一个服务器的时候，这个服务器会将一些Key/Value键值对返回给客户端浏览器，并给这些数据加上一些限制条件，在条件符合时这个用户下次访问这个服务器的时候，数据又被完整地带回给服务器。</p>

<h3 id="toc_1">Cookie如何工作</h3>

<ol>
<li>用户通过浏览器请求某个Servlet，在请求过程中如果本地有该站点的Cookie信息，浏览器会将这些信息放入request请求的请求头中；</li>
<li>在Servlet中可以通过<code>request.getCookies();</code>获取当前的Cookie数组；</li>
<li>根据自己的业务需求，新建Cookie对象实例，分别设置key和value的值；</li>
<li>将需要添加的Cookie实例通过<code>response.addCookie();</code>方法添加到响应当中返回客户端，客户端根据Cookie的生命周期（MaxAge属性）来选择是否将此Cookie写入硬盘当中。</li>
</ol>

<h3 id="toc_2">DemoCode</h3>

<pre><code class="language-java">    String getCookie(Cookie[] cookies, String key) { 
        if (cookies != null) { 
            for (Cookie cookie : cookies) { 
                if (cookie.getName().equals(key)) { 
                    return cookie.getValue(); 
                } 
            } 
        } 
        return null; 
    } 

    @Override 
    public void doGet(HttpServletRequest request, 
                      HttpServletResponse response) 
            throws IOException, ServletException { 
        Cookie[] cookies = request.getCookies(); 
        String userName = getCookie(cookies, &quot;userName&quot;); 
        String userAge = getCookie(cookies, &quot;userAge&quot;); 
        if (userName == null) { 
            response.addCookie(new Cookie(&quot;userName&quot;, &quot;user&quot;)); 
        } 
        if (userAge == null) { 
            response.addCookie(new Cookie(&quot;userAge&quot;, &quot;28&quot;)); 
        } 
         
 }
</code></pre>

<h3 id="toc_3">使用Cookie的限制</h3>

<p>Cookie是 HTTP 协议头中的一个字段，虽然HTTP协议本身对这个字段并没有多少限制，但是 Cookie 最终还是存储在浏览器里，所以不同的浏览器对Cookie的存储都有一些限制，下表是一些通常的浏览器对 Cookie的大小和数量的限制。</p>

<table>
<thead>
<tr>
<th style="text-align: center">浏览器版本</th>
<th style="text-align: center">Cookie数限制（个/域名）</th>
<th style="text-align: center">总大小限制</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">IE6</td>
<td style="text-align: center">20</td>
<td style="text-align: center">4095B</td>
</tr>
<tr>
<td style="text-align: center">IE7、8、9</td>
<td style="text-align: center">50</td>
<td style="text-align: center">4095B</td>
</tr>
<tr>
<td style="text-align: center">Chrome</td>
<td style="text-align: center">50</td>
<td style="text-align: center">&gt;8000</td>
</tr>
<tr>
<td style="text-align: center">FireFox</td>
<td style="text-align: center">50</td>
<td style="text-align: center">4097B</td>
</tr>
</tbody>
</table>

<hr/>

<h2 id="toc_4">Session</h2>

<p>前面已经介绍了 Cookie 可以让服务端程序跟踪每个客户端的访问，但是每次客户端的访问都必须传回这些 Cookie，如果 Cookie 很多，这无形地增加了客户端与服务端的数据传输量，而 Session 的出现正是为了解决这个问题。</p>

<h3 id="toc_5">Session如何工作</h3>

<ol>
<li>session是基于Cookie的，同一个客户端每次和服务端交互时，不需要每次都传回所有的 Cookie 值，而是只要传回一个 ID，这个 ID 是客户端第一次访问服务器的时候生成的，而且每个客户端是唯一的。这样每个客户端就有了一个唯一的 ID，客户端只要传回这个 ID 就行了，这个 ID 通常是 NANE 为 JSESIONID 的一个 Cookie；</li>
<li>有了Session ID服务端就可以创建HttpSession对象了，第一次触发通过<code>request.getSession()</code>方法。如果当前的Session ID 还没有对应的HttpSession对象，那么就创建一个新的，并将这个对象加到org.apache.catalina.Manager的sessions容器中保存。Manager类将管理所有Session的生命周期，如果该session存在则直接返回；</li>
<li>直接操作session对象对key/value键值对进行存储，数据保存在服务器端，可以通过api手工操作其声明周期</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[简述HTTP请求过程]]></title>
    <link href="http://swuzjb.github.io/14720186733605.html"/>
    <updated>2016-08-24T14:04:33+08:00</updated>
    <id>http://swuzjb.github.io/14720186733605.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>HTTP请求是web程序服务的基础，要想写好web程序，必然要对http请求的过程进行掌握。</p>
</blockquote>

<h2 id="toc_0">HTTP请求步骤</h2>

<ol>
<li>如果是以域名形式进行web访问，则浏览器会先通过DNS服务将域名转化为对应的IP地址，为下一步访问做准备。</li>
<li>通过IP地址与服务器建立TCP连接</li>
<li>客户端向服务器端发送Request请求</li>
<li>服务器端向客户端发送Response响应</li>
<li>服务器端关闭TCP连接。一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：<code>Connection:keep-alive</code>。TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 </li>
</ol>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-08-24-14720197735370.jpg" alt=""/></p>

<h2 id="toc_1">HTTP请求头,响应头字段</h2>

<h3 id="toc_2">请求头</h3>

<ul>
<li>Accept: text/html, image/* ：客户机支持的数据类型</li>
<li>Accept-Charset: UTF-8 ：客户机采用的编码</li>
<li>Accept-Encoding: gzip,compress:客户机支持的数据压缩格式</li>
<li>Accept-Language: en-us,zh-cn:客户机的语言环境</li>
<li>Host: localhost:8080 :访问的主机名</li>
<li>If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT : 资源的缓存时间,用以判断服务器上的资源是否发生变化</li>
<li>Referer: <a href="http://www.zhanjingbo.site">http://www.zhanjingbo.site</a> : 从哪个页面跳转来访问资源的,用以实现防盗链</li>
<li>User-Agent: Mozilla/4.0 (compatible;MSIE 5.5;Windows NT 5.0):客户机的软件环境</li>
<li>Connection: close/Keep-Alive:请求结束后,是关闭连接还是保持连接</li>
<li>Date: Tue, 11 Jul 2000 18:23:51 GMT当前请求时间</li>
<li>Range:指示服务器只传输一部分web资源.可以用来实现断点续传功能

<ul>
<li>Range字段可以通过3种格式设置要传输的字节范围:</li>
<li>Range: bytes=1000-2000:传输范围从1000到2000字节</li>
<li>Range: bytes=1000-:传输第1000个字节以后的所有内容</li>
<li>Range: bytes=10000:传输最后1000个字节</li>
</ul></li>
</ul>

<h3 id="toc_3">响应头</h3>

<ul>
<li>Location：这个头配合302状态码使用，重定向地址</li>
<li>Server:Apache-Coyote/1.1:服务器类的类型</li>
<li>Content-Encoding：服务器通过这个头，数据压缩的格式</li>
<li>Content-Type：服务器通过这个头告诉浏览器送回数据的类型</li>
<li>Refresh：服务器通过这个头，告诉浏览器隔多长时间刷新一次</li>
<li>Connection:keep-alive\close:访问完后的状态</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java康复性训练——SpringMVC]]></title>
    <link href="http://swuzjb.github.io/14693288315265.html"/>
    <updated>2016-07-24T10:53:51+08:00</updated>
    <id>http://swuzjb.github.io/14693288315265.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>SpringMVC是一套功能强大，性能强悍且使用方便的优秀MVC框架</p>
</blockquote>

<h2 id="toc_0">SpringMVC-HelloWorld</h2>

<ol>
<li>导入相关jar包</li>
<li><p>配置web.xml文件，设置全局拦截器。拦截所有请求，转发给SpringMVC</p>

<pre><code class="language-xml">&lt;servlet&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre></li>
<li><p>添加SpringMVC配置文件spring-mvc.xml</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!-- 使用注解的包，包括子集 --&gt;
    &lt;context:component-scan base-package=&quot;site.zhanjingbo&quot;/&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean id=&quot;viewResolver&quot;
        class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre></li>
<li><p>添加控制器HelloContorller</p>

<pre><code class="language-java">package site.zhanjingbo.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HelloController {

    @RequestMapping(&quot;/hello&quot;)
    public String hello(Model model){
        model.addAttribute(&quot;message&quot;, &quot;HelloWorld!&quot;);
        return &quot;hello&quot;;
    }
}
</code></pre></li>
<li><p>在/WEB-INF/jsp/下建立显示返回页面hello.jsp</p>

<pre><code class="language-html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
${message }
&lt;/body&gt;
&lt;/html&gt;
</code></pre></li>
<li><p>完成。启动Tomcat，访问<a href="http://localhost:8080/SpringMVC/hello.do">http://localhost:8080/SpringMVC/hello.do</a>  查看<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-07-24-14693326495259.jpg" alt=""/></p></li>
</ol>

<h2 id="toc_1">SpringMVC控制器</h2>

<ul>
<li>@RequestMapping：用于指定方法的响应URL或模块URL</li>
<li>@RequestParam：绑定提交参数与控制器方法参数的注解。<code>@RequestParam(value=&quot;&quot;,required=true/false)</code></li>
<li>ModelAndView:作为控制器的返回值类型，返回模型与视图</li>
<li>SpringMVC对象属性自动封装:SpringMVC可以根据表单传入的数据自动封装控制器参数对象</li>
<li><p>SpringMVC POST请求中文乱码:在web.xml中添加过滤器</p>

<pre><code class="language-xml">&lt;!-- 编码过滤器 --&gt;
&lt;filter&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;async-supported&gt;true&lt;/async-supported&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre></li>
<li><p>Controller内部转发与重定向</p>

<ul>
<li>转发：<code>forward:</code></li>
<li>重定向:<code>redirect:</code></li>
</ul></li>
<li><p>SpringMVC对Servlet API的支持</p>

<ul>
<li>只需要在控制器方法的参数列表中添加HttpServletRequest、HttpServletResponse参数即可自动注入实例对象。</li>
</ul></li>
<li><p>SpringMVC对json的支持：这个有很多实例，建议直接上搜索引擎。</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
