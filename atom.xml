<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Zhan's Blog]]></title>
  <link href="http://swuzjb.github.io/atom.xml" rel="self"/>
  <link href="http://swuzjb.github.io/"/>
  <updated>2016-12-07T22:51:09+08:00</updated>
  <id>http://swuzjb.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Hadoop搭建实例]]></title>
    <link href="http://swuzjb.github.io/14786108252793.html"/>
    <updated>2016-11-08T21:13:45+08:00</updated>
    <id>http://swuzjb.github.io/14786108252793.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>本次课程要求自主搭建Hadoop集群环境，并进行MapReduce作业操作<br/>
本文以统计知乎用户地域分布情况为例进行统计展示</p>
</blockquote>

<h2 id="toc_0">数据获取与格式说明</h2>

<h3 id="toc_1">数据获取</h3>

<p>实验数据采用爬虫方式从知乎进行爬取，并保存进入数据库，总数据量3383054条。为了后续处理方便，我们将数据从数据库中倒成csv文件进行存储。<br/>
数据爬取代码：<a href="https://github.com/wycm/mycrawler">知乎爬虫</a></p>

<h3 id="toc_2">数据格式</h3>

<p>导出的数据格式为：<code>id,name,headline,gender,school,major,address,industry,company,job</code><br/>
<img src="media/14786108252793/14786149854526.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_3">Hadoop集群搭建</h2>

<p>Hadoop是一个由Apache基金会所开发的分布式系统基础架构。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。<br/>
本次课程实例基于ubuntu12.04、jdk1.8.111、hadoop2.7.3进行说明，其中ubuntu服务器以虚拟机的形式搭建。</p>

<ol>
<li><p>ubuntu虚拟机搭建</p>

<p>虚拟机创建的步骤在本文中不加以介绍，如有需要请自行百度。ps.为了简便操作，我们可以先创建并配置一台虚拟机然后进行克隆。为了简便操作，可以使用<code>sudo apt-get install ubuntu-desktop</code>安装ubuntu的图形操作界面。</p></li>
<li><p>建立软件目录</p>

<p>为了后续更好的管理我们按照的软件。我们使用mkdir命令，建立软件的安装目录。命令：<code>sudo mkdir /usr/soft</code></p></li>
<li><p>jdk的安装与环境变量设置</p>

<ol>
<li>首先我们从Oracle的官网上下载jdk的压缩文件。下载地址：<a href="http://download.oracle.com/otn-pub/java/jdk/8u111-b14/jdk-8u111-linux-x64.tar.gz">jdk</a>;</li>
<li>使用<code>tar -xzvf 文件名</code>对安装包进行解压;</li>
<li>将解压后的文件夹移至上一步我们建立的软件安装目录。<code>mv jdk1.8.0_111/ /usr/soft</code></li>
<li><p>设置java所需要的环境变量:</p>

<ol>
<li>打开配置文件 <code>sudo vi /etc/profile</code>；</li>
<li>在配置文件中加入<code>export JAVA_HOME=&quot;/usr/soft/jdk1.8.0_111&quot;</code>；</li>
<li>在配置文件中加入<code>export PATH=&quot;$PATH:$JAVA_HOME/bin&quot;</code>；</li>
<li>保存配置文件退出；</li>
<li>使用source命令让配置文件生效，<code>source /etc/profile</code></li>
</ol></li>
<li><p>调用<code>javac -version</code>命令，检查配置是否生效,安装是否成功。</p></li>
</ol></li>
<li><p>Hadoop的安装与环境变量设置</p>

<ol>
<li>从Apache Hadoop网站上下载对应的Hadoop安装包。下载地址：<a href="http://mirrors.cnnic.cn/apache/hadoop/common/hadoop-2.7.3/hadoop-2.7.3.tar.gz">Hadoop2.7.3</a>；</li>
<li>使用<code>tar -xzvf 文件名</code>对安装包进行解压;</li>
<li>将解压后的文件夹移至上一步我们建立的软件安装目录。<code>mv Hadoop-2.7.3 /usr/soft</code></li>
<li>打开配置文件 <code>sudo vi /etc/profile</code>；</li>
<li>在配置文件中加入<code>export PATH=&quot;$PATH:$JAVA_HOME/bin:/usr/soft/hadoop-2.7.3/bin:/usr/soft/hadoop-2.7.3/sbin&quot;</code>；</li>
<li>保存配置文件退出；</li>
<li>使用source命令让配置文件生效，<code>source /etc/profile</code></li>
<li>调用<code>Hadoop version</code>命令，检查配置是否生效,安装是否成功。</li>
</ol></li>
<li><p>SSH免密码登录配置</p>

<ol>
<li>使用<code>sudo apt-get install ssh</code>安装完整的ssh客户端；</li>
<li>使用<code>ssh-keygen -t rsa -P &#39;&#39; -f ~/.ssh/id_rsa</code>生成公私钥；</li>
<li>使用<code>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code>将公钥复制；</li>
<li>使用<code>ssh localhost</code>命令检验是否可以免密码登录系统。</li>
</ol></li>
<li><p>修改服务器的名称</p>

<ol>
<li>使用<code>sudo vi /etc/hostname</code>,修改服务器的名称</li>
<li>重启服务器使配置生效</li>
</ol></li>
<li><p>配置Hadoop配置文件</p>

<p>Hadoop的配置文件位于其安装目录下的etc/hadoop/目录下</p>

<ol>
<li><p>修改yarn-site.xml，内容如下（master代表主服务器名）：</p>

<pre><code class="language-xml">&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;fs.defaultFS&lt;/name&gt;
        &lt;value&gt;hdfs://master/&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;
        &lt;value&gt;~/hadoop/data&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre></li>
<li><p>修改hdfs-site.xml，内容如下:</p>

<pre><code class="language-xml">&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.replication&lt;/name&gt;
        &lt;value&gt;3&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre></li>
<li><p>修改mapred-site.xml（此文件需要从mapred-site.xml.template复制），内容如下：</p>

<pre><code class="language-xml">&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;
        &lt;value&gt;yarn&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre></li>
<li><p>修改yarn-site.xml,内容如下：</p>

<pre><code class="language-xml">&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;
        &lt;value&gt;master&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;
        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt;
        &lt;value&gt;master:8032&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt;
        &lt;value&gt;master:8030&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre></li>
<li><p>修改slaves文件，将附属机主机名添加入内，每行一个，样例为:</p>

<pre><code class="language-xml">s1
s3
</code></pre></li>
</ol></li>
<li><p>克隆宿主机，配置hosts文件</p>

<ol>
<li>使用VM的克隆功能，克隆虚拟机，并依次修改主机名</li>
<li><p>根据实际IP修改各个机器的hosts文件，ip查看可以使用<code>ifconfig</code>命令，样例如下：</p>

<pre><code>127.0.0.1  localhost    
10.104.234.203  master
182.254.216.245 s1
123.207.252.11 s2
123.207.24.98 s3
</code></pre></li>
</ol></li>
<li><p>格式化HDFS文件系统，执行<code>hdfs namenode -format</code>命令，对HDFS进行格式化。</p></li>
<li><p>启动Hadoop集群</p>

<ol>
<li>启动文件系统,<code>start-dfs.sh</code>;</li>
<li>启动yarn，<code>start-yarn.sh</code>;</li>
<li>可以使用<code>jps</code>命令，检查各个服务的启动情况</li>
</ol></li>
</ol>

<h2 id="toc_4">统计程序的编写与运行</h2>

<p>本次实验所用的MapReduce程序采用Maven的方式进行构建，具体操作可以参考文章：<a href="http://www.cnblogs.com/Leo_wl/p/4862820.html">Maven构建Hadoop工程</a></p>

<ol>
<li><p>编写Mapper类，本次我们实现的功能从原理上与Hadoop自带的WordCount实验非常相似。</p>

<pre><code class="language-java">package com.swu.count;

import java.io.IOException;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;

public class CountMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt; {

    private final static IntWritable one = new IntWritable(1);
    private Text word = new Text();

    @Override
    protected void map(Object key, Text value, Mapper&lt;Object, Text, Text, IntWritable&gt;.Context context)
            throws IOException, InterruptedException {
        // 获取每一行数据，并以逗号为基准进行分割
        String[] data = value.toString().split(&quot;,&quot;);
        // 设置word的key为地址信息
        word.set(data[5]);
        // 设置value为1
        context.write(word, one);
    }

}
</code></pre></li>
<li><p>编写Reducer类。</p>

<pre><code class="language-java">package com.swu.count;

import java.io.IOException;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Reducer;

public class CountReduce extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {
    private IntWritable result = new IntWritable();
    private Text keyEx = new Text();

    @Override
    protected void reduce(Text key, Iterable&lt;IntWritable&gt; values,
            Reducer&lt;Text, IntWritable, Text, IntWritable&gt;.Context context) throws IOException, InterruptedException {
        int sum = 0;
        // 遍历value相加
        for (IntWritable val : values) {
            sum += val.get();
        }
        // 返回新的key-value
        result.set(sum);
        keyEx.set(key);
        context.write(keyEx, result);
    }
}
</code></pre></li>
<li><p>编写Comparator类，用于第二次作业的排序。</p>

<pre><code class="language-java">package com.swu.count;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.WritableComparable;

public class CountComparator extends IntWritable.Comparator {

    @Override
    public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {
        // TODO Auto-generated method stub
        return -super.compare(b1, s1, l1, b2, s2, l2);
    }
    public int compare(WritableComparable a, WritableComparable b) {
        // TODO Auto-generated method stub
        return -super.compare(a, b);
    }
}
</code></pre></li>
<li><p>编写主方法。</p>

<pre><code class="language-java">package com.swu.count;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.util.GenericOptionsParser;
import java.util.Random;

import org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat;
import org.apache.hadoop.mapreduce.lib.input.SequenceFileInputFormat;
import org.apache.hadoop.mapreduce.lib.map.InverseMapper;

public class Main {
    public static void main(String[] args) throws Exception {
        Configuration conf = new Configuration();
        String[] otherArgs = new GenericOptionsParser(conf, args).getRemainingArgs();
        if (otherArgs.length != 2) {
            System.err.println(&quot;Usage: zhihuCount &lt;in&gt; &lt;out&gt;&quot;);
            System.exit(2);
        }
        Path tempDir = new Path(&quot;wordcount-temp-&quot; + Integer.toString(new Random().nextInt(Integer.MAX_VALUE))); // 定义一个临时目录

        Job job = new Job(conf, &quot;zhihuCount&quot;);
        job.setJarByClass(Main.class);
        try {
            job.setMapperClass(CountMapper.class);
            job.setCombinerClass(CountReduce.class);
            job.setReducerClass(CountReduce.class);

            job.setOutputKeyClass(Text.class);
            job.setOutputValueClass(IntWritable.class);

            FileInputFormat.addInputPath(job, new Path(otherArgs[0]));
            FileOutputFormat.setOutputPath(job, tempDir);
            // 先将词频统计任务的输出结果写到临时目录中,下一个排序任务以临时目录为输入目录。
            job.setOutputFormatClass(SequenceFileOutputFormat.class);
            if (job.waitForCompletion(true)) {
                Job sortJob = new Job(conf, &quot;sort&quot;);
                sortJob.setJarByClass(Main.class);
                FileInputFormat.addInputPath(sortJob, tempDir);
                sortJob.setInputFormatClass(SequenceFileInputFormat.class);

                /* InverseMapper由hadoop库提供，作用是实现map()之后的数据对的key和value交换 */
                sortJob.setMapperClass(InverseMapper.class);
                /* 将 Reducer 的个数限定为1, 最终输出的结果文件就是一个。 */
                sortJob.setNumReduceTasks(1);
                FileOutputFormat.setOutputPath(sortJob, new Path(otherArgs[1]));

                sortJob.setOutputKeyClass(IntWritable.class);
                sortJob.setOutputValueClass(Text.class);
                /*
                 * Hadoop 默认对 IntWritable 按升序排序，而我们需要的是按降序排列。 因此我们实现了一个
                 * IntWritableDecreasingComparator 类, 并指定使用这个自定义的 Comparator
                 * 类对输出结果中的 key (词频)进行排序
                 */
                sortJob.setSortComparatorClass(CountComparator.class);

                System.exit(sortJob.waitForCompletion(true) ? 0 : 1);
            }
        } finally {
            FileSystem.get(conf).deleteOnExit(tempDir);
        }
    }
}
</code></pre></li>
<li><p>将写好的程序编译为jar包(注意指定Main方法)，上传至服务器。</p></li>
<li><p>执行<code>hadoop jar XXX.jar /inputFile /outputFile</code>，执行作业。</p></li>
</ol>

<h2 id="toc_5">结果展示与说明</h2>

<p>上述作业结束后，我们就可以通过查询输出文件得到我们的统计结果。本次实验统计结果如下：<br/>
<img src="media/14786108252793/14787497512630.jpg" alt=""/><br/>
输出文件如下：<br/>
<img src="media/14786108252793/14787497741393.jpg" alt=""/></p>

<h2 id="toc_6">相关代码</h2>

<p>本次实验相关代码和所用的数据资料，均已上传至码云仓库（OSChina git）地址为：<a href="https://git.oschina.net/cobber/HadoopPractice">HadoopPractice</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网易Java Web微专业Spring-Web框架单元作业]]></title>
    <link href="http://swuzjb.github.io/14773646522828.html"/>
    <updated>2016-10-25T11:04:12+08:00</updated>
    <id>http://swuzjb.github.io/14773646522828.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>完成包含以下功能的Web工程，提供一个接口，该接口可以根据需要（扩展名，Accep头）返回一个HTML文档或者JSON数据，要求：<br/>
返回的JSON数据是一个用户列表，每个用户包含两个信息：用户Id（userId），用户名（userName），最终的数据类似：<br/>
{&quot;userList&quot; : [<br/>
    {<br/>
        &quot;userId&quot;: 1001,<br/>
        &quot;userName&quot;: &quot;test1&quot;<br/>
    },<br/>
    {<br/>
        &quot;userId&quot;: 1002,<br/>
        &quot;userName&quot;: &quot;test2&quot;<br/>
    }<br/>
    ...<br/>
]}<br/>
2. 返回的HTML文档基于FreeMarker生成，内容是一个用户列表的表格，对HTML表格不熟悉的同学可以参考 <a href="http://www.w3school.com.cn/tiy/t.asp?f=html_tables">http://www.w3school.com.cn/tiy/t.asp?f=html_tables</a> 了解；<br/>
3. 以自己能力为基础，返回的数据可以是接口内直接返回的，也可以是从数据库表里查询出来的（加分）；<br/>
4. 尽可能根据项目模板里介绍的内容组织代码及资源。</p>
</blockquote>

<h2 id="toc_0">项目架构</h2>

<p><img src="media/14773646522828/14773699877029.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_1">相关概念</h2>

<h3 id="toc_2">SpringMVC</h3>

<p>SpringMVC是Spring自身提供的一套基于MVC设计理念的开发框架，用于替代安全性较低的Sturts框架</p>

<h3 id="toc_3">JSON</h3>

<p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C、C++、C#、Java、JavaScript、Perl、Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。</p>

<h3 id="toc_4">视图解析器</h3>

<p>控制器在选择好适合处理请求的方法时，传入收到的请求(根据方法参数类型，可能以不同的类型传入)，并且 调用该方法中的逻辑来进行处理(也可以是调用Service来真正处理)。方法逻辑可能也会在参数中添加或者删除数据。处理方法处理完之后，会委派给一个 视图，由该视图来处理方法的返回值。处理程序的返回值并不代表视图的具体实现，可以只是String类型，代表视图名，甚至是void(这时候 Spring MVC可以根据方法名或者控制器名找默认视图)。也不需要担心返回值只是视图名称的话，视图拿不到要显示的数据。因为方法参数对于视图来说也是可以拿到 的。比如说，如果处理方法以Map为参数，那么这个Map对于视图也是可以拿到的。<br/>
返回的视图名称会返回给DispatcherServlet，它会根据一个视图解析器将视图名称解析为一个具体的视图实现。这里说到的视图解析器是一个实现了ViewResolver借口的Bean，它的任务就是返回一个视图的具体实现(HTML、jsonp、json等等)。</p>

<h4 id="toc_5">内容协商视图解析器</h4>

<p>可以根据请求的内容，自动匹配对应的视图解析器，对视图进行解析。</p>

<h2 id="toc_6">作业实现</h2>

<p>我们按照模块图有下自上对本次作业实现进行说明。</p>

<ol>
<li><p>User模型</p>

<pre><code class="language-java">package site.zhanjingbo.course.meta;

public class User {
    private int userId;
    private String userName;

    public int getUserId() {
        return userId;
    }

    public void setUserId(int userId) {
        this.userId = userId;
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }
}
</code></pre></li>
<li><p>UserDao。User数据库访问接口</p>

<pre><code class="language-java">package site.zhanjingbo.course.dao;
import java.util.List;
import site.zhanjingbo.course.meta.User;
public interface UserDao {
    public List&lt;User&gt; getUserList();
}
</code></pre></li>
<li><p>UserDaoMapper。使用Mybatis对UserDao进行实现。</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;site.zhanjingbo.course.dao.UserDao&quot;&gt;
    &lt;resultMap type=&quot;User&quot; id=&quot;UserResult&quot;&gt;
        &lt;result property=&quot;userId&quot; column=&quot;userId&quot; /&gt;
        &lt;result property=&quot;userName&quot; column=&quot;userName&quot; /&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;getUserList&quot; resultMap=&quot;UserResult&quot;&gt;
        select * from user
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre></li>
<li><p>UserService。User的对应业务逻辑层</p>

<pre><code class="language-java">package site.zhanjingbo.course.service.impl;
import java.util.List;
import javax.annotation.Resource;
import org.springframework.stereotype.Service;
import site.zhanjingbo.course.dao.UserDao;
import site.zhanjingbo.course.meta.User;
import site.zhanjingbo.course.service.UserService;  
@Service
public class UserServiceImpl implements UserService {
    @Resource
    private UserDao userDao;
    public List&lt;User&gt; getUserList() {
        return userDao.getUserList();
    }
}
</code></pre></li>
<li><p>UserController。User的控制器层，调用业务逻辑，返回对应视图名称和数据。</p>

<pre><code class="language-java">package site.zhanjingbo.course.web.controller;

import javax.annotation.Resource;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;
import site.zhanjingbo.course.service.UserService;

@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {
    @Resource
    private UserService userService;
    @RequestMapping(&quot;/userList&quot;)
    public ModelAndView getUserList() {
        ModelAndView mav = new ModelAndView();
        mav.setViewName(&quot;userList&quot;);
        mav.addObject(&quot;userList&quot;, userService.getUserList());
        return mav;
    }
}
</code></pre></li>
<li><p>userList.ftl。使用FreeMarker渲染的视图文件</p>

<pre><code class="language-html">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;用户列表&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;table border=&quot;1px&quot;&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;td&gt;userId&lt;/td&gt;
              &lt;td&gt;userName&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;#list userList as user&gt; 
                &lt;tr&gt;
                    &lt;td&gt;${user.userId}&lt;/td&gt; 
                    &lt;td&gt;${user.userName}&lt;/td&gt;
                &lt;/tr&gt;
            &lt;/#list&gt;
          &lt;/tbody&gt;  
        &lt;/table&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre></li>
<li><p>DispatcherServlet的配置文件，主要配置对应View的渲染方案，即内容协商视图响应。</p>

<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd
http://www.springframework.org/schema/mvc
http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

&lt;context:component-scan base-package=&quot;site.zhanjingbo.course.web.controller&quot; /&gt;

&lt;bean id=&quot;contentNegotiationManager&quot;
    class=&quot;org.springframework.web.accept.ContentNegotiationManagerFactoryBean&quot;&gt;
    &lt;!-- 扩展名至mimeType的映射,即 /user.json =&gt; application/json --&gt;
    &lt;property name=&quot;favorPathExtension&quot; value=&quot;true&quot; /&gt;
    &lt;!-- 用于开启 /userinfo/123?format=json 的支持 --&gt;
    &lt;property name=&quot;favorParameter&quot; value=&quot;true&quot; /&gt;
    &lt;property name=&quot;parameterName&quot; value=&quot;format&quot; /&gt;
    &lt;!-- 是否忽略Accept Header --&gt;
    &lt;property name=&quot;ignoreAcceptHeader&quot; value=&quot;false&quot; /&gt;
    &lt;property name=&quot;mediaTypes&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;json&quot; value=&quot;application/json&quot; /&gt;
            &lt;entry key=&quot;xml&quot; value=&quot;application/xml&quot; /&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;!-- 默认的content type --&gt;
    &lt;property name=&quot;defaultContentType&quot; value=&quot;text/html&quot; /&gt;
&lt;/bean&gt;
&lt;!-- freeMarker --&gt;
&lt;bean id=&quot;freemarkerConfig&quot;
    class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;
    &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/freemarker/&quot; /&gt;
&lt;/bean&gt;
&lt;bean
    class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt;
    &lt;property name=&quot;contentNegotiationManager&quot; ref=&quot;contentNegotiationManager&quot; /&gt;
    &lt;property name=&quot;viewResolvers&quot;&gt;
        &lt;list&gt;
            &lt;bean id=&quot;viewResolver&quot;
                class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;
                &lt;property name=&quot;cache&quot; value=&quot;true&quot; /&gt;
                &lt;property name=&quot;prefix&quot; value=&quot;&quot; /&gt;
                &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot; /&gt;
                &lt;property name=&quot;contentType&quot; value=&quot;text/html; charset=utf-8&quot; /&gt;
            &lt;/bean&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;defaultViews&quot;&gt;
        &lt;list&gt;
            &lt;!-- JSON --&gt;
            &lt;bean
                class=&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot; /&gt;
            &lt;!-- XML --&gt;
            &lt;bean class=&quot;org.springframework.web.servlet.view.xml.MarshallingView&quot;&gt;
                &lt;property name=&quot;marshaller&quot;&gt;
                    &lt;bean class=&quot;org.springframework.oxm.xstream.XStreamMarshaller&quot; /&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;/beans&gt;
</code></pre></li>
</ol>

<h2 id="toc_7">结果展示</h2>

<p>为了更好的展示不同URL后缀以及不同Accept头对应的不同返回结果，我们使用curl命令对项目进行请求，观察返回结果。</p>

<ol>
<li><p>无后缀，默认URL</p>

<pre><code>curl http://localhost:8080/SpringHomework5_1/api/user/userList
</code></pre>

<p><img src="media/14773646522828/14773731907095.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>html后缀</p>

<pre><code>http://localhost:8080/SpringHomework5_1/api/user/userList.html
</code></pre>

<p><img src="media/14773646522828/14773756220422.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>JSON后缀</p>

<pre><code>http://localhost:8080/SpringHomework5_1/api/user/userList.json
</code></pre>

<p><img src="media/14773646522828/14773756553739.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>XML后缀</p>

<pre><code>curl http://localhost:8080/SpringHomework5_1/api/user/userList.xml
</code></pre>

<p><img src="media/14773646522828/14773755762050.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>JSON头</p>

<pre><code>curl -H &#39;Accept:application/json&#39; http://localhost:8080/SpringHomework5_1/api/user/userList
</code></pre>

<p><img src="media/14773646522828/14773757816596.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
<li><p>XML头</p>

<pre><code>curl -H &#39;Accept:application/xml&#39; http://localhost:8080/SpringHomework5_1/api/user/userList
</code></pre>

<p><img src="media/14773646522828/14773757471295.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
</ol>

<h2 id="toc_8">总结</h2>

<p>虽然完成了目标任务，但是对于Spring整合其它框架以及SpringMVC的相关功能的具体熟悉还需要进一步学习。</p>

<h2 id="toc_9">代码</h2>

<p><a href="http://git.oschina.net/cobber/SpringHomework5_1">Demo</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网易Java Web微专业Spring-数据访问单元作业]]></title>
    <link href="http://swuzjb.github.io/14766902757975.html"/>
    <updated>2016-10-17T15:44:35+08:00</updated>
    <id>http://swuzjb.github.io/14766902757975.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>根据本单介绍的Spring JDBC，事务管理，MyBatis等内容，分别使用Spring JDBC及MyBatis提供一个转帐服务（保证事务），提供一个transferMoney接口：<br/>
transferMoney(Long srcUserId, Long targetUserId, double count)；// srcUserId及targetUserId为转帐用户标识</p>
</blockquote>

<h2 id="toc_0">相关表结构</h2>

<table>
<thead>
<tr>
<th style="text-align: center">列名</th>
<th style="text-align: center">类型</th>
<th style="text-align: center">备注</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">userId</td>
<td style="text-align: center">Long</td>
<td style="text-align: center">唯一用户标识</td>
</tr>
<tr>
<td style="text-align: center">balance</td>
<td style="text-align: center">double</td>
<td style="text-align: center">账户余额</td>
</tr>
</tbody>
</table>

<h2 id="toc_1">程序架构</h2>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-10-17-14766906872633.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h3 id="toc_2">说明</h3>

<ul>
<li>UserDao 为统一的User数据库访问接口</li>
<li>UserService 为外部服务提供直接调用的接口</li>
</ul>

<h2 id="toc_3">实现说明</h2>

<ol>
<li><p>application-config配置，相关配置均有注释说明。其中事务的处理可以采用注解或AOP的XML配置方式，下列代码均有体现。</p>

<pre><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
xmlns:mybatis=&quot;http://mybatis.org/schema/mybatis-spring&quot;
xsi:schemaLocation=&quot;
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop-2.0.xsd
http://www.springframework.org/schema/tx
http://www.springframework.org/schema/tx/spring-tx.xsd
http://mybatis.org/schema/mybatis-spring
http://mybatis.org/schema/mybatis-spring.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!-- 数据库连接配置文件导入 --&gt;
    &lt;context:property-placeholder location=&quot;db.properties&quot; /&gt;
    &lt;!-- 扫描注解 --&gt;
    &lt;context:component-scan base-package=&quot;site.zhanjingbo&quot; /&gt;
    &lt;!-- 使用注解声明事务 --&gt;
    &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; /&gt;
    &lt;!-- MyBatis的自动扫描 --&gt;
    &lt;mybatis:scan base-package=&quot;site.zhanjingbo&quot; /&gt;

    &lt;!-- 数据源配置 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;
        destroy-method=&quot;close&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driverClassName}&quot; /&gt;
        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;
        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
    &lt;/bean&gt;
    &lt;!-- 事务管理器 --&gt;
    &lt;bean id=&quot;txManager&quot;
        class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- 使用AOP-XML声明事务 --&gt;
    &lt;!-- &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt; &lt;tx:attributes&gt; 
        &lt;tx:method name=&quot;transfer*&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; 
        &lt;aop:pointcut id=&quot;daoOperation&quot; expression=&quot;execution(* site.zhanjingbo.service.*.*(..))&quot; 
        /&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;daoOperation&quot; /&gt; &lt;/aop:config&gt; --&gt;

    &lt;!-- 配置myBatis的sqlSessionFactory --&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;!-- 自动扫描mappers.xml文件 --&gt;
        &lt;property name=&quot;mapperLocations&quot;
            value=&quot;classpath:site/zhanjingbo/dao/myBatiesImpl/*.xml&quot;&gt;&lt;/property&gt;
        &lt;!-- myBatis配置文件 --&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre></li>
<li><p>UserDao的接口声明</p>

<pre><code class="language-java">public interface UserDao {
    public void reset();
    public List&lt;User&gt; getUserList();
    public void updateMoney(Long userId, double count);
}
</code></pre></li>
<li><p>UserDao的JDBC实现，其中JdbcTemplete由Spring进行装载。</p>

<pre><code class="language-java">@Component(&quot;UserJDBCDao&quot;)
public class UserDaoJDBCImpl implements UserDao {
    private JdbcTemplate jdbcTemplate;
    @Autowired
    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }
    public void reset() {
        this.jdbcTemplate.execute(&quot;update UserBalance set balance=1000&quot;);
    }
    public List&lt;User&gt; getUserList() {
        return this.jdbcTemplate.query(&quot;select * from UserBalance&quot;, new RowMapper&lt;User&gt;() {
            public User mapRow(ResultSet rs, int rowNum) throws SQLException {
                User user = new User();
                user.setUserId(rs.getLong(&quot;userId&quot;));
                user.setBalance(rs.getDouble(&quot;balance&quot;));
                return user;
            }
        });
    }
    public void updateMoney(Long userId, double count) {
        this.jdbcTemplate.update(&quot;update UserBalance set balance=balance+? where userId=?&quot;, count, userId);
    }
}
</code></pre></li>
<li><p>UserDao的MyBatis实现，采用Mapper.xml的方式进行声明实现</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;site.zhanjingbo.dao.UserDao&quot;&gt;
    &lt;resultMap type=&quot;User&quot; id=&quot;UserResult&quot;&gt;
        &lt;result property=&quot;userId&quot; column=&quot;userId&quot; /&gt;
        &lt;result property=&quot;balance&quot; column=&quot;balance&quot; /&gt;
    &lt;/resultMap&gt;
    &lt;update id=&quot;reset&quot;&gt;
        update UserBalance set balance=500
    &lt;/update&gt;

    &lt;select id=&quot;getUserList&quot; resultMap=&quot;UserResult&quot;&gt;
        select * from userBalance
    &lt;/select&gt;
    &lt;update id=&quot;updateMoney&quot;&gt;
        update UserBalance set balance=balance+#{param2} where userId=#{param1}
    &lt;/update&gt;
&lt;/mapper&gt; 
</code></pre></li>
<li><p>UserService的实现，其中主要为transferMoney方法的实现。由于该方法的业务逻辑，该方法应该确保事务性。采用注解的方式声明事务，则在该方法前添加<code>@Transactional</code>注解。采用配置文件方式对事务进行声明参考第1小节中的配置文件。</p>

<pre><code class="language-java">@Transactional(propagation = Propagation.REQUIRED)
public void transferMoney(Long srcUserId, Long targetUserId, double count) {
    userDao.updateMoney(srcUserId, 0 - count);
    userDao.updateMoney(targetUserId, count);
}
</code></pre>

<p>在UserService的实现过程中，我们需要调用UserDao的具体实例，在本次作业过程中我们采用了两种方法来实现UserDao。在测试不同的实现方式时只需要修改注入的UserDao的具体实例就可完成。为了明显区分两种实例的实现，我们在reset的方法中做了区别。其中JDBC实现方式Reset之后balance的值为1000，MyBatis实现方式reset之后的balance值为500。</p></li>
<li><p>Application调用代码</p>

<pre><code class="language-java">    public static void main(String[] args) {
        //加载Spring
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application-context.xml&quot;);
        //获取UserService实例
        UserService userService = applicationContext.getBean(UserService.class);
        userService.reset();
        try {
            userService.transferMoney(new Long(10000), new Long(10001), 100);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        List&lt;User&gt; userList = userService.getUserList();
        for (User user : userList) {
            System.out.println(user);
        }

        ((ConfigurableApplicationContext) applicationContext).close();
    }
</code></pre></li>
</ol>

<h2 id="toc_4">运行结果</h2>

<h3 id="toc_5">JDBC运行结果</h3>

<ol>
<li><p>正常执行<br/>
<img src="media/14766902757975/14766935577292.jpg" alt=""/></p></li>
<li><p>执行中异常，打印异常信息，数据回滚<br/>
<img src="media/14766902757975/14766935207561.jpg" alt=""/></p></li>
</ol>

<h3 id="toc_6">MyBatis运行结果</h3>

<ol>
<li><p>正常执行<br/>
<img src="media/14766902757975/14766936235948.jpg" alt=""/></p></li>
<li><p>执行中异常，打印异常信息，数据回滚<br/>
<img src="media/14766902757975/14766936425847.jpg" alt=""/></p></li>
</ol>

<h2 id="toc_7">程序地址</h2>

<p><a href="http://git.oschina.net/cobber/SpringHomework4_1">SpringHomework4_1</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网易Java Web微专业Spring-AOP容器作业]]></title>
    <link href="http://swuzjb.github.io/14759932535473.html"/>
    <updated>2016-10-09T14:07:33+08:00</updated>
    <id>http://swuzjb.github.io/14759932535473.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>完成一个基本的应用，提供若干个Service（&gt;=2），每个Service提供基本的增删查改的接口（实现随意，比如输出一行信息），通过AOP保证所有所有的Service接口在正常调用返回后以及抛出异常时（Service接口模拟），打出如下信息：函数名称，函数参数，并说明发生的事件：正常返回或者抛出异常。</p>
</blockquote>

<h2 id="toc_0">AOP模式示意图</h2>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-10-09-14759941824050.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_1">作业描述</h2>

<p>本次作业我设计了两个Service，分别是UserService和ProductService，每个Service分别提供增删改查操作（Print语句代替业务逻辑）。</p>

<ol>
<li><p>配置Spring配置文件，加入AOP相关的xsd文件。并配置AOP。</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd
http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop-2.0.xsd&quot;&gt;

    &lt;!-- 引入AOP --&gt;
    &lt;aop:aspectj-autoproxy /&gt;
    &lt;!-- 自动扫描annotation配置 --&gt;
    &lt;context:component-scan base-package=&quot;site.zhanjingbo&quot; /&gt;

    &lt;!-- 自定义的日志切面声明 --&gt;
    &lt;bean id=&quot;logAspect&quot; class=&quot;site.zhanjingbo.aspect.LogAspect&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre></li>
<li><p>编写Service。以UserService为例。</p>

<pre><code class="language-java">package site.zhanjingbo.service;
import org.springframework.stereotype.Component;

@Component
public class UserService {
    public void add(String username) throws Exception {
        System.out.println(&quot;添加用户:&quot; + username);
        throw new Exception(&quot;测试&quot;);
    }
    public void edit(String username) {
        System.out.println(&quot;添加用户:&quot; + username);
    }
    public void del(String username) {
        System.out.println(&quot;删除用户:&quot; + username);
    }
    public void find(String username) {
        System.out.println(&quot;查询用户:&quot; + username);
    }
}
</code></pre></li>
<li><p>编写Aspect，完成切面方法。</p>

<pre><code class="language-java">package site.zhanjingbo.aspect;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Aspect;

@Aspect
public class LogAspect {

    /**
     * 正常返回时调用
     * @param jp调用点信息
     */
    @AfterReturning(&quot;execution(* site.zhanjingbo.service.*.*(..))&quot;)
    public void logAfterReturning(JoinPoint jp){
        String className = jp.getSignature().getDeclaringTypeName();
        String methodName = jp.getSignature().getName();
        System.out.print(&quot;正常返回Log:调用&quot;+className+&quot;的&quot;+methodName+&quot;方法,参数为：&quot;);
        for (Object obj : jp.getArgs()) {
            System.out.print(obj.toString());
        }
        System.out.println(&quot;&quot;);
    }
    /**
     * 抛出异常返回时调用
     * @param jp 调用点信息
     * @param ex 异常信息
     */
    @AfterThrowing(pointcut=&quot;execution(* site.zhanjingbo.service.*.*(..))&quot;,throwing=&quot;ex&quot;)
    public void logAfterThrowing(JoinPoint jp,Exception ex){
        String className = jp.getSignature().getDeclaringTypeName();
        String methodName = jp.getSignature().getName();
        System.out.print(&quot;异常Log:调用&quot;+className+&quot;的&quot;+methodName+&quot;方法,参数为：&quot;);
        for (Object obj : jp.getArgs()) {
            System.out.print(obj.toString());
        }
        System.out.println(&quot;。抛出异常:&quot;+ex.getMessage()+&quot;!&quot;);
    }
}
</code></pre></li>
<li><p>编写模拟调用的Application类，来模拟业务。</p>

<pre><code class="language-java">public class Application {
    public static void main(String[] args){
        //加载Spring相关配置文件
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application-context.xml&quot;);

        //获取UserService实例
        UserService userService = applicationContext.getBean(UserService.class);
        //调用方法
        try {
            userService.add(&quot;ZhangSan&quot;);
        } catch (Exception e) {

        }
        //获取ProductService实例
        ProductService productService = applicationContext.getBean(ProductService.class);
        //调用方法
        productService.del(&quot;Pen&quot;);

        ((ConfigurableApplicationContext)applicationContext).close();
    }
}
</code></pre></li>
</ol>

<h2 id="toc_2">程序运行结果</h2>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-10-09-14759958614665.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<p>Service的方法正常调用或调用异常结束后，完成对应的切面方法响应，输出对应的Log。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网易Java Web微专业Spring-IoC容器作业]]></title>
    <link href="http://swuzjb.github.io/14748062329626.html"/>
    <updated>2016-09-25T20:23:52+08:00</updated>
    <id>http://swuzjb.github.io/14748062329626.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>假设我们有个应用（Application），它包含一个写文件的服务（FileWriterService），该服务在创建时会创建并打开一个文件，销毁时关闭该文件，并且该服务包含一个write(String content)方法：会将content写入到文件中，要求：<br/>
1. 使用Spring IoC的相关内容组织该程序；<br/>
2. 文件路径通过配置文件（properties）指定；<br/>
基本要求：必须附加一个项目说明文档，说明每个功能点对应程序的运行结果（截图），项目的接口说明或者关键代码（不要把全部代码贴出来）等可以反映项目结果的内容。提交作业的时候必须有这个项目说明文档，否则会影响最终评分</p>
</blockquote>

<h2 id="toc_0">程序结构</h2>

<p>根据题目要求，程序采用IoC的方式进行组织和构建。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-09-27-14749583867443.jpg" alt=""/></p>

<h2 id="toc_1">核心代码与结果</h2>

<ol>
<li><p>FileWriterService接口定义</p>

<pre><code class="language-java">public interface FileWirterService {
    public void write(String content);
}
</code></pre></li>
<li><p>FileWriterService实现类FileWriterServiceImpl</p>

<pre><code class="language-java">//声明一个Bean的id
@Component(&quot;fileWriterService&quot;)
public class FileWirterServiceImpl implements FileWirterService{

    //通过配置文件获取参数，注入到FileWirterServiceImpl中
    @Value(&quot;${filePath}&quot;)
    private File file;
    private FileWriter fw;
    //创建时调用，打开一个文件，获取输出流
    @PostConstruct
    public void init() {
        try {
            //判断文件是否存在，如不存在则创建文件
            if (!file.exists()) {
                file.createNewFile();
            }
            //打开文件
            fw = new FileWriter(file, true);
            System.out.println(&quot;打开文件&quot;);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public void write(String content) {
        try {
            //向文件中写入内容，并换行
            fw.write(content+&quot;\n&quot;);
            System.out.println(&quot;文件写入:&quot;+content);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    //销毁前调用，关闭文件输出流，释放文件
    @PreDestroy
    public void destory() {
        try {
            //关闭文件的输出流
            if (fw != null) {
                fw.flush();
                fw.close();
            }
            System.out.println(&quot;关闭文件&quot;);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre></li>
<li><p>读取配置文件获取FilePath参数。</p>

<ol>
<li>建立配置文件：<code>writer.properties</code>。写入配置<code>filePath=/Users/zhanjingbo/Desktop/spring.txt</code>，记录文件路径。</li>
<li><p>在Spring的<code>application-context.xml</code>中加入读取配置文件的配置。</p>

<pre><code class="language-xml">&lt;bean id=&quot;writerServiceProperties&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;
    &lt;property name=&quot;location&quot; value=&quot;classpath:writer.properties&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre></li>
</ol></li>
<li><p>编写Application的主类，实现main方法。</p>

<pre><code class="language-java">public static void main(String[] args) {
    //加载spring的配置文件，创建容器
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application-context.xml&quot;);
    //通过Bean的id来对FileWriterService进行注入
    FileWirterService fileWriterService = applicationContext.getBean(&quot;fileWriterService&quot;,FileWirterService.class);
    //调用业务逻辑
    fileWriterService.write(&quot;Hello World&quot;);
    //关闭容器
    ((ConfigurableApplicationContext)applicationContext).close();
}
</code></pre></li>
<li><p>结果展示</p>

<ul>
<li><p>控制台的相关输出<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-09-27-14749592874889.jpg" alt=""/></p></li>
<li><p>文件写入情况<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-09-27-14749593122837.jpg" alt=""/></p></li>
</ul></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据库连接池]]></title>
    <link href="http://swuzjb.github.io/14729975970385.html"/>
    <updated>2016-09-04T21:59:57+08:00</updated>
    <id>http://swuzjb.github.io/14729975970385.html</id>
    <content type="html"><![CDATA[
<p>建立数据库连接是一个非常耗时耗资源的行为，在大量并发的情况下，会降低服务器性能。同时，如果连接数超过最大的数据库允许连接值，数据库会直接抛出异常，非常不友好。为了解决上述的问题，我们引入了数据连接池的概念。<br/>
数据库连接池类似于线程池，通过连接池预先同数据库建立一些连接，放在内存中，应用程序需要建立数据库连接时直接到连接池中申请一个就行，用完后再放回去，避免频繁的新建和关闭连接对象</p>

<h2 id="toc_0">DBCP</h2>

<p>DBCP（DataBase Connection Pool）数据库连接池，是java数据库连接池的一种，由Apache开发，通过数据库连接池，可以让程序自动管理数据库连接的释放和断开。同时DBCP也是tomcat所使用的连接池组价。</p>

<h3 id="toc_1">DBCP的简单使用DEMO</h3>

<pre><code class="language-java">package site.zhanjingbo.HelloDB;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import org.apache.commons.dbcp2.BasicDataSource;

public class HelloDBCP {

    static final String DRIVER_NAME = &quot;com.mysql.jdbc.Driver&quot;;
    static final String DB_URL = &quot;jdbc:mysql://localhost:3307/cloud_study?characterEncoding=utf8&quot;;
    static final String DB_USER = &quot;root&quot;;
    static final String DB_PASSWORD = &quot;&quot;;

    public static BasicDataSource ds = null;

    public static void init() {
        ds = new BasicDataSource();
        ds.setDriverClassName(DRIVER_NAME);
        ds.setUsername(DB_USER);
        ds.setUrl(DB_URL);
        ds.setPassword(DB_PASSWORD);
    }

    public static void search() {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;

        try {
            conn = ds.getConnection();
            stmt = conn.createStatement();
            rs = stmt.executeQuery(&quot;select username from user&quot;);
            while (rs.next()) {
                System.out.println(&quot;Hello &quot; + rs.getString(&quot;username&quot;));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }
                if (stmt != null) {
                    stmt.close();
                }
                if (conn != null) {
                    conn.close();
                }
            } catch (SQLException e) {
            }
        }
    }

    public static void main(String[] args) {
        init();
        search();
    }
}

</code></pre>

<p>通过上述的demo可见，使用DBCP对数据进行访问实际操作与JDBC并无不同。唯一的区别就是Connection对象的获取是通过BasicDataSource对象来获得而不是DriverManage对象。<br/>
注：释放Connection对象同样是调用Connection的close()方法，不过这里的close()方法是被DBCP重写过的，是将连接对象重新放回连接池，而不是释放销毁。</p>

<h3 id="toc_2">DBCP高级API</h3>

<p>为了更好的设置和使用DBCP连接池，使数据库连接池效率更高，DBCP还提供了多个API接口供我们使用。</p>

<table>
<thead>
<tr>
<th style="text-align: center">接口</th>
<th style="text-align: center">作用</th>
<th style="text-align: center">建议</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.setInitialSize()</td>
<td style="text-align: center">设置初始化连接数</td>
<td style="text-align: center">设置为项目预期访问量</td>
</tr>
<tr>
<td style="text-align: center">.setMaxTotal()</td>
<td style="text-align: center">最大连接数</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">ds.setMaxWaitMillis()</td>
<td style="text-align: center">线程最大等待时间</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">.setMaxIdle()</td>
<td style="text-align: center">最大空闲连接数</td>
<td style="text-align: center">与MinIdle相同</td>
</tr>
<tr>
<td style="text-align: center">.setMinIdle()</td>
<td style="text-align: center">最小空闲连接数</td>
<td style="text-align: center">与MaxIdle相同</td>
</tr>
</tbody>
</table>

<h4 id="toc_3">DBCP定期检查</h4>

<p>为了保证连接池中的连接都是有效的，我们需要定期的对连接池中的连接进行检查，对失效的连接及时进行关闭。相关API如下：</p>

<table>
<thead>
<tr>
<th style="text-align: center">API</th>
<th style="text-align: center">作用</th>
<th style="text-align: center">建议</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">.setTestWhileIdle(true)</td>
<td style="text-align: center">是否开启定期检查</td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">.setMinEvictableIdle</td>
<td style="text-align: center">最小空闲时间，超过该值被销毁</td>
<td style="text-align: center">小于服务器连接失效时间(一般为8小时)</td>
</tr>
<tr>
<td style="text-align: center">.setTimeBetweenEvictionRunsMillis</td>
<td style="text-align: center">检查时间间隔</td>
<td style="text-align: center"></td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cookie与Session]]></title>
    <link href="http://swuzjb.github.io/14728168486763.html"/>
    <updated>2016-09-02T19:47:28+08:00</updated>
    <id>http://swuzjb.github.io/14728168486763.html</id>
    <content type="html"><![CDATA[
<p>在开发过程中我们经常需要保存一些状态信息如用户登录状态等，但是由于HTTP协议的无状态特性，这些功能无法直接实现。所以我们引入了Cookie与Session这两个概念用于保存一些信息。</p>

<h2 id="toc_0">Cookie</h2>

<p>Cookie的作用通俗地说就是当一个用户通过HTTP协议访问一个服务器的时候，这个服务器会将一些Key/Value键值对返回给客户端浏览器，并给这些数据加上一些限制条件，在条件符合时这个用户下次访问这个服务器的时候，数据又被完整地带回给服务器。</p>

<h3 id="toc_1">Cookie如何工作</h3>

<ol>
<li>用户通过浏览器请求某个Servlet，在请求过程中如果本地有该站点的Cookie信息，浏览器会将这些信息放入request请求的请求头中；</li>
<li>在Servlet中可以通过<code>request.getCookies();</code>获取当前的Cookie数组；</li>
<li>根据自己的业务需求，新建Cookie对象实例，分别设置key和value的值；</li>
<li>将需要添加的Cookie实例通过<code>response.addCookie();</code>方法添加到响应当中返回客户端，客户端根据Cookie的生命周期（MaxAge属性）来选择是否将此Cookie写入硬盘当中。</li>
</ol>

<h3 id="toc_2">DemoCode</h3>

<pre><code class="language-java">    String getCookie(Cookie[] cookies, String key) { 
        if (cookies != null) { 
            for (Cookie cookie : cookies) { 
                if (cookie.getName().equals(key)) { 
                    return cookie.getValue(); 
                } 
            } 
        } 
        return null; 
    } 

    @Override 
    public void doGet(HttpServletRequest request, 
                      HttpServletResponse response) 
            throws IOException, ServletException { 
        Cookie[] cookies = request.getCookies(); 
        String userName = getCookie(cookies, &quot;userName&quot;); 
        String userAge = getCookie(cookies, &quot;userAge&quot;); 
        if (userName == null) { 
            response.addCookie(new Cookie(&quot;userName&quot;, &quot;user&quot;)); 
        } 
        if (userAge == null) { 
            response.addCookie(new Cookie(&quot;userAge&quot;, &quot;28&quot;)); 
        } 
         
 }
</code></pre>

<h3 id="toc_3">使用Cookie的限制</h3>

<p>Cookie是 HTTP 协议头中的一个字段，虽然HTTP协议本身对这个字段并没有多少限制，但是 Cookie 最终还是存储在浏览器里，所以不同的浏览器对Cookie的存储都有一些限制，下表是一些通常的浏览器对 Cookie的大小和数量的限制。</p>

<table>
<thead>
<tr>
<th style="text-align: center">浏览器版本</th>
<th style="text-align: center">Cookie数限制（个/域名）</th>
<th style="text-align: center">总大小限制</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">IE6</td>
<td style="text-align: center">20</td>
<td style="text-align: center">4095B</td>
</tr>
<tr>
<td style="text-align: center">IE7、8、9</td>
<td style="text-align: center">50</td>
<td style="text-align: center">4095B</td>
</tr>
<tr>
<td style="text-align: center">Chrome</td>
<td style="text-align: center">50</td>
<td style="text-align: center">&gt;8000</td>
</tr>
<tr>
<td style="text-align: center">FireFox</td>
<td style="text-align: center">50</td>
<td style="text-align: center">4097B</td>
</tr>
</tbody>
</table>

<hr/>

<h2 id="toc_4">Session</h2>

<p>前面已经介绍了 Cookie 可以让服务端程序跟踪每个客户端的访问，但是每次客户端的访问都必须传回这些 Cookie，如果 Cookie 很多，这无形地增加了客户端与服务端的数据传输量，而 Session 的出现正是为了解决这个问题。</p>

<h3 id="toc_5">Session如何工作</h3>

<ol>
<li>session是基于Cookie的，同一个客户端每次和服务端交互时，不需要每次都传回所有的 Cookie 值，而是只要传回一个 ID，这个 ID 是客户端第一次访问服务器的时候生成的，而且每个客户端是唯一的。这样每个客户端就有了一个唯一的 ID，客户端只要传回这个 ID 就行了，这个 ID 通常是 NANE 为 JSESIONID 的一个 Cookie；</li>
<li>有了Session ID服务端就可以创建HttpSession对象了，第一次触发通过<code>request.getSession()</code>方法。如果当前的Session ID 还没有对应的HttpSession对象，那么就创建一个新的，并将这个对象加到org.apache.catalina.Manager的sessions容器中保存。Manager类将管理所有Session的生命周期，如果该session存在则直接返回；</li>
<li>直接操作session对象对key/value键值对进行存储，数据保存在服务器端，可以通过api手工操作其声明周期</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[简述HTTP请求过程]]></title>
    <link href="http://swuzjb.github.io/14720186733605.html"/>
    <updated>2016-08-24T14:04:33+08:00</updated>
    <id>http://swuzjb.github.io/14720186733605.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>HTTP请求是web程序服务的基础，要想写好web程序，必然要对http请求的过程进行掌握。</p>
</blockquote>

<h2 id="toc_0">HTTP请求步骤</h2>

<ol>
<li>如果是以域名形式进行web访问，则浏览器会先通过DNS服务将域名转化为对应的IP地址，为下一步访问做准备。</li>
<li>通过IP地址与服务器建立TCP连接</li>
<li>客户端向服务器端发送Request请求</li>
<li>服务器端向客户端发送Response响应</li>
<li>服务器端关闭TCP连接。一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：<code>Connection:keep-alive</code>。TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 </li>
</ol>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-08-24-14720197735370.jpg" alt=""/></p>

<h2 id="toc_1">HTTP请求头,响应头字段</h2>

<h3 id="toc_2">请求头</h3>

<ul>
<li>Accept: text/html, image/* ：客户机支持的数据类型</li>
<li>Accept-Charset: UTF-8 ：客户机采用的编码</li>
<li>Accept-Encoding: gzip,compress:客户机支持的数据压缩格式</li>
<li>Accept-Language: en-us,zh-cn:客户机的语言环境</li>
<li>Host: localhost:8080 :访问的主机名</li>
<li>If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT : 资源的缓存时间,用以判断服务器上的资源是否发生变化</li>
<li>Referer: <a href="http://www.zhanjingbo.site">http://www.zhanjingbo.site</a> : 从哪个页面跳转来访问资源的,用以实现防盗链</li>
<li>User-Agent: Mozilla/4.0 (compatible;MSIE 5.5;Windows NT 5.0):客户机的软件环境</li>
<li>Connection: close/Keep-Alive:请求结束后,是关闭连接还是保持连接</li>
<li>Date: Tue, 11 Jul 2000 18:23:51 GMT当前请求时间</li>
<li>Range:指示服务器只传输一部分web资源.可以用来实现断点续传功能

<ul>
<li>Range字段可以通过3种格式设置要传输的字节范围:</li>
<li>Range: bytes=1000-2000:传输范围从1000到2000字节</li>
<li>Range: bytes=1000-:传输第1000个字节以后的所有内容</li>
<li>Range: bytes=10000:传输最后1000个字节</li>
</ul></li>
</ul>

<h3 id="toc_3">响应头</h3>

<ul>
<li>Location：这个头配合302状态码使用，重定向地址</li>
<li>Server:Apache-Coyote/1.1:服务器类的类型</li>
<li>Content-Encoding：服务器通过这个头，数据压缩的格式</li>
<li>Content-Type：服务器通过这个头告诉浏览器送回数据的类型</li>
<li>Refresh：服务器通过这个头，告诉浏览器隔多长时间刷新一次</li>
<li>Connection:keep-alive\close:访问完后的状态</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java康复性训练——SpringMVC]]></title>
    <link href="http://swuzjb.github.io/14693288315265.html"/>
    <updated>2016-07-24T10:53:51+08:00</updated>
    <id>http://swuzjb.github.io/14693288315265.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>SpringMVC是一套功能强大，性能强悍且使用方便的优秀MVC框架</p>
</blockquote>

<h2 id="toc_0">SpringMVC-HelloWorld</h2>

<ol>
<li>导入相关jar包</li>
<li><p>配置web.xml文件，设置全局拦截器。拦截所有请求，转发给SpringMVC</p>

<pre><code class="language-xml">&lt;servlet&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre></li>
<li><p>添加SpringMVC配置文件spring-mvc.xml</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!-- 使用注解的包，包括子集 --&gt;
    &lt;context:component-scan base-package=&quot;site.zhanjingbo&quot;/&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean id=&quot;viewResolver&quot;
        class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre></li>
<li><p>添加控制器HelloContorller</p>

<pre><code class="language-java">package site.zhanjingbo.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HelloController {

    @RequestMapping(&quot;/hello&quot;)
    public String hello(Model model){
        model.addAttribute(&quot;message&quot;, &quot;HelloWorld!&quot;);
        return &quot;hello&quot;;
    }
}
</code></pre></li>
<li><p>在/WEB-INF/jsp/下建立显示返回页面hello.jsp</p>

<pre><code class="language-html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
${message }
&lt;/body&gt;
&lt;/html&gt;
</code></pre></li>
<li><p>完成。启动Tomcat，访问<a href="http://localhost:8080/SpringMVC/hello.do">http://localhost:8080/SpringMVC/hello.do</a>  查看<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-07-24-14693326495259.jpg" alt=""/></p></li>
</ol>

<h2 id="toc_1">SpringMVC控制器</h2>

<ul>
<li>@RequestMapping：用于指定方法的响应URL或模块URL</li>
<li>@RequestParam：绑定提交参数与控制器方法参数的注解。<code>@RequestParam(value=&quot;&quot;,required=true/false)</code></li>
<li>ModelAndView:作为控制器的返回值类型，返回模型与视图</li>
<li>SpringMVC对象属性自动封装:SpringMVC可以根据表单传入的数据自动封装控制器参数对象</li>
<li><p>SpringMVC POST请求中文乱码:在web.xml中添加过滤器</p>

<pre><code class="language-xml">&lt;!-- 编码过滤器 --&gt;
&lt;filter&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;async-supported&gt;true&lt;/async-supported&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre></li>
<li><p>Controller内部转发与重定向</p>

<ul>
<li>转发：<code>forward:</code></li>
<li>重定向:<code>redirect:</code></li>
</ul></li>
<li><p>SpringMVC对Servlet API的支持</p>

<ul>
<li>只需要在控制器方法的参数列表中添加HttpServletRequest、HttpServletResponse参数即可自动注入实例对象。</li>
</ul></li>
<li><p>SpringMVC对json的支持：这个有很多实例，建议直接上搜索引擎。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java康复性训练——Spring（2）]]></title>
    <link href="http://swuzjb.github.io/14691739607250.html"/>
    <updated>2016-07-22T15:52:40+08:00</updated>
    <id>http://swuzjb.github.io/14691739607250.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">AOP</h2>

<blockquote>
<p>AOP(Aspect Oriented Programming,面向切面编程)，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是软件开发的一个热点，也是Spring框架中的一个重要内容。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高开发效率。<br/>
主要功能是：日志记录、性能统计、安全控制、事务处理、异常处理等</p>
</blockquote>

<h2 id="toc_1">Spring AOP实例</h2>

<p>AOP的使用可以让我们在某个业务逻辑或事务执行的各个不同时期加入灵活的代码，让我们的权限控制、日志记录、性能统计等基础功能与业务逻辑彻底分离，降低耦合。这种执行方式称之为通知，通知有以下几种类型：</p>

<ol>
<li>前置通知：在业务逻辑开始之前执行。</li>
<li>后置通知：在业务逻辑结束之后执行。</li>
<li>环绕通知：可以灵活配置业务逻辑的执行时间或是否执行业务逻辑，功能上有点类似于Filter。</li>
<li>返回通知：当业务逻辑执行完并返回非空数据时执行。</li>
<li>异常通知：当业务逻辑执行过程中产生异常时执行。</li>
</ol>

<h3 id="toc_2">实例demo：</h3>

<ol>
<li><p>通知具体内容类：</p>

<pre><code class="language-java">package site.zhanjingbo.advice;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;

public class UserServiceAspect {
    public void doBefore(JoinPoint jp){
        System.out.println(&quot;请求类型:&quot;+jp.getTarget().getClass().getName()+&quot;,请求方法:&quot;+jp.getSignature().getName());
        System.out.println(&quot;开始添加用户：&quot;+jp.getArgs()[0]);
    }
    public void doAfter(JoinPoint jp){
        System.out.println(&quot;请求类型:&quot;+jp.getTarget().getClass().getName()+&quot;,请求方法:&quot;+jp.getSignature().getName());
        System.out.println(&quot;完成添加用户：&quot;+jp.getArgs()[0]);
    }
    public Object doAround(ProceedingJoinPoint pjp) throws Throwable{
        System.out.println(&quot;环绕前&quot;);
        Object retVal = pjp.proceed();
        System.out.println(&quot;环绕后&quot;);
        return retVal;
    }   
    public void doAfterThrowing(JoinPoint jp,Throwable ex){
        System.out.println(&quot;异常通知信息：&quot;+ex.getMessage());
    }
    public void doAfterReturning(JoinPoint jp){
        System.out.println(&quot;返回通知&quot;);
    }
}
</code></pre></li>
<li><p>beans.xml的配置</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

        &lt;bean id=&quot;userService&quot; class=&quot;site.zhanjingbo.service.impl.UserServiceImpl&quot;/&gt;
        &lt;bean id=&quot;userServiceAspect&quot; class=&quot;site.zhanjingbo.advice.UserServiceAspect&quot; /&gt;

        &lt;aop:config&gt;
            &lt;aop:aspect id=&quot;userServiceAspect&quot; ref=&quot;userServiceAspect&quot;&gt;
                &lt;!-- 声明一个切点 --&gt;
                &lt;aop:pointcut expression=&quot;execution(* site.zhanjingbo.service.*.*(..))&quot; id=&quot;businessService&quot;/&gt;  
                &lt;!-- 为切点添加通知 --&gt;
                &lt;aop:before method=&quot;doBefore&quot; pointcut-ref=&quot;businessService&quot;/&gt;
                &lt;aop:after method=&quot;doAfter&quot; pointcut-ref=&quot;businessService&quot;/&gt;
                &lt;aop:around method=&quot;doAround&quot; pointcut-ref=&quot;businessService&quot; /&gt;
                &lt;aop:around method=&quot;doAround&quot; pointcut-ref=&quot;businessService&quot;/&gt;
                &lt;aop:after-returning method=&quot;doAfterReturning&quot; pointcut-ref=&quot;businessService&quot;/&gt;
                &lt;aop:after-throwing method=&quot;doAfterThrowing&quot; pointcut-ref=&quot;businessService&quot; throwing=&quot;ex&quot;/&gt;
            &lt;/aop:aspect&gt;
        &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre></li>
<li><p>执行顺序<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-07-22-14691852095800.jpg" alt="" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p></li>
</ol>

<h2 id="toc_3">Spring对Dao的支持</h2>

<p>Spring发布以来很好的支持了Hibernate和Mybatis等ORM框架，只需要简单的配置，就可以很方便的实现dao的注入。</p>

<h2 id="toc_4">Spring对事务的支持</h2>

<p>事务,是业务逻辑非常重要的一个概念。事务具有的原子性、一致性、隔离性、永久性是数据正确的保证。Spring为开发人员实现事务这个特性提供了非常方便的实现方式。</p>

<ol>
<li>编程式事务管理：通过Spring提供的事务模板类<code>org.springframework.transaction.support.TranscationTemplate</code>来实现事务处理。</li>
<li>声明式事务管理：通过XML或注解配置的方式自动添加事务处理。</li>
<li><p>事务传播行为：Spring中，当一个service方法调用另外一个service方法的时候，因为每个service方法都有事务，这时候就出现了事务的嵌套，就产生了事务传播行为。</p>

<ol>
<li>PROPAGATION_REQUIRED--支持当前事务,如果当前没有事务,就新建一个事务。这是最常见的选择。</li>
<li>PROPAGATION_SUPPORTS--支持当前事务,如果当前没有事务,就以非事务方式执行。</li>
<li>PROPAGATION_MANDATORY--支持当前事务,如果当前没有事务,就抛出异常。</li>
<li>PROPAGATION_REQUIRES_NEW--新建事务,如果当前存在事务,把当前事务挂起。</li>
<li>PROPAGATION_NOT_SUPPORTED--以非事务方式执行操作,如果当前存在事务,就把当前事务挂起。</li>
<li>PROPAGATION_NEVER--以非事务方式执行,如果当前存在事务,则抛出异常。</li>
</ol>

<pre><code class="language-xml">&lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;
&lt;bean id=&quot;transactionManager&quot;
    class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;

&lt;!-- 配置事务通知属性 --&gt;  
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;  
    &lt;!-- 定义事务传播属性 --&gt;  
    &lt;tx:attributes&gt;  
        &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; /&gt;  
        &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt;  
        &lt;tx:method name=&quot;edit*&quot; propagation=&quot;REQUIRED&quot; /&gt;  
        &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt;  
        &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; /&gt;  
        &lt;tx:method name=&quot;new*&quot; propagation=&quot;REQUIRED&quot; /&gt;  
        &lt;tx:method name=&quot;set*&quot; propagation=&quot;REQUIRED&quot; /&gt;  
        &lt;tx:method name=&quot;remove*&quot; propagation=&quot;REQUIRED&quot; /&gt;  
        &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt;  
        &lt;tx:method name=&quot;change*&quot; propagation=&quot;REQUIRED&quot; /&gt;  
        &lt;tx:method name=&quot;get*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt;  
        &lt;tx:method name=&quot;find*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt;  
        &lt;tx:method name=&quot;load*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt;  
        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt;  
    &lt;/tx:attributes&gt;  
&lt;/tx:advice&gt;  
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java康复性训练——Spring（1）]]></title>
    <link href="http://swuzjb.github.io/14690817459253.html"/>
    <updated>2016-07-21T14:15:45+08:00</updated>
    <id>http://swuzjb.github.io/14690817459253.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson创建。简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。</p>
</blockquote>

<h2 id="toc_0">Spring IOC</h2>

<p>IOC(Inverse of Control)控制反转,又称作依赖注入。是一种重要的面向对象编程的法则，用于削减计算机程序的耦合问题，是轻量级Spring框架的核心。<br/>
Spring的IOC的核心就是为各类依赖进行注入，Spring将注入的单例实例称之为bean。依赖注入也就是将Bean注入实例。</p>

<h3 id="toc_1">依赖注入</h3>

<ol>
<li><p>装配一个Bean</p>

<ol>
<li><p>在Spring的bean.xml文件中填写如下配置：</p>

<pre><code class="language-xml">&lt;bean id=&quot;user1&quot; class=&quot;site.zhanjingbo.model.User&quot;&gt;&lt;/bean&gt; 
</code></pre></li>
<li><p>在需要对实例进行初始化的时候使用如下代码：</p>

<pre><code class="language-java">public static void main(String[] args) {

    //加载Spring-bean配置信息
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);

    //获取id为user1的bean的实例
    User user1 = (User)ac.getBean(&quot;user1&quot;);
    System.out.println(user1);
}
</code></pre></li>
</ol></li>
<li><p>属性注入：为注入的实例设置属性值。通过配置beans.xml实现，实现代码如下:</p>

<pre><code class="language-xml">&lt;bean id=&quot;user2&quot; class=&quot;site.zhanjingbo.model.User&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;2&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;username&quot; value=&quot;administrator&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;password&quot; value=&quot;password&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre></li>
<li><p>构造函数注入：在实例化bean时调用指定的构造方法。通过配置beans.xml文件实现。</p>

<pre><code class="language-xml">&lt;bean id=&quot;user3&quot; class=&quot;site.zhanjingbo.model.User&quot;&gt;
    &lt;!-- 通过索引来设置参数值 --&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;3&quot;&gt;&lt;/constructor-arg&gt;
    &lt;!-- 通过类型来设置参数值 --&gt;
    &lt;constructor-arg type=&quot;String&quot; value=&quot;username&quot;&gt;&lt;/constructor-arg&gt;
    &lt;!-- 通过参数名来设置参数值 --&gt;
    &lt;constructor-arg name=&quot;password&quot; value=&quot;password&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre></li>
<li><p>工厂方法注入：通过自己定义的工厂方法对bean进行实例化注入。</p>

<ol>
<li><p>静态工厂方法，在beans.xml中调用。</p>

<pre><code class="language-xml">&lt;bean id=&quot;user4&quot; class=&quot;site.zhanjingbo.factory.UserFactory&quot; factory-method=&quot;createUser&quot;&gt;&lt;/bean&gt;
</code></pre></li>
<li><p>非静态工厂方法,先声明工厂类的Bean，再对其进行调用</p>

<pre><code class="language-xml">&lt;bean id=&quot;userFactory&quot; class=&quot;site.zhanjingbo.factory.UserFactory&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;user5&quot; factory-bean=&quot;userFactory&quot; factory-method=&quot;createUser&quot;&gt;&lt;/bean&gt;
</code></pre></li>
</ol></li>
</ol>

<h3 id="toc_2">注入参数</h3>

<ol>
<li>基本类型值：参考上一节属性注入。</li>
<li>注入Bean：<code>&lt;property name=&quot;role&quot; ref=&quot;role1&quot;&gt;&lt;/property&gt;</code>。</li>
<li>内部Bean，为了防止bean被其他部分引用，可以将bean声明在<code>&lt;property&gt;&lt;/property&gt;</code>之间，仅供自己引用。</li>
<li><code>null</code>值，在<code>&lt;property&gt;&lt;/property&gt;</code>之间添加<code>&lt;null&gt;&lt;/null&gt;</code>表示空值。</li>
<li>级联属性，直接对属性对象的属性进行赋值。要确保该属性对象不为null。<code>&lt;property name=&quot;role.name&quot; value=&quot;admin&quot;&gt;&lt;/property&gt;</code></li>
<li><p>集合类型属性，可以用下列配置来实现。</p>

<pre><code class="language-xml">&lt;!-- list--&gt;
&lt;property name=&quot;list&quot;&gt;
    &lt;list&gt;
        &lt;value&gt;&lt;/value&gt;
    &lt;/list&gt;
&lt;/property&gt;
&lt;!--set--&gt;
&lt;property name=&quot;set&quot;&gt;
    &lt;set&gt;
        &lt;value&gt;&lt;/value&gt;
    &lt;/set&gt;
&lt;/property&gt;
&lt;!--map--&gt;
&lt;property name=&quot;map&quot;&gt;
    &lt;map&gt;
        &lt;entry&gt;
            &lt;key&gt;&lt;value&gt;key&lt;/value&gt;&lt;/key&gt;
            &lt;value&gt;value&lt;/value&gt;
        &lt;/entry&gt;
    &lt;/map&gt;
&lt;/property&gt;
</code></pre></li>
</ol>

<h3 id="toc_3">自动装配</h3>

<p>通过配置default-autowrite属性，Spring IOC容器可以自动为程序注入bean；默认是no，不启用自动装配。default-autowrite的类型有byName，byType,constructor。<br/>
- byName:通过名称进行自动匹配<br/>
- byType:根据类型进行自动匹配<br/>
- constructor:和byType类似，只不过它是根据构造方法注入而言的，根据类型，自动注入。<br/>
<em>建议：自动装配机制由于屏蔽了装配的细节，容易产生潜在的错误，慎用</em></p>

<h3 id="toc_4">方法注入</h3>

<p>Spring bean默认的作用域是单例的，每次获取的都是同一个对象。我们可以通过设置bean的scope属性为prototype实现多例。<br/>
在关联的Bean中我们通过设置<lookup-method>来实现多例注入。</p>

<h3 id="toc_5">bean之间关系</h3>

<ol>
<li>继承：可以通过设置Abstract类型的Bean来设置某一类Bean的共用参数，继承bean设置parent属性即可。</li>
<li>依赖：通过设置bean的depends-on属性来设置依赖</li>
<li>引用：见上部</li>
</ol>

<h3 id="toc_6">bean的作用范围</h3>

<ol>
<li>singleton:Spring Ioc容器中仅有一个bean实例，以单例的方式存在</li>
<li>prototype:每次容器调用Bean时，都返回一个新的实例</li>
<li>request:每次Http请求时都会创建一个新的实例</li>
<li>session:同一个Http Session共享一个Bean</li>
<li>global session：同一个全局Session共享一个bean，一般用于portlet应用环境</li>
<li>application:同一个Application共享一个bean</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java康复性训练——MyBatis3(3)]]></title>
    <link href="http://swuzjb.github.io/14689923975384.html"/>
    <updated>2016-07-20T13:26:37+08:00</updated>
    <id>http://swuzjb.github.io/14689923975384.html</id>
    <content type="html"><![CDATA[
<p>接上篇，继续对Mybatis的使用进行介绍。</p>

<blockquote>
<p>代码展示：<a href="https://github.com/swuzjb/MybatisDemo">Github地址</a></p>
</blockquote>

<h2 id="toc_0">动态SQL</h2>

<p>在实际开发过程中，静态的SQL写法并没有什么灵活性。当我们对User进行检索时，可能是依据id，role，username等等参数，如果使用静态SQL语句，我们就需要重复写大量的代码。为了解决这类问题，我们引入动态SQL。</p>

<p>Mybatis对动态SQL有很不错的支持，增加了很多扩展。</p>

<h3 id="toc_1">IF标签</h3>

<p>当我们开发过程中，遇到上述的多条件或指定条件查询时，我们可以使用IF标签来扩展。<br/>
以实现一个用户检索为例：</p>

<ol>
<li>在UserMapper接口中定义查询方法：<code>public List&lt;User&gt; searchUser(Map&lt;String, Object&gt; searchMap);</code></li>
<li><p>在UserMapper.xml中对接口进行实现：</p>

<pre><code class="language-xml">    &lt;select id=&quot;searchUser&quot; parameterType=&quot;Map&quot; resultMap=&quot;UserResult&quot;&gt;
    select * from user where 1=1
    &lt;if test=&quot;username!=null&quot;&gt;
        and username like #{username}
    &lt;/if&gt;
    &lt;if test=&quot;id!=null&quot;&gt;
        and id=#{id}
    &lt;/if&gt;
    &lt;if test=&quot;role!=null&quot;&gt;
        and roleId=#{role.id}
    &lt;/if&gt;
&lt;/select&gt;
</code></pre></li>
<li><p>调用查询，传入查询条件的Map即可。</p>

<pre><code class="language-java">public void testSearch(){
    Role role = new Role();
    role.setId(1);
    Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
    map.put(&quot;role&quot;, role);  
    List&lt;User&gt; userList = userMapper.searchUser(map);
    for(User user:userList){
        System.out.println(user);
    }   
}
</code></pre></li>
</ol>

<h3 id="toc_2">Choose、when和otherwise标签</h3>

<p>上面的IF标签类似于我们结构控制的IF语句，那么现在介绍的这个标签就类似于我们的结构控制中的Switch-Case语句。<br/>
当我们需要对条件进行限制的时候，我们就可以使用这个标签。标签的结构如下：</p>

<pre><code class="language-xml">&lt;choose&gt;
    &lt;when test=&quot;&quot;&gt;&lt;/when&gt;
    &lt;when test=&quot;&quot;&gt;&lt;/when&gt;
    &lt;otherwise&gt;&lt;/otherwise&gt;
&lt;/choose&gt;
</code></pre>

<h3 id="toc_3">where标签</h3>

<p>where条件是对Where语句的一个优化，可以自动给SQL语句加上Where。如果Where子句以and或者or开头时，则自动删除第一个and或or。</p>

<pre><code class="language-xml">    &lt;select id=&quot;searchUser&quot; parameterType=&quot;Map&quot; resultMap=&quot;UserResult&quot;&gt;
        select * from user 
        &lt;where&gt;
            &lt;if test=&quot;username!=null&quot;&gt;
                and username like #{username}
            &lt;/if&gt;
            &lt;if test=&quot;id!=null&quot;&gt;
                and id=#{id}
            &lt;/if&gt;
            &lt;if test=&quot;role!=null&quot;&gt;
                and roleId=#{role.id}
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
</code></pre>

<h3 id="toc_4">trim标签</h3>

<p>与where语句类似，给语句增加前后缀。</p>

<h3 id="toc_5">Foreach标签</h3>

<p>用于拼接SQL语句的in语句，对传入的集合进行遍历。集合名称collectionName，元素名称itemName，拼接时以<code>(</code>开始，以<code>）</code>结束，用<code>，</code>分割。</p>

<pre><code class="language-xml">&lt;foreach collection=&quot;collectionName&quot; item=&quot;itemName&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt;
#{itemName}
&lt;/foreach&gt;
</code></pre>

<h3 id="toc_6">set标签</h3>

<p>和where子句类似，用于update语句。可以自动加上set，并自动删除最后一个<code>，</code>。</p>

<pre><code class="language-xml">&lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt;
        update user 
        &lt;set&gt;
            &lt;if test=&quot;username!=null&quot;&gt;
                username=#{username},
            &lt;/if&gt;
            &lt;if test=&quot;password!=null&quot;&gt;
                password=#{password},
            &lt;/if&gt;
            &lt;if test=&quot;role!=null&quot;&gt;
                roleId=#{role.id},
            &lt;/if&gt;
        &lt;/set&gt;
        where id=#{id}
&lt;/update&gt;
</code></pre>

<h3 id="toc_7">处理CLOB、BLOB类型数据</h3>

<ul>
<li>BLOB映射为<code>byte[]</code>,CLOB映射为<code>String</code>。</li>
<li>数据插入和读取时，参照对应的映射类型进行处理即可。</li>
</ul>

<h3 id="toc_8">传入多个输入参数</h3>

<ul>
<li>使用<code>&lt;key,value&gt;</code>键值对的Map进行传递</li>
<li>在SQL拼接时，直接使用#{param1}、#{param2}...来获取</li>
</ul>

<h3 id="toc_9">MyBatis分页</h3>

<ul>
<li>逻辑分页，即把所有的数据加入内存，每次取出若干条。通过<code>RowBounds</code>对象即可实现（需要指定offset,limit两个值）</li>
<li>物理分页，使用limit子句来实现分页</li>
</ul>

<h3 id="toc_10">MyBatis缓存</h3>

<p>MyBatis默认情况下，启用一级缓存，即同一个SqlSession接口对象调用了相同的select语句，则直接会从缓存中返回结果，而不再查询一次数据库。<br/>
开发者可以自己配置二级缓存，二级缓存是全局的。默认情况下，select使用缓存，insert、update、delete不使用缓存。</p>

<h3 id="toc_11">使用注解配置SQL映射器</h3>

<h4 id="toc_12">基本映射语句</h4>

<ol>
<li>@Insert：声明在插入的接口上方，参数为sql语句，和XML配置时相同；</li>
<li>@Update：同上；</li>
<li>@delete：同上；</li>
<li>@select：简单的返回单个对象时，和在查询方法上配置sql语句即可。</li>
<li><p>@select：当需要返回集合时：</p>

<pre><code class="language-java">@Select(&quot;select * from user where id=#{id}&quot;)
@Results({
    @Result(id=true,column=&quot;id&quot;,property=&quot;id&quot;),
    @Result(column=&quot;username&quot;,property=&quot;username&quot;),
    @Result(column=&quot;password&quot;,property=&quot;password&quot;),
})
public User getUserById(Integer id);
</code></pre></li>
</ol>

<h4 id="toc_13">关系映射</h4>

<ol>
<li><p>一对一映射：<code>@Result(column=&quot;roleId&quot;,property=&quot;role&quot; one=@One(select=&quot;site.zhanjingbo.mapper.RoleMapper.getRoleById&quot;))</code>;</p></li>
<li><p>一对多： <code>@Result(column=&quot;id&quot;,property=&quot;userList&quot; many=@Many(select=&quot;site.zhanjingbo.mapper.StudentMapper.getUserbyRole&quot;))</code></p></li>
</ol>

<h4 id="toc_14">动态SQL</h4>

<p>实现比较复杂，建议使用XML实现。使用注解效果不是很好。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java康复性训练——MyBatis3(2)]]></title>
    <link href="http://swuzjb.github.io/14689148951216.html"/>
    <updated>2016-07-19T15:54:55+08:00</updated>
    <id>http://swuzjb.github.io/14689148951216.html</id>
    <content type="html"><![CDATA[
<p>接上篇，继续对Mybatis的使用进行介绍。</p>

<blockquote>
<p>代码展示：<a href="https://github.com/swuzjb/MybatisDemo">Github地址</a></p>
</blockquote>

<h2 id="toc_0">Mapper的XML配置</h2>

<p>上一篇的文章当中UserMapper接口只定义了一个addUser的方法。这次我们首先先完善这个接口类。添加写、改、删、查这些方法。</p>

<pre><code class="language-java">package site.zhanjingbo.mapper;

import java.util.List;

import site.zhanjingbo.model.User;

public interface UserMapper {
    public int addUser(User user);
    public int updateUser(User user);
    public int deleteUser(Integer id);
    
    public User getUserById(Integer id);
    public List&lt;User&gt; getAllUser();
    
}
</code></pre>

<h3 id="toc_1">添加XML配置</h3>

<p>配置文件如下：</p>

<pre><code class="language-xml">    &lt;insert id=&quot;addUser&quot; parameterType=&quot;User&quot; useGeneratedKeys=&quot;true&quot; &gt;
        insert into user(username,password) values(#{username},#{password}) 
    &lt;/insert&gt;
</code></pre>

<h3 id="toc_2">修改XML配置</h3>

<pre><code class="language-xml">    &lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt;
        update user set username=#{username},password=#{password} where id=#{id}
    &lt;/update&gt;
</code></pre>

<h3 id="toc_3">删除XML配置</h3>

<pre><code class="language-xml">    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;Integer&quot;&gt;
        delete from user where id=#{id}
    &lt;/delete&gt;
</code></pre>

<h3 id="toc_4">查询XML配置</h3>

<ol>
<li><p>返回单个对象。(注意:对象一定要有对应的构造方法或无参构造)</p>

<pre><code class="language-xml">&lt;select id=&quot;getUserById&quot; parameterType=&quot;Integer&quot; resultType=&quot;User&quot;&gt;
    select * from user where id=#{id}
&lt;/select&gt;
</code></pre></li>
<li><p>返回结构List。</p>

<ol>
<li><p>先声明一个返回类型</p>

<pre><code class="language-xml">&lt;resultMap type=&quot;User&quot; id=&quot;UserList&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
    &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt;
    &lt;result property=&quot;password&quot; column=&quot;password&quot;/&gt;
&lt;/resultMap&gt;
</code></pre></li>
<li><p>声明SQL语句映射</p>

<pre><code class="language-xml">&lt;select id=&quot;getAllUser&quot; resultMap=&quot;UserList&quot;&gt;
    select * from user
&lt;/select&gt;
</code></pre></li>
</ol></li>
</ol>

<h2 id="toc_5">关系映射</h2>

<h3 id="toc_6">一对一关系</h3>

<p>为了更好的展示，我们给User添加一个Role的属性，也就是角色属性。</p>

<ol>
<li><p>建立Role的POJO对象</p>

<pre><code class="language-java">package site.zhanjingbo.model;
public class Role {
    private Integer id;
    private String roleName;

    public Role(){
        super();
    }
    public Role(Integer id, String roleName) {
        super();
        this.id = id;
        this.roleName = roleName;
    }

    public Integer getId() {
        return id;
    }
    public void setId(Integer id) {
        this.id = id;
    }
    public String getRoleName() {
        return roleName;
    }
    public void setRoleName(String roleName) {
        this.roleName = roleName;
    }

    @Override
    public String toString() {
        return &quot;Role [id=&quot; + id + &quot;, roleName=&quot; + roleName + &quot;]&quot;;
    }
}
</code></pre></li>
<li><p>建立Role的Mapper接口</p>

<pre><code class="language-java">package site.zhanjingbo.mapper;

import site.zhanjingbo.model.Role;

public interface RoleMapper {
    public Role getRoleById(Integer id);
}
</code></pre></li>
<li><p>建立Role的Mapper映射文件（注：这里使用的Role 实在config文件中设置了别名）</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;site.zhanjingbo.mapper.RoleMapper&quot;&gt;
    &lt;select id=&quot;getRoleById&quot; parameterType=&quot;Integer&quot;  resultType=&quot;Role&quot;&gt;
        select * from role where id=#{id}
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre></li>
<li><p>修改User的Mapper映射文件，主要修改查询语句的相关返回，设置resultMap为UserResult，其声明如下：</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;site.zhanjingbo.mapper.UserMapper&quot;&gt;  
    &lt;resultMap type=&quot;User&quot; id=&quot;UserResult&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
        &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt;
        &lt;result property=&quot;password&quot; column=&quot;password&quot;/&gt;
        &lt;association property=&quot;role&quot; column=&quot;roleId&quot; select=&quot;site.zhanjingbo.mapper.RoleMapper.getRoleById&quot;&gt;&lt;/association&gt;
    &lt;/resultMap&gt;

    &lt;insert id=&quot;addUser&quot; parameterType=&quot;User&quot; useGeneratedKeys=&quot;true&quot; &gt;
        insert into user(username,password) values(#{username},#{password}) 
    &lt;/insert&gt;
    &lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt;
        update user set username=#{username},password=#{password} where id=#{id}
    &lt;/update&gt;
    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;Integer&quot;&gt;
        delete from user where id=#{id}
    &lt;/delete&gt;
    &lt;select id=&quot;getUserById&quot; parameterType=&quot;Integer&quot; resultMap=&quot;UserResult&quot;&gt;
        select * from user where id=#{id}
    &lt;/select&gt;
    &lt;select id=&quot;getAllUser&quot; resultMap=&quot;UserResult&quot;&gt;
        select * from user
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre></li>
</ol>

<h3 id="toc_7">一对多关系</h3>

<p>一对多关系其实是扩展的一对一关系，我们在这一部分对上面的Role实体进行扩展。在上面我们定义一个用户只能有一个角色，但是一个角色其实可以有多个用户。这就构成了一对多。<br/>
为了展示一对多，我们增加一个根据用户角色查询用户的功能。</p>

<ol>
<li>需要在UserMapper中添加一个根据Role返回User List的方法。</li>
<li>在UserMapper.xml中完善这个方法的SQL语句</li>
<li>在Role中增加UserList属性，并添加getter和setter方法</li>
<li><p>在RoleMapper.xml中增加配置。如下代码展示</p>

<pre><code class="language-xml"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;site.zhanjingbo.mapper.RoleMapper&quot;&gt;
&lt;resultMap type=&quot;Role&quot; id=&quot;RoleResult&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
    &lt;result property=&quot;roleName&quot; column=&quot;roleName&quot;/&gt;
    &lt;collection property=&quot;userList&quot; column=&quot;id&quot; select=&quot;site.zhanjingbo.mapper.UserMapper.getUserByRole&quot;&gt;&lt;/collection&gt;
&lt;/resultMap&gt;
&lt;select id=&quot;getRoleById&quot; parameterType=&quot;Integer&quot;  resultMap=&quot;RoleResult&quot;&gt;
    select * from role where id=#{id}
&lt;/select&gt;
&lt;/mapper&gt;
</code></pre></li>
</ol>

<h3 id="toc_8">多对多关系</h3>

<p>多对多关系可以理解为双向的一对多关系，参照上方的一对多实现，关联中间表即可。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java康复性训练——MyBatis3(1)]]></title>
    <link href="http://swuzjb.github.io/14687533604786.html"/>
    <updated>2016-07-17T19:02:40+08:00</updated>
    <id>http://swuzjb.github.io/14687533604786.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">MyBatis</h2>

<blockquote>
<p>MyBatis是一个支持普通SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis消除了几乎所有的JDBC代码和参数的手工设置以及对结果集的检索封装。MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录。</p>
</blockquote>

<h2 id="toc_1">MyBatis3使用-Hell,World项目</h2>

<p>MyBatis3的使用比较简单。新建一个基本的Mybatis项目需要如下步骤：</p>

<ol>
<li>新建一个Java项目（这句是废话）。</li>
<li>导入相关Jar包。

<ol>
<li>JDBC相关包：mysql-connector-java-5.1.39-bin.jar</li>
<li>MyBatis核心包：mybatis-3.4.1.jar</li>
</ol></li>
<li><p>创建Mybatis配置文件：mybatis-config.xml 位于src目录下</p>

<pre><code class="language-xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
    &lt;!DOCTYPE configuration
      PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
      &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
    &lt;configuration&gt;

      &lt;!--  引入相关JDBC配置文件 --&gt;
      &lt;properties  resource=&quot;jdbc.properties&quot;/&gt;

      &lt;!-- 配置Mybatis运行的数据库环境 --&gt;
      &lt;environments default=&quot;development&quot;&gt;
            &lt;environment id=&quot;development&quot;&gt;
                  &lt;transactionManager type=&quot;JDBC&quot;/&gt;
                  &lt;dataSource type=&quot;POOLED&quot;&gt;
                    &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driverClassName}&quot;/&gt;
                    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
                    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
                    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
                  &lt;/dataSource&gt;
            &lt;/environment&gt;
      &lt;/environments&gt;

      &lt;!-- 对象与数据库映射文件 --&gt;
      &lt;mappers&gt;
        &lt;mapper resource=&quot;site/zhanjingbo/mapper/UserMapper.xml&quot;/&gt;
      &lt;/mappers&gt;
    &lt;/configuration&gt;
</code></pre></li>
<li><p>创建JDBC配置文件:jdbc.properties。（也可直接在上文配置）</p>

<pre><code class="language-txt">jdbc.dirverClassName=com.mysql.jdbc.Dirver
jdbc.url=jdbc:mysql://localhost:3307/user
jdbc.username=root
jdbc.password=

</code></pre></li>
<li><p>创建MyBatis的连接工厂类:</p>

<pre><code class="language-Java">package site.zhanjingbo.util;
import java.io.IOException;
import java.io.InputStream;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

public class SqlSessionFactoryUtil {
    private static SqlSessionFactory sqlSessionFactory; 
    private static SqlSessionFactory getSqlSessionFactory(){

        if(sqlSessionFactory == null){
            InputStream is = null;
            try {
                is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);
                sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
            } catch (IOException e) {
                // TODO Auto-generated catch block
                System.out.println(&quot;配置文件加载失败&quot;);
                e.printStackTrace();
            }
        }
        return sqlSessionFactory;
    }
    public static SqlSession openSession(){
        return getSqlSessionFactory().openSession();
    }
}
</code></pre></li>
<li><p>创建实体数据库访问<em>接口</em>：</p>

<pre><code class="language-java">package site.zhanjingbo.dao;
import site.zhanjingbo.model.User;
public interface UserMapper {
    public int addUser(User user);
}
</code></pre></li>
<li><p>创建映射Mapper配置文件</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;site.zhanjingbo.mapper.UserMapper&quot;&gt;
    &lt;insert id=&quot;addUser&quot; parameterType=&quot;site.zhanjingbo.model.User&quot;&gt;
        insert into user(username,password) values(#{username},#{password}) 
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre></li>
<li><p>创建测试类 </p>

<pre><code class="language-java"> package site.zhanjingbo.test;
 import org.apache.ibatis.session.SqlSession;
 import site.zhanjingbo.mapper.UserMapper;
 import site.zhanjingbo.model.User;
 import site.zhanjingbo.util.SqlSessionFactoryUtil;
 public class MyBatisTest {
    public static void main(String[] args) {
        //获取SqlSession实例
        SqlSession sqlSession = SqlSessionFactoryUtil.openSession();
        //根据sqlSession生成对应的Mapper对象
        UserMapper userDao = sqlSession.getMapper(UserMapper.class);

        User user = new User(&quot;test&quot;, &quot;123&quot;);
        int flag = userDao.addUser(user);

        if(flag &gt; 0){
            System.out.println(&quot;添加成功&quot;);
        }

        //提交事务
        sqlSession.commit();
        //关闭SQLSession
        sqlSession.close();

    }
}
</code></pre></li>
</ol>

<h2 id="toc_2">Mybatis-Config.xml配置文件</h2>

<p>本部分简要描述一下Mybatis-config配置文件的各项内容。<br/>
<code>&lt;configuration&gt;&lt;/configuration&gt;</code>是配置文件xml的根节点，所有配置项都其中。主要包含以下几项：</p>

<h3 id="toc_3">properties参数配置</h3>

<ul>
<li>properties主要包含各类配置信息，可以直接引入properties文件。也可以直接设置键值对。</li>
<li><code>&lt;properties  resource=&quot;jdbc.properties&quot;/&gt;</code> 通过resource来指定配置文件</li>
<li><p>直接写入键值对，写法</p>

<pre><code class="language-xml">&lt;properties&gt;
    &lt;property name=&quot;jdbc.dirverCLassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
 &lt;/properties&gt;
</code></pre></li>
</ul>

<h3 id="toc_4">environments 环境配置</h3>

<p>MyBatis支持多环境配置。可以同时配置多个数据库信息。用<code>&lt;environment&gt;</code>标签表示。</p>

<h4 id="toc_5">environment标签</h4>

<p>每一对<code>&lt;environment&gt;&lt;/environment&gt;</code>标签标示一个数据库环境信息。包含transactionManager、dataSource两个子节点。<br/>
样例代码：</p>

<pre><code class="language-xml">&lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
              &lt;transactionManager type=&quot;JDBC&quot;/&gt;
              &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.dirverClassName}&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
              &lt;/dataSource&gt;
        &lt;/environment&gt;
        &lt;environment id=&quot;test&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.dirverClassName}&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
              &lt;/dataSource&gt;
        &lt;/environment&gt;
 &lt;/environments&gt;
</code></pre>

<h5 id="toc_6">transactionManager事务管理方式</h5>

<p>MyBatis支持两种类型的事务管理器：JDBC和MANAGED(托管)：</p>

<ul>
<li>JDBC：应用程序负责管理数据库连接的声明周期</li>
<li>MANAGED：由应用服务器管理数据库连接的声明周期。（一般商业服务器才有此功能，如JBOSS，WebLogic）</li>
<li><code>&lt;transactionManager type=&quot;JDBC&quot;/&gt;</code></li>
</ul>

<h5 id="toc_7">dataSource数据源</h5>

<p>用来配置数据库数据源信息。类型分为：UNPOOLED,POOLED,JNDI：</p>

<ul>
<li>UNPOOLED：没有连接池，每次数据库操作MyBatis都会新建一个数据库连接，用完后，关闭。适合小并发项目。</li>
<li>POOLED：启用连接池</li>
<li>JNDI：使用服务器配置JNDI数据源获取数据库连接</li>
</ul>

<h3 id="toc_8">typeAliases</h3>

<p>类型别名，通过设置该项目可以给类的完整限定名取别名，方便使用。<br/>
如在上面部分 UserMapper.xml中addUser的参数类别写为<code>site.zhanjingbo.model.User</code>。不方便使用。我们可以在Mybatis-config.xml中加入如下代码：</p>

<pre><code class="language-xml">&lt;typeAliases&gt;
    &lt;typeAlias type=&quot;site.zhanjingbo.model.User&quot; alias=&quot;User&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>

<p>便可以使用<em>User</em>来指代<em>site.zhanjingbo.model.User</em>。</p>

<h3 id="toc_9">Mappers映射</h3>

<p>用于引入Mapper映射文件。有三种比较推荐的配置方式，如下代码：</p>

<pre><code class="language-xml">  &lt;mappers&gt;
    &lt;mapper resource=&quot;site/zhanjingbo/dao/UserMapper.xml&quot;/&gt;
    &lt;mapper class=&quot;site.zhanjingbo.dao.UserMapper&quot;/&gt;
    &lt;!-- 包含这个包下的所有 --&gt;
    &lt;package name=&quot;site.zhanjingbo.dao&quot;/&gt;
  &lt;/mappers&gt;
</code></pre>

<p>示例代码见：<a href="https://github.com/swuzjb/MybatisDemo">https://github.com/swuzjb/MybatisDemo</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java康复性训练-JDBC]]></title>
    <link href="http://swuzjb.github.io/14686724239639.html"/>
    <updated>2016-07-16T20:33:43+08:00</updated>
    <id>http://swuzjb.github.io/14686724239639.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">什么是JDBC</h2>

<blockquote>
<p>JDBC(Java Data Base Connectivity，Java数据库链接)是一种用于执行SQL语句的Java API。可以为多种关系数据库提供统一的访问，它由一组Java语言编写的类和接口组成。JDBC提供了一种标准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。</p>
</blockquote>

<h3 id="toc_1">JDBC原理</h3>

<p>JDBC原理：JDBC是以前SUN公司定义的一套访问数据库的接口（没有具体实现），具体实现是由各大数据库厂商自己实现的。每个数据库厂商都有自己的JDBC实现，也被称为JDBC驱动实现类。Java应用程序连接指定数据库，需要使用厂家提供的JDBC驱动才能连接。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-07-16-14686740816527.jpg" alt=" " class="mw_img_center" style="display: block; clear:both; margin: 0 auto;"/></p>

<h2 id="toc_2">JDBC链接数据库步骤</h2>

<ol>
<li>加载驱动</li>
<li>链接数据库</li>
<li>使用语句操作数据库</li>
<li>关闭数据库，释放资源</li>
</ol>

<h3 id="toc_3">在项目中配置数据库驱动（Eclipse）</h3>

<p>右击项目-&gt;Build Path-&gt;Configure Build Path-&gt; Add External JARS</p>

<h3 id="toc_4">加载JDBC驱动</h3>

<p>MySQL JDBC 驱动名称：<em>com.mysql.jdbc.Driver</em><br/>
加载方式：<code>Class.forName(&quot;驱动名&quot;);</code></p>

<h3 id="toc_5">连接及关闭数据库</h3>

<ol>
<li><p>DriverManager 驱动管理类，主要负责一个数据的连接。<code>static Connection getConnection(String url, String user, String password)</code>试图建立到给定数据库 URL 的连接。</p></li>
<li><p>Mysql 数据的连接地址格式：</p>

<ul>
<li>jdbc:mysql://127.0.0.1:3306/DataBaseName</li>
<li>jdbc协议：JDBC URL 中的协议总是jdbc</li>
<li>子协议： 驱动程序名称或数据库连接机制（这种驱动可由一个或多个驱动程序支持）的名称如：mysql</li>
<li>子名称：一种标示数据库的方法。必须遵循<em>//主机名：端口/数据库</em>的标准URL命名约定，如：<code>//localhost:3306/test</code></li>
</ul></li>
<li><p>Connection接口：与特定的数据库的连接(也称为会话)。</p>

<ul>
<li><code>void close()</code>立即释放此Connection对象的数据库和JDBC资源，而不是等待自动释放</li>
</ul></li>
</ol>

<h4 id="toc_6">Demo Code</h4>

<p>封装一个用于获取和关闭连接的工具类DBTool。</p>

<pre><code class="language-Java">package com.swu.JDBC;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class DBTool {
    public static Connection getConnection(){
        String dbURL = &quot;jdbc:mysql://localhost:3306/test&quot;;
        String username = &quot;root&quot;;
        String password = &quot;&quot;;
        Connection conn = null;
        try {
            //注册驱动类
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            //获取连接
            conn = DriverManager.getConnection(dbURL,username,password);
            
        } catch (ClassNotFoundException e) {
            // TODO Auto-generated catch block
            System.out.println(&quot;加载驱动失败&quot;);
            e.printStackTrace();
        } catch (SQLException e) {
            System.out.println(&quot;连接失败&quot;);
            e.printStackTrace();
        }
        return conn;
    }
    public static void closeConnection(Connection conn){
        try {
            conn.close();
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            System.out.println(&quot;关闭失败&quot;);
            e.printStackTrace();
        }
    }
}

</code></pre>

<h2 id="toc_7">使用Statement接口实现数据的增、删、改、查</h2>

<h3 id="toc_8">Statement接口</h3>

<ul>
<li>作用：用于执行静态SQL语句并返回它所产生的结果的对象。</li>
<li><code>int executeUpdate(String sql)</code> 执行给定SQL语句。该语句可能为INSERT,UPDATE,DELETE语句或者不返回人格内容的SQL语句。</li>
<li><code>void close()</code> 立即释放此Statement对象的数据库和JDBC资源，而不是等待对象自动关闭时发生此操作。</li>
</ul>

<h4 id="toc_9">Statement接口实现添加数据操作</h4>

<p>demo如下：</p>

<pre><code class="language-java">public void addUser(String username,String password){
        Connection conn = DBTool.getConnection();
        String sql = &quot;insert into user(username,password) values(&#39;&quot;+username+&quot;&#39;,&#39;&quot;+password+&quot;&#39;)&quot;;
        Statement stmt = null;
        try {
            //通过Connection获取Statement
            stmt = conn.createStatement();
            int result = stmt.executeUpdate(sql);
            System.out.println(result);
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                stmt.close();
                DBTool.closeConnection(conn);
            } catch (SQLException e) {
                e.printStackTrace();
            }
            
        }
    }
</code></pre>

<h4 id="toc_10">Statement接口实现修改数据操作</h4>

<p>demo如下：</p>

<pre><code class="language-java">    public void updateUser(int id,String username,String password){
        Connection conn = DBTool.getConnection();
        String sql = &quot;update user set username=&#39;&quot;+username+&quot;&#39;,password=&#39;&quot;+password+&quot;&#39; where id=&quot;+id;
        Statement stmt = null;
        try {
            //通过Connection获取Statement
            stmt = conn.createStatement();
            int result = stmt.executeUpdate(sql);
            System.out.println(result);
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                stmt.close();
                DBTool.closeConnection(conn);
            } catch (SQLException e) {              e.printStackTrace();
            }
            
        }
    }
</code></pre>

<h4 id="toc_11">Statement接口实现删除数据操作</h4>

<p>demo如下：</p>

<pre><code class="language-java">    public void deleteUser(int id){
        Connection conn = DBTool.getConnection();
        String sql = &quot;delete from user where id=&quot;+id;
        Statement stmt = null;
        try {
            //通过Connection获取Statement
            stmt = conn.createStatement();
            int result = stmt.executeUpdate(sql);
            System.out.println(result);
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                stmt.close();
                DBTool.closeConnection(conn);
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
</code></pre>

<h4 id="toc_12">Statment接口实现数据查询</h4>

<p>demo如下（里面的ResultSet后面详细介绍）:</p>

<pre><code class="language-java">public void getAllUser(){
        Connection conn = DBTool.getConnection();
        String sql = &quot;select * from user&quot;;
        Statement stmt = null;
        //保存查询返回结果
        ResultSet rs = null;
        try {
            stmt = conn.createStatement();
            rs = stmt.executeQuery(sql);
            while(rs.next()){
                System.out.println(rs.getInt(1)+&quot;\t&quot;+rs.getString(2)+&quot;\t&quot;+rs.getString(3));
            }
        } catch (SQLException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }finally {
            try {
                rs.close();
                stmt.close();
                conn.close();
            } catch (SQLException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
            
        }
}
</code></pre>

<h3 id="toc_13">PreparedStatement接口</h3>

<p>PreparedStatement是Statement的子接口，是一个SQL语句预处理Statement。与直接Statement不同的是PreparedStatement在操作时，是先在数据表中准备好了一条SQL语句，但是此SQL语句的内容暂时不设置，而是之后再进行设置。<em>实际开发过程中建议使用PreparedStatement，可以避免一定的SQL注入问题</em></p>

<h4 id="toc_14">PreparedStatement接口实现数据添加</h4>

<p>demo如下:</p>

<pre><code class="language-java">    public void addUser(String username,String password) throws Exception{
        //预处理SQL语句
        String sql = &quot;insert into user(username,password) values(?,?)&quot;;
        Connection conn = DBTool.getConnection();
        //获得PreparedStatement对象
        PreparedStatement stmt = conn.prepareStatement(sql);
        //设置预处理占位符的实际值
        stmt.setString(1, username);
        stmt.setString(2, password);
        //执行添加
        stmt.executeUpdate();
        
        DBTool.closeConnection(stmt, conn);
    }
</code></pre>

<h4 id="toc_15">PreparedStatement接口实现数据修改</h4>

<p>demo如下：</p>

<pre><code class="language-java">    public void updateUser(int id,String username,String password) throws SQLException{
        String sql = &quot;update user set username=?,password=? where id=?&quot;;
        Connection conn = DBTool.getConnection();
        PreparedStatement stmt = conn.prepareStatement(sql);
        
        stmt.setString(1, username);
        stmt.setString(2, password);
        stmt.setInt(3, id);
        
        stmt.executeUpdate();
        
        DBTool.closeConnection(stmt, conn);
        
    }
</code></pre>

<h3 id="toc_16">PreparedStatement接口实现数据删除</h3>

<p>demo如下：</p>

<pre><code class="language-java">    public void deleteUser(int id) throws SQLException{
        String sql = &quot;delete from user where id = ?&quot;;
        Connection conn = DBTool.getConnection();
        PreparedStatement stmt = conn.prepareStatement(sql);
        
        stmt.setInt(1, id);
    
        stmt.executeUpdate();
        
        DBTool.closeConnection(stmt, conn);
    }
</code></pre>

<h4 id="toc_17">PreparedStatement接口实现数据查询</h4>

<p>demo如下：</p>

<pre><code class="language-java">    public void getUserByUsername(String username) throws SQLException{
        String sql = &quot;select * from user where username=?&quot;;
        Connection conn = DBTool.getConnection();
        PreparedStatement stmt = conn.prepareStatement(sql);
        
        stmt.setString(1, username);
    
        ResultSet rs = stmt.executeQuery();
        
        while(rs.next()){
            System.out.println(rs.getInt(1)+&quot;\t&quot;+rs.getString(2)+&quot;\t&quot;+rs.getString(3));
        }
        
        DBTool.closeConnection(stmt, conn);
    }
</code></pre>

<h3 id="toc_18">ResultSet结果集</h3>

<blockquote>
<p>当我们对数据库的数据进行查询的时候，返回的是一个二维的结果集。我们这个时候需要使用ResultSet来遍历结果集，获取每一行的数据。</p>
</blockquote>

<h4 id="toc_19">获取数据</h4>

<ul>
<li><code>boolean next()</code>将光标从当前位置向前移动一行</li>
<li><code>String getString(int columnIndex)</code>以String的形式获取此ResultSet对象的当前行中指定列的值。</li>
<li><code>String getString(String columnLabel)</code>以String的形式获取此ResultSet对象的当前行中指定列的值。</li>
</ul>

<h4 id="toc_20">使用例子</h4>

<p>见上方实现的数据查询。</p>

<h3 id="toc_21">处理大数据对象</h3>

<blockquote>
<p>大数据对象处理主要有CLOB(character large object)和BLOB(binary large object)两种类型的字段。在CLOB中可以存储大字符数据对象，比如长篇小说;在BLOB中可以存放二进制大数据对象，比如图片、电影、音乐</p>
</blockquote>

<h4 id="toc_22">处理CLOB数据</h4>

<ul>
<li>使用PreparedStatement插入数据。<code>statement.setAsciiStream(parameterIndex, x, length);</code></li>
<li>使用ResultSet读取数据。<code>resultSet.getClob(String columnLabel);</code>获得一个Clob对象，然后可以转为字符串对象。</li>
</ul>

<h4 id="toc_23">处理BLOB数据</h4>

<ul>
<li>使用PreparedStatement插入数据。<code>statement.setBinaryStream(parameterIndex, x, length);</code></li>
<li>使用ResultSet读取数据。<code>resultSet.getBlob(String columnLabel);</code>获得一个Blob对象，然后可以转为目标对象。</li>
</ul>

<h3 id="toc_24">使用CallableStatement接口调用存储过程</h3>

<blockquote>
<p>CallableStatement 主要是调用数据库中的存储过程,CallableStatement 也是 Statement 接口的子接口。在使用 CallableStatement 时可以接收存储过程的返回值。 </p>
</blockquote>

<h3 id="toc_25">使用DatabaseMetaData分析数据库</h3>

<blockquote>
<p>DatabaseMetaData可以得到数据库的一些基本信息,包括数据库的名称、版本,以及得到表的信息。 </p>
</blockquote>

<ul>
<li><code>String getDatabaseProductName()</code> 获取此数据库产品的名称。</li>
<li><code>int getDriverMajorVersion()</code>获取此 JDBC 驱动程序的主版本号。</li>
<li><code>int getDriverMinorVersion()</code> 获取此 JDBC 驱动程序的次版本号。 </li>
</ul>

<h3 id="toc_26">使用 ResultSetMetaData 获取 ResultSet 对象中的信息</h3>

<blockquote>
<p>ResultSetMetaData 可获取关于 ResultSet 对象中列的基本信息;</p>
</blockquote>

<ul>
<li><code>int getColumnCount()</code> 返回此 ResultSet 对象中的列数。</li>
<li><code>String getColumnName(int column)</code> 获取指定列的名称。 </li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java康复性训练——Java基础1]]></title>
    <link href="http://swuzjb.github.io/14676190809439.html"/>
    <updated>2016-07-04T15:58:00+08:00</updated>
    <id>http://swuzjb.github.io/14676190809439.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">开发环境搭建</h2>

<h3 id="toc_1">JDK的安装与配置</h3>

<ol>
<li>下载JavaSE版本的安装包。</li>
<li>双击安装，选定安装目录</li>
<li>配置环境变量

<ul>
<li>JAVA_HOME JDK的安装目录</li>
<li>path(在此项中添加)   %JAVA_HOME%\bin</li>
</ul></li>
</ol>

<h3 id="toc_2">开发工具eclipse</h3>

<p>下载地址：<a href="http://eclipse.org"></a></p>

<h2 id="toc_3">Hello Java</h2>

<pre><code class="language-java">
public class Hello {

    public static void main(String[] args) {
        System.out.println(&quot;Hello Java&quot;);
    }

}

</code></pre>

<h2 id="toc_4">输入</h2>

<p>利用Scanner扫描器对数据进行读取：<code>Scanner in = new Scanner(System.in);</code></p>

<h2 id="toc_5">变量</h2>

<p>变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。变量可以通过变量名访问。</p>

<p><code>int price = 0;</code>这一行定义了一个变量。变量的名字是price，类型是int，初始值是0。</p>

<p>Java是一种强类型语言，所有的变量在使用之前必须定义或声明，所有的变量必须具有确定的数据类型。数据类型表示在变量中可以存放什么样的数据，变量中只能存放指定类型的数据，程序运行过程中也不能改变变量的类型。</p>

<h2 id="toc_6">赋值</h2>

<p><code>=</code>在计算机中表示赋值。<code>A = B</code>表示将B的值赋给A。</p>

<h2 id="toc_7">浮点数</h2>

<p>两个整数的运算结果只能是整数。10和10.0在程序中是不一样的概念。<br/>
带小数点的数值。浮点这个词的本意就是指小数点是浮动的，是计算机内部表示非整数（包含分数和无理数）的一种方式。人们借用浮点数这个词来表示所有带小数点的数。</p>

<h2 id="toc_8">优先级</h2>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-07-05-14676900576214.jpg" alt=""/></p>

<h2 id="toc_9">类型转换</h2>

<p>就一个值得类型转变为新的类型并赋值给新的变量。</p>

<pre><code class="language-java">float a = 1.0;
int b = (int)a;
</code></pre>

<h2 id="toc_10">关系运算</h2>

<p>计算两个值之间的关系，叫做关系运算<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-07-06-14677691671515.jpg" alt=""/><br/>
判断两个浮点数是否相等</p>

<pre><code class="language-java">double a = 1.0;
double b = 0.1+0.1+0.1+0.1+0.1+0.1+0.1+0.1+0.1+0.1;
System.out.println(Math.abs(a-b)&lt;1e6);
</code></pre>

<h2 id="toc_11">IF语句</h2>

<p>一个基本的if语句由一个关键字if开头，跟上在括号里的一个表示条件的逻辑表达式，然后是一对大括号{}之间的若干条语句。如果表示条件的逻辑表达式的结果为true，那么就执行后面跟着的这对大括号中的语句，否则就跳过这些语句不执行，而继续执行下面的其他语句。</p>

<pre><code class="language-java">if(?){
    //do something
}else{
    //do something
}
</code></pre>

<h2 id="toc_12">多路分支（Switch-Case）</h2>

<pre><code class="language-java">switch (整型或字符型变量){
    case 变量可能值1: 
      　  分支一;
        　break;
   case 变量可能值2: 
      　  分支二;
        　break;
   case 变量可能值3: 
      　  分支三;
        　break;
   ...
   default:
       最后分支;
｝
</code></pre>

<h2 id="toc_13">循环</h2>

<h3 id="toc_14">while循环</h3>

<p>可能一次都不执行</p>

<pre><code class="language-java">while(true){
    //doSomthing..
}
</code></pre>

<h3 id="toc_15">do-while循环</h3>

<p>至少执行一次</p>

<pre><code class="language-java">do{
    //doSomething..
}while();
</code></pre>

<h3 id="toc_16">for循环</h3>

<pre><code class="language-java">for(int i = ?;i&lt;?;i++){
    //doSomething
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GeekBand.Swift-Homework13]]></title>
    <link href="http://swuzjb.github.io/14640741638557.html"/>
    <updated>2016-05-24T15:16:03+08:00</updated>
    <id>http://swuzjb.github.io/14640741638557.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">题目</h2>

<p>请说出下面代码存在的问题，以及改进方式。</p>

<pre><code class="language-swift">class Customer{
    let name:String;
    var card:CreditCard?;
    init(name:String){
        self.name = name;
    }
    deinit{
        print(&quot;\(name) is being deinitialized&quot;);
    }
}
class CreditCard{
    let number:UInt64;
    let customer:Customer;
    init(number:UInt64,customer:Customer){
        self.number = number;
        self.customer = customer;
    } 
    deinit{
        print(&quot;Card #\(number) is being deinitialized&quot;);
    }
}
</code></pre>

<h2 id="toc_1">回答</h2>

<h3 id="toc_2">问题分析</h3>

<p>题目代码所描述的关系为用户——信用卡关系。在设计过程中，用户类中有信用卡属性，信用卡中有用户属性。<br/>
如果在实际操作过程中，执行如下代码：</p>

<pre><code class="language-swift">var customer :Customer?;
customer = Customer(name:&quot;Jobs&quot;);
var card :CreditCard;
card = CreditCard(number: 10000,customer: customer!);
customer!.card = card;
</code></pre>

<p>执行之后内存关系如图：<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-05-24-14640753860457.jpg" alt=""/><br/>
可见，执行之后card和customer之间构成了循环引用，在ARC(自动引用计数)模式之下，会导致两个变量没办法被回收，造成内存溢出。执行如下代码：</p>

<pre><code class="language-swift">card = nil;
customer = nil;
</code></pre>

<p>内存关系如图：<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-05-24-14640756280185.jpg" alt=""/></p>

<p>card和customer的引用计数非0，无法吸收。</p>

<h3 id="toc_3">解决方法</h3>

<h4 id="toc_4">方案A——手动打破循环引用</h4>

<p>程序员通过自己的操作，打破循环引用，使引用计数减少。</p>

<pre><code class="language-swift">card = nil;
customer.card = nil;
customer = nil;
</code></pre>

<p>执行结果，deinit析构器成功执行<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-05-24-14640760729455.jpg" alt=""/></p>

<h4 id="toc_5">方案B-weak(弱)引用</h4>

<p>弱引用是语言提供的打破循环引用的方式，弱引用在计算引用计数时计算。代码如下：</p>

<pre><code class="language-swift">class Customer{
    let name:String;
    //注意这里！！
    weak var card:CreditCard?;
    init(name:String){
        self.name = name;
    }
    deinit{
        print(&quot;\(name) is being deinitialized&quot;);
    }
}
class CreditCard{
    let number:UInt64;
    let customer:Customer;
    init(number:UInt64,customer:Customer){
        self.number = number;
        self.customer = customer;
    }
    
    deinit{
        print(&quot;Card #\(number) is being deinitialized&quot;);
    }
}

var customer :Customer?;
customer = Customer(name:&quot;Jobs&quot;);
var card :CreditCard?;
card = CreditCard(number: 10000,customer: customer!);
customer!.card = card;

card = nil;
customer = nil;
</code></pre>

<p>内存结构:<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-05-24-14640768586804.jpg" alt=""/><br/>
执行结果，deinit析构器成功执行<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-05-24-14640769060387.jpg" alt=""/></p>

<h4 id="toc_6">方案C-unowned(无主)引用</h4>

<p>如果不允许属性的值为nil，我们可以将其设置为unowned引用，打破循环引用。</p>

<pre><code class="language-swift">class Customer{
    let name:String;
    var card:CreditCard?;
    init(name:String){
        self.name = name;
    }
    deinit{
        print(&quot;\(name) is being deinitialized&quot;);
    }
}
class CreditCard{
    let number:UInt64;
    //注意这里！！！！
    unowned let customer:Customer;
    init(number:UInt64,customer:Customer){
        self.number = number;
        self.customer = customer;
    }
    
    deinit{
        print(&quot;Card #\(number) is being deinitialized&quot;);
    }
}

var customer :Customer?;
customer = Customer(name:&quot;Jobs&quot;);
var card :CreditCard?;
card = CreditCard(number: 10000,customer: customer!);
customer!.card = card;
card = nil;
customer = nil;
</code></pre>

<p>内存模型：<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-05-24-14640773927457.jpg" alt=""/><br/>
执行结果，deinit析构器成功执行。<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-05-24-14640774704318.jpg" alt=""/></p>

<h5 id="toc_7">方案B和C的区别</h5>

<p>弱引用在对象被释放后，ARC会将引用设置为nil,无主引用在对象被释放后，ARC不会设置nil，访问是会抛运行时错误（空悬指针）。</p>

<h2 id="toc_8">写在最后</h2>

<p>其实还有一个不太合理的，Customer应该可以拥有多张卡。所以card属性应该为</p>

<pre><code class="language-swift">var cards:Array&lt;CreditCard&gt;?;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GeekBand.Swift-集合类型]]></title>
    <link href="http://swuzjb.github.io/14635750426080.html"/>
    <updated>2016-05-18T20:37:22+08:00</updated>
    <id>http://swuzjb.github.io/14635750426080.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">数组(Array)</h2>

<p>数组是一个有序的元素序列，支持随机存储，支持动态更新长度。<br/>
索引从0开始，依次递增。索引访问越界时会抛出异常。<br/>
在Swift中，Array被定义为Struct类型，值类型，拷贝时具有值语义。但是，它内部却包含一个指向堆上的元素指针。其指向真正存放的数组元素。</p>

<h3 id="toc_1">内存模型</h3>

<p><img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-05-18-14635752854229.jpg" alt=""/></p>

<h3 id="toc_2">使用数组</h3>

<p>数组支持变量或常量。常量数组的长度和元素内容都不能更改。</p>

<pre><code class="language-swift">//数组声明与实例化
var array1=[1,2,3,4,5];
var array2:[Int];
var array3:Array&lt;Int&gt;;
array2=[Int](count:10, repeatedValue:10);
array3=[Int]();

//变量数组和常量数组
var array5=[1,2,3]
let array6=[1,2,3]
</code></pre>

<h4 id="toc_3">数组遍历</h4>

<ul>
<li>使用<code>for</code>循环访问array需要检查索引是否越界。具有性能代价。</li>
<li>尽可能使用<code>for-in</code>来遍历数组元素；或者使用<code>Array.enumerate()</code>遍历索引；二者在编译器层面会优化掉索引检查。</li>
</ul>

<pre><code class="language-swift">for item in array5{
    print(item);
}

for(index, value) in array5.enumerate(){
    print(&quot;\(index): \(value)&quot;);
}

for index in 0..&lt;array5.count {
    print(array5[index]);
}
</code></pre>

<h4 id="toc_4">缓存容量与增长</h4>

<ul>
<li>数组初始化后，会分配一个缓存容量capacity,其长度一般大于实际的元素数量</li>
<li>当数组长度增长时，如果实际需求大于capacity，其capacity会以近似二倍的方式指数增长，产生对应代价：

<ul>
<li>分配新的堆内存 2*capacity</li>
<li>将原来堆内存上的元素拷贝到新内存</li>
<li>释放原来的内存</li>
</ul></li>
<li>最佳实践：估计好capacity，预先分配好一定的容量。避免频繁造成capacity的增长。</li>
</ul>

<h4 id="toc_5">copy-on-write共享技术</h4>

<p>同一个数组拷贝到不同的变量中时，其指向堆的元素指针不变。即不同的变量共享一份内存空间，从而节省内存开销。<br/>
但是，当某一个变量的元素内容发生改变时，先将原来的堆内存拷贝一份，元素指针指向新的拷贝，然后再更改新的拷贝，从而确保正确性。<br/>
copy-on-write的目的是实现“元素内容相同的数组共享内存，同时支持元素的随时修改”<br/>
更改前：<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-05-18-14635762688451.jpg" alt=""/><br/>
更改后：<br/>
<img src="http://7xrsyo.com1.z0.glb.clouddn.com/2016-05-18-14635762803954.jpg" alt=""/></p>

<h2 id="toc_6">集合类型(Set)</h2>

<p>Set是一个无序集合，其存储的值不能重复。<br/>
Set中的值必须有哈希值，即支持Hashable协议。<br/>
Set被定义为Struct，值类型，与Array类似。</p>

<pre><code class="language-swift">var set = Set&lt;String&gt;();
var set2:Set&lt;String&gt;;
set2 = [&quot;shanghai&quot;,&quot;beijing&quot;];
</code></pre>

<h2 id="toc_7">字典类型(Dictionary)</h2>

<p>Dictionary是一个存储Key—Value的无序的集合，key唯一，value可重复。<br/>
Dictionary中的Key必须支持Hashable协议。<br/>
Dictionary被定义为Struct，值类型，特征与Array一致。</p>

<pre><code class="language-swift">var dictionary1 = [String:Int]()；
var dictionary2 : Dictionary&lt;String,Int&gt;；
dictionary2=[&quot;Jason&quot;:36, &quot;Tom&quot;:31, &quot;Marty&quot;:44]；

for(name, age) in dictionary2{
    print(&quot;The Age of \(name) is: \(age)&quot;)
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GeekBand.Swift-协议]]></title>
    <link href="http://swuzjb.github.io/14634889513152.html"/>
    <updated>2016-05-17T20:42:31+08:00</updated>
    <id>http://swuzjb.github.io/14634889513152.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>协议，在很多语言中也叫作接口，常用于定义一套规范，使用者可以根据自己的不同需求，进行不同的实现。<br/>
协议：类型的约束合同，只描述外部的接口，不提供具体的实现</p>
</blockquote>

<h2 id="toc_0">协议的成员</h2>

<p>协议可以包含如下成员：属性、方法、初始化器、下标、操作符</p>

<h2 id="toc_1">协议的使用</h2>

<p>一个类型可以实现多个协议。协议可以应用在<em>类</em>、<em>结构</em>、<em>枚举</em>上。</p>

<pre><code class="language-swift">protocol  Drawable{
    var description: String{
        get
    }
    func draw();
    init(); 
    subscript(index: Int) -&gt; Int {
        get
    }
    func ==(leftValue: Self, rightValue: Self) -&gt; Bool
}
class Image :Drawable{
    var description:String{
        get{
            return self.description;
        }
    }
    func draw(){
        print(&quot;draw&quot;);
    }
    ……
}
</code></pre>

<p>协议本质上是一种类型，可以最为声明类型，但是无法创建实例。<br/>
协议变量的内存模型遵从实际类型的内存模型：</p>

<ul>
<li>引用类型传参、拷贝采用传引用的方式</li>
<li>值类型传参、拷贝采用值拷贝方式</li>
</ul>

<h3 id="toc_2">检查协议类型实现</h3>

<ul>
<li>使用is检查类型是否实现了协议</li>
<li>使用as?和as!将类型转换为协议</li>
</ul>

<h3 id="toc_3">协议中的属性</h3>

<ol>
<li>协议可以定义只读属性或读写属性</li>
<li>协议可以定义实例属性，也可以定义类型属性</li>
<li>协议只能定义变量属性，不能定义常量属性</li>
<li>实现属性时，可以实现为存储属性或计算属性</li>
</ol>

<h3 id="toc_4">协议中的方法</h3>

<ol>
<li>协议可以定义实例方法，也可以定义类型方法</li>
<li>协议中的方法不能定义参数的默认值</li>
<li>针对值类型的mutaing协议方法：

<ul>
<li>值类型实现的实例方法如果要修改实例本身，需要在协议方法的定义中标明mutaing关键字。同时在方法实现时也添加该关键字。</li>
<li>添加了mutaing的协议方法，对类的实现方法无影响。</li>
</ul></li>
</ol>

<h3 id="toc_5">协议中的初始化器</h3>

<ol>
<li>协议可以定义初始化器，但不可以定义析构器</li>
<li>当class中实现协议定义的初始化器时，需要添加required关键字。

<ul>
<li>标明子类也需要提供该初始化器</li>
<li>如果定义为final类，则不需要添加required关键字</li>
</ul></li>
<li>协议可以定义可失败的初始化器init?，具体实现时可以失败或成功。</li>
</ol>

<h3 id="toc_6">更多协议形式</h3>

<ul>
<li>协议继承

<ul>
<li>一个协议可以继承一个或多个协议</li>
<li>实现子协议的类型，也必须实现父协议</li>
</ul></li>
<li>协议组合

<ul>
<li>可以使用protocol<A,B,....>来组合多个协议</li>
<li>实现组合协议的类型，必须实现组合中的每一个协议</li>
<li>组合协议是一个临时类型</li>
</ul></li>
<li>可选协议

<ul>
<li>协议的某些成员可以定义为optional,不必实现</li>
<li>可选协议只能用于class</li>
<li>可选协议必须标明@objc特性</li>
</ul></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GeekBand.Swift-面向对象]]></title>
    <link href="http://swuzjb.github.io/14633841095158.html"/>
    <updated>2016-05-16T15:35:09+08:00</updated>
    <id>http://swuzjb.github.io/14633841095158.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>面向对象三大特性：封装、继承、多态</p>
</blockquote>

<h2 id="toc_0">封装</h2>

<p>封装值得是隐藏类的一部分内部结构，避免外部访问或者外部直接访问，只有类自身可以操作。<br/>
通常，我们使用<code>getter</code>和<code>setter</code>来达到封装的目的。</p>

<h3 id="toc_1">访问控制符</h3>

<ol>
<li>private —— private访问级别所修饰的属性或者方法只能在当前的Swift源文件里可以访问。</li>
<li>internal（默认访问级别，internal修饰符可写可不写）—— internal访问级别所修饰的属性或方法在源代码所在的整个模块都可以访问。如果是框架或者库代码，则在整个框架内部都可以访问，框架由外部代码所引用时，则不可以访问。如果是App代码，也是在整个App代码，也是在整个App内部可以访问。</li>
<li>public —— 可以被任何人使用</li>
</ol>

<h3 id="toc_2">一个例子</h3>

<p>假设我们想要创建一个代表圆的类，那么圆的半径应该是可以改变的。而且，该圆的面积和周长应该可以从圆的实例中获取，而这两个属性不应该被类本身以外所更改。出于性能考虑，面积和周长也应该只计算一次。</p>

<pre><code class="language-swift">class Circle {
    private var area: Double = 0;
    private var diameter: Double = 0;
    var radius: Double {
        didSet {
            calculateFigures();
        }
    }
    init(radius:Double) {
        self.radius = radius;
        calculateFigures();
    }
    private func calculateFigures() {
        area = M_PI * radius * radius;
        diameter = 2 * M_PI * radius;
    }

    func getArea() -&gt; Double {
        return self.area;
    }

    func getDiameter() -&gt; Double {
        return self.diameter;
    } 
}
</code></pre>

<p>Swift还为我们提供了简便方法。<br/>
通过在属性前面使用<code>private(set)</code>，属性就被设置为默认访问等级的 <code>getter</code>方法，但是<code>setter</code>方法是私有的。所以我们可以去掉两个 <code>getter</code>方法：</p>

<pre><code class="language-swift">class Circle {
    private(set) var area: Double = 0;
    private(set) var diameter: Double = 0;
    var radius: Double {
        didSet {
            calculateFigures()
        }
    }
    init(radius:Double) {
        self.radius = radius
        calculateFigures()
    }
    private func calculateFigures() {
        area = M_PI * radius * radius
        diameter = 2 * M_PI * radius
    }
}
</code></pre>

<p>当然也可以为属性设置公有的getter方法：</p>

<pre><code class="language-switf">public private(set) var area: Double = 0
public private(set) var diameter: Double = 0
</code></pre>

<h2 id="toc_3">继承</h2>

<p>面向对象中，非常重要的一个概念。通过继承，子类可以拥有父类(超类)中的方法和属性，对代码进行复用。<br/>
在Swift中，子类继承父类的属性、方法、下标。</p>

<h3 id="toc_4">一个例子</h3>

<pre><code class="language-swift">struct Point{
    var x=0;
    var y=0;
}
class Shape{
    var no=0;
    func move() {
        print(&quot;NO: \(no) Shape.move&quot;);
    }
}
class Rectangle: Shape{
    var leftUp=Point();
    var width=0;
    var height=0;
    
}
class Circle: Shape{
    var center=Point();
    var radius=0;
}
</code></pre>

<p>Rectangle和Circle就继承了Shape中的方法和属性。</p>

<h3 id="toc_5">方法重写</h3>

<p>有的时候，我们需要在子类中对父类的某一个方法进行加工。就需要进行方法的重写。在Swift中，对于方法的重写，必须添加Override关键字。</p>

<pre><code class="language-swift">class Shape{
    var no=0;
    //用final关键字修饰，子类无法重写
    final func show(){
        print(&quot;Shape.show&quot;);
    }
    func move() {
        print(&quot;Shape.move&quot;);
    }
}
class Rectangle: Shape{
    //重写父类的no属性
    override var no: Int {
        get{
            print(&quot;Rectangle.no.get()&quot;);
            return super.no;
        }
        set{
            print(&quot;Rectangle.no.set()&quot;);
            super.no=newValue;
        }
    }
    override func move() {
        print(&quot;Rectangle.move&quot;);
    }
    
}
class Circle: Shape{
    override func move() {
        print(&quot;Circle.move&quot;);
    }
}
</code></pre>

<h3 id="toc_6">继承中的初始化器和析构器</h3>

<h4 id="toc_7">初始化器</h4>

<ul>
<li>如果子类没有定义初始化器，则自动继承父类的初始化器</li>
<li>如果子类定义了初始化器，则不再继承。此时子类的初始化器必须调用父类的一个初始化器。如果手工不调用，编译器将自动生成调用。</li>
<li>如果子类的初始化器与父类的初始化器原型一致，必须使用override</li>
<li>在子类中使用父类属性，必须确保首先调用父类初始化器</li>
</ul>

<h4 id="toc_8">析构器</h4>

<ul>
<li>如果子类没有定义析构器，会自动继承父类的析构器</li>
<li>子类析构器执行完毕后，会自动调用父类析构器</li>
<li>子类析构器自动具有多态性</li>
</ul>

<h2 id="toc_9">多态</h2>

<p>多态，也是面向对象的三大特性之一。即父类引用指向子类对象。在Swift中，每个属性都有两个类型，一个是声明类型，一个是实际类型。这两个类型在值类型中是相等的。但是在类中，可能不同。但是实际类型一定是声明类型本身或其子类。</p>

<pre><code class="language-swift">//如下代码是没有问题的
var rect:Shape;
rect = Rectangle();
//当我们调用rect的move方法的时候，实际调用的是Rectangle中的Move方法。
rect.move();

</code></pre>

<p>也可以将多态描述为：子类在同一行为接口下，表现不同的实现方式。</p>

]]></content>
  </entry>
  
</feed>
